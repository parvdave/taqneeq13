! function() {
    "use strict";
    Ip = function() {
        function t(e) { var n = this.constructor; return this.then(function(t) { return n.resolve(e()).then(function() { return t }) }, function(t) { return n.resolve(e()).then(function() { return n.reject(t) }) }) }
        var e = setTimeout;

        function c(t) { return Boolean(t && void 0 !== t.length) }

        function r() {}

        function o(t) {
            if (!(this instanceof o)) throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof t) throw new TypeError("not a function");
            this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], h(t, this)
        }

        function i(n, r) {
            for (; 3 === n._state;) n = n._value;
            0 !== n._state ? (n._handled = !0, o._immediateFn(function() {
                var t, e = 1 === n._state ? r.onFulfilled : r.onRejected;
                if (null !== e) {
                    try { t = e(n._value) } catch (t) { return void s(r.promise, t) }
                    a(r.promise, t)
                } else(1 === n._state ? a : s)(r.promise, n._value)
            })) : n._deferreds.push(r)
        }

        function a(e, t) {
            try {
                if (t === e) throw new TypeError("A promise cannot be resolved with itself.");
                if (t && ("object" == typeof t || "function" == typeof t)) { var n = t.then; if (t instanceof o) return e._state = 3, e._value = t, void l(e); if ("function" == typeof n) return void h((r = n, i = t, function() { r.apply(i, arguments) }), e) }
                e._state = 1, e._value = t, l(e)
            } catch (t) { s(e, t) }
            var r, i
        }

        function s(t, e) { t._state = 2, t._value = e, l(t) }

        function l(t) {
            2 === t._state && 0 === t._deferreds.length && o._immediateFn(function() { t._handled || o._unhandledRejectionFn(t._value) });
            for (var e = 0, n = t._deferreds.length; e < n; e++) i(t, t._deferreds[e]);
            t._deferreds = null
        }

        function u(t, e, n) { this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof e ? e : null, this.promise = n }

        function h(t, e) {
            var n = !1;
            try { t(function(t) { n || (n = !0, a(e, t)) }, function(t) { n || (n = !0, s(e, t)) }) } catch (t) {
                if (n) return;
                n = !0, s(e, t)
            }
        }
        o.prototype.catch = function(t) { return this.then(null, t) }, o.prototype.then = function(t, e) { var n = new this.constructor(r); return i(this, new u(t, e, n)), n }, o.prototype.finally = t, o.all = function(e) {
            return new o(function(i, o) {
                if (!c(e)) return o(new TypeError("Promise.all accepts an array"));
                var a = Array.prototype.slice.call(e);
                if (0 === a.length) return i([]);
                var s = a.length;
                for (var t = 0; t < a.length; t++) ! function e(n, t) {
                    try {
                        if (t && ("object" == typeof t || "function" == typeof t)) { var r = t.then; if ("function" == typeof r) return void r.call(t, function(t) { e(n, t) }, o) }
                        a[n] = t, 0 == --s && i(a)
                    } catch (t) { o(t) }
                }(t, a[t])
            })
        }, o.resolve = function(e) { return e && "object" == typeof e && e.constructor === o ? e : new o(function(t) { t(e) }) }, o.reject = function(n) { return new o(function(t, e) { e(n) }) }, o.race = function(i) { return new o(function(t, e) { if (!c(i)) return e(new TypeError("Promise.race accepts an array")); for (var n = 0, r = i.length; n < r; n++) o.resolve(i[n]).then(t, e) }) }, o._immediateFn = "function" == typeof setImmediate ? function(t) { setImmediate(t) } : function(t) { e(t, 0) }, o._unhandledRejectionFn = function(t) { "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t) };
        var n = function() { if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if ("undefined" != typeof global) return global; throw new Error("unable to locate global object") }();
        "Promise" in n ? n.Promise.prototype.finally || (n.Promise.prototype.finally = t) : n.Promise = o
    }, ("object" != typeof exports || "undefined" == typeof module) && "function" == typeof define && define.amd ? define(Ip) : Ip();
    var e, n, r = "URLSearchParams" in self,
        i = "Symbol" in self && "iterator" in Symbol,
        s = "FileReader" in self && "Blob" in self && function() { try { return new Blob, !0 } catch (t) { return !1 } }(),
        o = "FormData" in self,
        a = "ArrayBuffer" in self;

    function c(t) { if ("string" != typeof t && (t = String(t)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t) || "" === t) throw new TypeError("Invalid character in header field name"); return t.toLowerCase() }

    function l(t) { return "string" != typeof t && (t = String(t)), t }

    function t(e) { var t = { next: function() { var t = e.shift(); return { done: void 0 === t, value: t } } }; return i && (t[Symbol.iterator] = function() { return t }), t }

    function u(e) { this.map = {}, e instanceof u ? e.forEach(function(t, e) { this.append(e, t) }, this) : Array.isArray(e) ? e.forEach(function(t) { this.append(t[0], t[1]) }, this) : e && Object.getOwnPropertyNames(e).forEach(function(t) { this.append(t, e[t]) }, this) }

    function h(t) {
        if (t.bodyUsed) return Promise.reject(new TypeError("Already read"));
        t.bodyUsed = !0
    }

    function p(n) { return new Promise(function(t, e) { n.onload = function() { t(n.result) }, n.onerror = function() { e(n.error) } }) }

    function d(t) {
        var e = new FileReader,
            n = p(e);
        return e.readAsArrayBuffer(t), n
    }

    function f(t) { if (t.slice) return t.slice(0); var e = new Uint8Array(t.byteLength); return e.set(new Uint8Array(t)), e.buffer }

    function m() {
        return this.bodyUsed = !1, this._initBody = function(t) {
            var e;
            (this._bodyInit = t) ? "string" == typeof t ? this._bodyText = t : s && Blob.prototype.isPrototypeOf(t) ? this._bodyBlob = t : o && FormData.prototype.isPrototypeOf(t) ? this._bodyFormData = t : r && URLSearchParams.prototype.isPrototypeOf(t) ? this._bodyText = t.toString() : a && s && ((e = t) && DataView.prototype.isPrototypeOf(e)) ? (this._bodyArrayBuffer = f(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a && (ArrayBuffer.prototype.isPrototypeOf(t) || n(t)) ? this._bodyArrayBuffer = f(t) : this._bodyText = t = Object.prototype.toString.call(t): this._bodyText = "", this.headers.get("content-type") || ("string" == typeof t ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : r && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
        }, s && (this.blob = function() { var t = h(this); if (t) return t; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error("could not read FormData body as blob"); return Promise.resolve(new Blob([this._bodyText])) }, this.arrayBuffer = function() { return this._bodyArrayBuffer ? h(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(d) }), this.text = function() { var t, e, n = h(this); if (n) return n; if (this._bodyBlob) return t = this._bodyBlob, e = new FileReader, n = p(e), e.readAsText(t), n; if (this._bodyArrayBuffer) return Promise.resolve(function(t) { for (var e = new Uint8Array(t), n = new Array(e.length), r = 0; r < e.length; r++) n[r] = String.fromCharCode(e[r]); return n.join("") }(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error("could not read FormData body as text"); return Promise.resolve(this._bodyText) }, o && (this.formData = function() { return this.text().then(y) }), this.json = function() { return this.text().then(JSON.parse) }, this
    }
    a && (e = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], n = ArrayBuffer.isView || function(t) { return t && -1 < e.indexOf(Object.prototype.toString.call(t)) }), u.prototype.append = function(t, e) {
        t = c(t), e = l(e);
        var n = this.map[t];
        this.map[t] = n ? n + ", " + e : e
    }, u.prototype.delete = function(t) { delete this.map[c(t)] }, u.prototype.get = function(t) { return t = c(t), this.has(t) ? this.map[t] : null }, u.prototype.has = function(t) { return this.map.hasOwnProperty(c(t)) }, u.prototype.set = function(t, e) { this.map[c(t)] = l(e) }, u.prototype.forEach = function(t, e) { for (var n in this.map) this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this) }, u.prototype.keys = function() { var n = []; return this.forEach(function(t, e) { n.push(e) }), t(n) }, u.prototype.values = function() { var e = []; return this.forEach(function(t) { e.push(t) }), t(e) }, u.prototype.entries = function() { var n = []; return this.forEach(function(t, e) { n.push([e, t]) }), t(n) }, i && (u.prototype[Symbol.iterator] = u.prototype.entries);
    var g = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

    function v(t, e) {
        var n, r = (e = e || {}).body;
        if (t instanceof v) {
            if (t.bodyUsed) throw new TypeError("Already read");
            this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new u(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, r || null == t._bodyInit || (r = t._bodyInit, t.bodyUsed = !0)
        } else this.url = String(t);
        if (this.credentials = e.credentials || this.credentials || "same-origin", !e.headers && this.headers || (this.headers = new u(e.headers)), this.method = (n = e.method || this.method || "GET", t = n.toUpperCase(), -1 < g.indexOf(t) ? t : n), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && r) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(r)
    }

    function y(t) {
        var n = new FormData;
        return t.trim().split("&").forEach(function(t) {
            var e;
            t && (t = (e = t.split("=")).shift().replace(/\+/g, " "), e = e.join("=").replace(/\+/g, " "), n.append(decodeURIComponent(t), decodeURIComponent(e)))
        }), n
    }

    function _(t, e) { e = e || {}, this.type = "default", this.status = void 0 === e.status ? 200 : e.status, this.ok = 200 <= this.status && this.status < 300, this.statusText = "statusText" in e ? e.statusText : "OK", this.headers = new u(e.headers), this.url = e.url || "", this._initBody(t) }
    v.prototype.clone = function() { return new v(this, { body: this._bodyInit }) }, m.call(v.prototype), m.call(_.prototype), _.prototype.clone = function() { return new _(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new u(this.headers), url: this.url }) }, _.error = function() { var t = new _(null, { status: 0, statusText: "" }); return t.type = "error", t };
    var x = [301, 302, 303, 307, 308];
    _.redirect = function(t, e) { if (-1 === x.indexOf(e)) throw new RangeError("Invalid status code"); return new _(null, { status: e, headers: { location: t } }) };
    var b, w = self.DOMException;
    try { new w } catch (t) {
        (w = function(t, e) {
            this.message = t, this.name = e;
            t = Error(t);
            this.stack = t.stack
        }).prototype = Object.create(Error.prototype), w.prototype.constructor = w
    }

    function M(o, a) {
        return new Promise(function(r, t) {
            var e = new v(o, a);
            if (e.signal && e.signal.aborted) return t(new w("Aborted", "AbortError"));
            var i = new XMLHttpRequest;

            function n() { i.abort() }
            i.onload = function() {
                var n, t = {
                    status: i.status,
                    statusText: i.statusText,
                    headers: (e = i.getAllResponseHeaders() || "", n = new u, e.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(t) {
                        var e = t.split(":"),
                            t = e.shift().trim();
                        t && (e = e.join(":").trim(), n.append(t, e))
                    }), n)
                };
                t.url = "responseURL" in i ? i.responseURL : t.headers.get("X-Request-URL");
                var e = "response" in i ? i.response : i.responseText;
                r(new _(e, t))
            }, i.onerror = function() { t(new TypeError("Network request failed")) }, i.ontimeout = function() { t(new TypeError("Network request failed")) }, i.onabort = function() { t(new w("Aborted", "AbortError")) }, i.open(e.method, e.url, !0), "include" === e.credentials ? i.withCredentials = !0 : "omit" === e.credentials && (i.withCredentials = !1), "responseType" in i && s && (i.responseType = "blob"), e.headers.forEach(function(t, e) { i.setRequestHeader(e, t) }), e.signal && (e.signal.addEventListener("abort", n), i.onreadystatechange = function() { 4 === i.readyState && e.signal.removeEventListener("abort", n) }), i.send(void 0 === e._bodyInit ? null : e._bodyInit)
        })
    }

    function S(t) {
        this.time = t.time, this.target = t.target, this.rootBounds = t.rootBounds, this.boundingClientRect = t.boundingClientRect, this.intersectionRect = t.intersectionRect || R(), this.isIntersecting = !!t.intersectionRect;
        var e = this.boundingClientRect,
            t = e.width * e.height,
            e = this.intersectionRect,
            e = e.width * e.height;
        this.intersectionRatio = t ? Number((e / t).toFixed(4)) : this.isIntersecting ? 1 : 0
    }

    function E(t, e) {
        var n, r, i, e = e || {};
        if ("function" != typeof t) throw new Error("callback must be a function");
        if (e.root && 1 != e.root.nodeType) throw new Error("root must be an Element");
        this._checkForIntersections = (n = this._checkForIntersections.bind(this), r = this.THROTTLE_TIMEOUT, i = null, function() { i = i || setTimeout(function() { n(), i = null }, r) }), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(e.rootMargin), this.thresholds = this._initThresholds(e.threshold), this.root = e.root || null, this.rootMargin = this._rootMarginValues.map(function(t) { return t.value + t.unit }).join(" ")
    }

    function T(t, e, n, r) { "function" == typeof t.addEventListener ? t.addEventListener(e, n, r || !1) : "function" == typeof t.attachEvent && t.attachEvent("on" + e, n) }

    function A(t, e, n, r) { "function" == typeof t.removeEventListener ? t.removeEventListener(e, n, r || !1) : "function" == typeof t.detatchEvent && t.detatchEvent("on" + e, n) }

    function L(t) { var e; try { e = t.getBoundingClientRect() } catch (t) {} return e ? (e.width && e.height || (e = { top: e.top, right: e.right, bottom: e.bottom, left: e.left, width: e.right - e.left, height: e.bottom - e.top }), e) : R() }

    function R() { return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 } }

    function C(t, e) {
        for (var n = e; n;) {
            if (n == t) return !0;
            n = P(n)
        }
        return !1
    }

    function P(t) { t = t.parentNode; return t && 11 == t.nodeType && t.host ? t.host : t && t.assignedSlot ? t.assignedSlot.parentNode : t }
    M.polyfill = !0, self.fetch || (self.fetch = M, self.Headers = u, self.Request = v, self.Response = _), "object" == typeof window && ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype ? "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", { get: function() { return 0 < this.intersectionRatio } }) : (b = window.document, E.prototype.THROTTLE_TIMEOUT = 100, E.prototype.POLL_INTERVAL = null, E.prototype.USE_MUTATION_OBSERVER = !0, E.prototype.observe = function(e) {
        if (!this._observationTargets.some(function(t) { return t.element == e })) {
            if (!e || 1 != e.nodeType) throw new Error("target must be an Element");
            this._registerInstance(), this._observationTargets.push({ element: e, entry: null }), this._monitorIntersections(), this._checkForIntersections()
        }
    }, E.prototype.unobserve = function(e) { this._observationTargets = this._observationTargets.filter(function(t) { return t.element != e }), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance()) }, E.prototype.disconnect = function() { this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance() }, E.prototype.takeRecords = function() { var t = this._queuedEntries.slice(); return this._queuedEntries = [], t }, E.prototype._initThresholds = function(t) { t = t || [0]; return Array.isArray(t) || (t = [t]), t.sort().filter(function(t, e, n) { if ("number" != typeof t || isNaN(t) || t < 0 || 1 < t) throw new Error("threshold must be a number between 0 and 1 inclusively"); return t !== n[e - 1] }) }, E.prototype._parseRootMargin = function(t) { t = (t || "0px").split(/\s+/).map(function(t) { t = /^(-?\d*\.?\d+)(px|%)$/.exec(t); if (!t) throw new Error("rootMargin must be specified in pixels or percent"); return { value: parseFloat(t[1]), unit: t[2] } }); return t[1] = t[1] || t[0], t[2] = t[2] || t[0], t[3] = t[3] || t[1], t }, E.prototype._monitorIntersections = function() { this._monitoringIntersections || (this._monitoringIntersections = !0, this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (T(window, "resize", this._checkForIntersections, !0), T(b, "scroll", this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in window && (this._domObserver = new MutationObserver(this._checkForIntersections), this._domObserver.observe(b, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })))) }, E.prototype._unmonitorIntersections = function() { this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), this._monitoringInterval = null, A(window, "resize", this._checkForIntersections, !0), A(b, "scroll", this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), this._domObserver = null)) }, E.prototype._checkForIntersections = function() {
        var a = this._rootIsInDom(),
            s = a ? this._getRootRect() : R();
        this._observationTargets.forEach(function(t) {
            var e = t.element,
                n = L(e),
                r = this._rootContainsTarget(e),
                i = t.entry,
                o = a && r && this._computeTargetAndRootIntersection(e, s),
                o = t.entry = new S({ time: window.performance && performance.now && performance.now(), target: e, boundingClientRect: n, rootBounds: s, intersectionRect: o });
            i ? a && r ? this._hasCrossedThreshold(i, o) && this._queuedEntries.push(o) : i && i.isIntersecting && this._queuedEntries.push(o) : this._queuedEntries.push(o)
        }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
    }, E.prototype._computeTargetAndRootIntersection = function(t, e) {
        if ("none" != window.getComputedStyle(t).display) {
            for (var n, r, i, o, a = L(t), s = P(t), c = !1; !c;) {
                var l = null,
                    u = 1 == s.nodeType ? window.getComputedStyle(s) : {};
                if ("none" == u.display) return;
                if (s == this.root || s == b ? (c = !0, l = e) : s != b.body && s != b.documentElement && "visible" != u.overflow && (l = L(s)), l && (n = l, r = a, l = u = o = i = void 0, i = Math.max(n.top, r.top), o = Math.min(n.bottom, r.bottom), u = Math.max(n.left, r.left), l = Math.min(n.right, r.right), r = o - i, !(a = 0 <= (n = l - u) && 0 <= r && { top: i, bottom: o, left: u, right: l, width: n, height: r }))) break;
                s = P(s)
            }
            return a
        }
    }, E.prototype._getRootRect = function() { var t, e; return e = this.root ? L(this.root) : (t = b.documentElement, e = b.body, { top: 0, left: 0, right: t.clientWidth || e.clientWidth, width: t.clientWidth || e.clientWidth, bottom: t.clientHeight || e.clientHeight, height: t.clientHeight || e.clientHeight }), this._expandRectByRootMargin(e) }, E.prototype._expandRectByRootMargin = function(n) {
        var t = this._rootMarginValues.map(function(t, e) { return "px" == t.unit ? t.value : t.value * (e % 2 ? n.width : n.height) / 100 }),
            t = { top: n.top - t[0], right: n.right + t[1], bottom: n.bottom + t[2], left: n.left - t[3] };
        return t.width = t.right - t.left, t.height = t.bottom - t.top, t
    }, E.prototype._hasCrossedThreshold = function(t, e) {
        var n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1,
            r = e.isIntersecting ? e.intersectionRatio || 0 : -1;
        if (n !== r)
            for (var i = 0; i < this.thresholds.length; i++) { var o = this.thresholds[i]; if (o == n || o == r || o < n != o < r) return !0 }
    }, E.prototype._rootIsInDom = function() { return !this.root || C(b, this.root) }, E.prototype._rootContainsTarget = function(t) { return C(this.root || b, t) }, E.prototype._registerInstance = function() {}, E.prototype._unregisterInstance = function() {}, window.IntersectionObserver = E, window.IntersectionObserverEntry = S)), Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(t) { for (var e = (this.document || this.ownerDocument).querySelectorAll(t), n = e.length; 0 <= --n && e.item(n) !== this;); return -1 < n }), Element.prototype.closest || (Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest = function(t) {
        var e = this;
        if (!document.documentElement.contains(this)) return null;
        do { if (e.matches(t)) return e } while (null !== (e = e.parentElement));
        return null
    }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }), void 0 === Math.sign && (Math.sign = function(t) { return t < 0 ? -1 : 0 < t ? 1 : +t }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function() { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function(t) {
        var e = arguments;
        if (null == t) throw new TypeError("Cannot convert undefined or null to object");
        for (var n = Object(t), r = 1; r < arguments.length; r++) {
            var i = e[r];
            if (null != i)
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
        }
        return n
    });
    var k = 0,
        G = 1,
        V = 2,
        O = 1,
        I = 2,
        D = 3,
        X = 0,
        j = 1,
        Y = 2,
        W = 0,
        q = 1,
        Z = 2,
        J = 3,
        K = 4,
        Q = 5,
        $ = 100,
        tt = 101,
        et = 102,
        nt = 103,
        rt = 104,
        it = 200,
        ot = 201,
        at = 202,
        st = 203,
        ct = 204,
        lt = 205,
        ut = 206,
        ht = 207,
        pt = 208,
        dt = 209,
        ft = 210,
        mt = 0,
        gt = 1,
        vt = 2,
        yt = 3,
        _t = 4,
        xt = 5,
        bt = 6,
        wt = 7,
        N = 0,
        B = 1,
        F = 2,
        Et = 0,
        U = 1,
        z = 2,
        H = 3,
        Mt = 4,
        St = 5,
        Tt = 301,
        At = 302,
        Lt = 303,
        Rt = 304,
        Ct = 306,
        Pt = 307,
        Ot = 1e3,
        It = 1001,
        Dt = 1002,
        Nt = 1003,
        Bt = 1004,
        Ft = 1005,
        Ut = 1006,
        zt = 1007,
        Ht = 1008,
        kt = 1009,
        Gt = 1010,
        Vt = 1011,
        jt = 1012,
        Wt = 1013,
        qt = 1014,
        Xt = 1015,
        Yt = 1016,
        Zt = 1017,
        Jt = 1018,
        Kt = 1019,
        Qt = 1020,
        $t = 1021,
        te = 1022,
        ee = 1023,
        ne = 1024,
        re = 1025,
        ie = ee,
        oe = 1026,
        ae = 1027,
        se = 1028,
        ce = 1029,
        le = 1030,
        ue = 1031,
        he = 1032,
        pe = 1033,
        de = 33776,
        fe = 33777,
        me = 33778,
        ge = 33779,
        ve = 35840,
        ye = 35841,
        _e = 35842,
        xe = 35843,
        be = 36196,
        we = 37492,
        Me = 37496,
        Se = 37808,
        Ee = 37809,
        Te = 37810,
        Ae = 37811,
        Le = 37812,
        Re = 37813,
        Ce = 37814,
        Pe = 37815,
        Oe = 37816,
        Ie = 37817,
        De = 37818,
        Ne = 37819,
        Be = 37820,
        Fe = 37821,
        Ue = 36492,
        ze = 37840,
        He = 37841,
        ke = 37842,
        Ge = 37843,
        Ve = 37844,
        je = 37845,
        We = 37846,
        qe = 37847,
        Xe = 37848,
        Ye = 37849,
        Ze = 37850,
        Je = 37851,
        Ke = 37852,
        Qe = 37853,
        $e = 2300,
        tn = 2301,
        en = 2400,
        nn = 2401,
        rn = 2402,
        on = 2,
        an = 3e3,
        sn = 3001,
        cn = 3007,
        ln = 3002,
        un = 3003,
        hn = 3004,
        pn = 3005,
        dn = 3006,
        fn = 3200,
        mn = 3201,
        gn = 0,
        vn = 1,
        yn = 7680,
        _n = 519,
        xn = 35044,
        bn = 35048,
        wn = "300 es";

    function Mn() {}
    Object.assign(Mn.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) { if (void 0 === this._listeners) return !1; var n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) },
        removeEventListener: function(t, e) { void 0 !== this._listeners && (void 0 === (t = this._listeners[t]) || -1 !== (e = t.indexOf(e)) && t.splice(e, 1)) },
        dispatchEvent: function(t) { if (void 0 !== this._listeners) { var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; for (var n = e.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, t) } } }
    });
    for (var Sn = [], En = 0; En < 256; En++) Sn[En] = (En < 16 ? "0" : "") + En.toString(16);
    var Tn = 1234567,
        An = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (Sn[255 & t] + Sn[t >> 8 & 255] + Sn[t >> 16 & 255] + Sn[t >> 24 & 255] + "-" + Sn[255 & e] + Sn[e >> 8 & 255] + "-" + Sn[e >> 16 & 15 | 64] + Sn[e >> 24 & 255] + "-" + Sn[63 & n | 128] + Sn[n >> 8 & 255] + "-" + Sn[n >> 16 & 255] + Sn[n >> 24 & 255] + Sn[255 & r] + Sn[r >> 8 & 255] + Sn[r >> 16 & 255] + Sn[r >> 24 & 255]).toUpperCase()
            },
            clamp: function(t, e, n) { return Math.max(e, Math.min(n, t)) },
            euclideanModulo: function(t, e) { return (t % e + e) % e },
            mapLinear: function(t, e, n, r, i) { return r + (t - e) * (i - r) / (n - e) },
            lerp: function(t, e, n) { return (1 - n) * t + n * e },
            smoothstep: function(t, e, n) { return t <= e ? 0 : n <= t ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) },
            smootherstep: function(t, e, n) { return t <= e ? 0 : n <= t ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) },
            randInt: function(t, e) { return t + Math.floor(Math.random() * (e - t + 1)) },
            randFloat: function(t, e) { return t + Math.random() * (e - t) },
            randFloatSpread: function(t) { return t * (.5 - Math.random()) },
            seededRandom: function(t) { return void 0 !== t && (Tn = t % 2147483647), ((Tn = 16807 * Tn % 2147483647) - 1) / 2147483646 },
            degToRad: function(t) { return t * An.DEG2RAD },
            radToDeg: function(t) { return t * An.RAD2DEG },
            isPowerOfTwo: function(t) { return 0 == (t & t - 1) && 0 !== t },
            ceilPowerOfTwo: function(t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) },
            floorPowerOfTwo: function(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) },
            setQuaternionFromProperEuler: function(t, e, n, r, i) {
                var o = Math.cos,
                    a = Math.sin,
                    s = o(n / 2),
                    c = a(n / 2),
                    l = o((e + r) / 2),
                    u = a((e + r) / 2),
                    h = o((e - r) / 2),
                    p = a((e - r) / 2),
                    d = o((r - e) / 2),
                    f = a((r - e) / 2);
                switch (i) {
                    case "XYX":
                        t.set(s * u, c * h, c * p, s * l);
                        break;
                    case "YZY":
                        t.set(c * p, s * u, c * h, s * l);
                        break;
                    case "ZXZ":
                        t.set(c * h, c * p, s * u, s * l);
                        break;
                    case "XZX":
                        t.set(s * u, c * f, c * d, s * l);
                        break;
                    case "YXY":
                        t.set(c * d, s * u, c * f, s * l);
                        break;
                    case "ZYZ":
                        t.set(c * f, c * d, s * u, s * l);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                }
            }
        },
        Ln = function(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), Object.defineProperty(this, "isVector2", { value: !0 }), this.x = t, this.y = e },
        Rn = { width: { configurable: !0 }, height: { configurable: !0 } };
    Rn.width.get = function() { return this.x }, Rn.width.set = function(t) { this.x = t }, Rn.height.get = function() { return this.y }, Rn.height.set = function(t) { this.y = t }, Ln.prototype.set = function(t, e) { return this.x = t, this.y = e, this }, Ln.prototype.setScalar = function(t) { return this.x = t, this.y = t, this }, Ln.prototype.setX = function(t) { return this.x = t, this }, Ln.prototype.setY = function(t) { return this.y = t, this }, Ln.prototype.setComponent = function(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }, Ln.prototype.getComponent = function(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
        }
    }, Ln.prototype.clone = function() { return new this.constructor(this.x, this.y) }, Ln.prototype.copy = function(t) { return this.x = t.x, this.y = t.y, this }, Ln.prototype.add = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, Ln.prototype.addScalar = function(t) { return this.x += t, this.y += t, this }, Ln.prototype.addVectors = function(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, Ln.prototype.addScaledVector = function(t, e) { return this.x += t.x * e, this.y += t.y * e, this }, Ln.prototype.sub = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, Ln.prototype.subScalar = function(t) { return this.x -= t, this.y -= t, this }, Ln.prototype.subVectors = function(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, Ln.prototype.multiply = function(t) { return this.x *= t.x, this.y *= t.y, this }, Ln.prototype.multiplyScalar = function(t) { return this.x *= t, this.y *= t, this }, Ln.prototype.divide = function(t) { return this.x /= t.x, this.y /= t.y, this }, Ln.prototype.divideScalar = function(t) { return this.multiplyScalar(1 / t) }, Ln.prototype.applyMatrix3 = function(t) {
        var e = this.x,
            n = this.y,
            t = t.elements;
        return this.x = t[0] * e + t[3] * n + t[6], this.y = t[1] * e + t[4] * n + t[7], this
    }, Ln.prototype.min = function(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, Ln.prototype.max = function(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, Ln.prototype.clamp = function(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, Ln.prototype.clampScalar = function(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }, Ln.prototype.clampLength = function(t, e) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, Ln.prototype.floor = function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, Ln.prototype.ceil = function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, Ln.prototype.round = function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, Ln.prototype.roundToZero = function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, Ln.prototype.negate = function() { return this.x = -this.x, this.y = -this.y, this }, Ln.prototype.dot = function(t) { return this.x * t.x + this.y * t.y }, Ln.prototype.cross = function(t) { return this.x * t.y - this.y * t.x }, Ln.prototype.lengthSq = function() { return this.x * this.x + this.y * this.y }, Ln.prototype.length = function() { return Math.sqrt(this.x * this.x + this.y * this.y) }, Ln.prototype.manhattanLength = function() { return Math.abs(this.x) + Math.abs(this.y) }, Ln.prototype.normalize = function() { return this.divideScalar(this.length() || 1) }, Ln.prototype.angle = function() { var t = Math.atan2(-this.y, -this.x) + Math.PI; return t }, Ln.prototype.distanceTo = function(t) { return Math.sqrt(this.distanceToSquared(t)) }, Ln.prototype.distanceToSquared = function(t) {
        var e = this.x - t.x,
            t = this.y - t.y;
        return e * e + t * t
    }, Ln.prototype.manhattanDistanceTo = function(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, Ln.prototype.setLength = function(t) { return this.normalize().multiplyScalar(t) }, Ln.prototype.lerp = function(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, Ln.prototype.lerpVectors = function(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this }, Ln.prototype.equals = function(t) { return t.x === this.x && t.y === this.y }, Ln.prototype.fromArray = function(t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, Ln.prototype.toArray = function(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, Ln.prototype.fromBufferAttribute = function(t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }, Ln.prototype.rotateAround = function(t, e) {
        var n = Math.cos(e),
            r = Math.sin(e),
            i = this.x - t.x,
            e = this.y - t.y;
        return this.x = i * n - e * r + t.x, this.y = i * r + e * n + t.y, this
    }, Ln.prototype.random = function() { return this.x = Math.random(), this.y = Math.random(), this }, Object.defineProperties(Ln.prototype, Rn);
    var Cn, Pn = function() { Object.defineProperty(this, "isMatrix3", { value: !0 }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") };
    Pn.prototype.set = function(t, e, n, r, i, o, a, s, c) { var l = this.elements; return l[0] = t, l[1] = r, l[2] = a, l[3] = e, l[4] = i, l[5] = s, l[6] = n, l[7] = o, l[8] = c, this }, Pn.prototype.identity = function() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, Pn.prototype.clone = function() { return (new this.constructor).fromArray(this.elements) }, Pn.prototype.copy = function(t) {
        var e = this.elements,
            t = t.elements;
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this
    }, Pn.prototype.extractBasis = function(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this }, Pn.prototype.setFromMatrix4 = function(t) { t = t.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this }, Pn.prototype.multiply = function(t) { return this.multiplyMatrices(this, t) }, Pn.prototype.premultiply = function(t) { return this.multiplyMatrices(t, this) }, Pn.prototype.multiplyMatrices = function(t, e) {
        var n = t.elements,
            r = e.elements,
            i = this.elements,
            o = n[0],
            a = n[3],
            s = n[6],
            c = n[1],
            l = n[4],
            u = n[7],
            h = n[2],
            p = n[5],
            d = n[8],
            f = r[0],
            m = r[3],
            g = r[6],
            v = r[1],
            y = r[4],
            t = r[7],
            e = r[2],
            n = r[5],
            r = r[8];
        return i[0] = o * f + a * v + s * e, i[3] = o * m + a * y + s * n, i[6] = o * g + a * t + s * r, i[1] = c * f + l * v + u * e, i[4] = c * m + l * y + u * n, i[7] = c * g + l * t + u * r, i[2] = h * f + p * v + d * e, i[5] = h * m + p * y + d * n, i[8] = h * g + p * t + d * r, this
    }, Pn.prototype.multiplyScalar = function(t) { var e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, Pn.prototype.determinant = function() {
        var t = this.elements,
            e = t[0],
            n = t[1],
            r = t[2],
            i = t[3],
            o = t[4],
            a = t[5],
            s = t[6],
            c = t[7],
            t = t[8];
        return e * o * t - e * a * c - n * i * t + n * a * s + r * i * c - r * o * s
    }, Pn.prototype.getInverse = function(t, e) {
        void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
        var n = t.elements,
            r = this.elements,
            i = n[0],
            o = n[1],
            a = n[2],
            s = n[3],
            c = n[4],
            l = n[5],
            u = n[6],
            h = n[7],
            p = n[8],
            d = p * c - l * h,
            e = l * u - p * s,
            t = h * s - c * u,
            n = i * d + o * e + a * t;
        if (0 == n) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        n = 1 / n;
        return r[0] = d * n, r[1] = (a * h - p * o) * n, r[2] = (l * o - a * c) * n, r[3] = e * n, r[4] = (p * i - a * u) * n, r[5] = (a * s - l * i) * n, r[6] = t * n, r[7] = (o * u - h * i) * n, r[8] = (c * i - o * s) * n, this
    }, Pn.prototype.transpose = function() {
        var t = this.elements,
            e = t[1];
        return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
    }, Pn.prototype.getNormalMatrix = function(t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, Pn.prototype.transposeIntoArray = function(t) { var e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, Pn.prototype.setUvTransform = function(t, e, n, r, i, o, a) {
        var s = Math.cos(i),
            i = Math.sin(i);
        this.set(n * s, n * i, -n * (s * o + i * a) + o + t, -r * i, r * s, -r * (-i * o + s * a) + a + e, 0, 0, 1)
    }, Pn.prototype.scale = function(t, e) { var n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this }, Pn.prototype.rotate = function(t) {
        var e = Math.cos(t),
            n = Math.sin(t),
            r = this.elements,
            i = r[0],
            o = r[3],
            a = r[6],
            s = r[1],
            c = r[4],
            t = r[7];
        return r[0] = e * i + n * s, r[3] = e * o + n * c, r[6] = e * a + n * t, r[1] = -n * i + e * s, r[4] = -n * o + e * c, r[7] = -n * a + e * t, this
    }, Pn.prototype.translate = function(t, e) { var n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this }, Pn.prototype.equals = function(t) {
        for (var e = this.elements, n = t.elements, r = 0; r < 9; r++)
            if (e[r] !== n[r]) return !1;
        return !0
    }, Pn.prototype.fromArray = function(t, e) { void 0 === e && (e = 0); for (var n = 0; n < 9; n++) this.elements[n] = t[n + e]; return this }, Pn.prototype.toArray = function(t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t };
    var On = { getDataURL: function(t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; var e, t = t instanceof HTMLCanvasElement ? t : (void 0 === Cn && (Cn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Cn.width = t.width, Cn.height = t.height, e = Cn.getContext("2d"), t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), Cn); return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png") } },
        In = 0;

    function Dn(t, e, n, r, i, o, a, s, c, l) { Object.defineProperty(this, "id", { value: In++ }), this.uuid = An.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Dn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Dn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : It, this.wrapT = void 0 !== r ? r : It, this.magFilter = void 0 !== i ? i : Ut, this.minFilter = void 0 !== o ? o : Ht, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : ee, this.internalFormat = null, this.type = void 0 !== s ? s : kt, this.offset = new Ln(0, 0), this.repeat = new Ln(1, 1), this.center = new Ln(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Pn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : an, this.version = 0, this.onUpdate = null }
    Dn.DEFAULT_IMAGE = void 0, Dn.DEFAULT_MAPPING = 300, Dn.prototype = Object.assign(Object.create(Mn.prototype), {
        constructor: Dn,
        isTexture: !0,
        updateMatrix: function() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) },
        clone: function() { return (new this.constructor).copy(this) },
        copy: function(t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
            if (void 0 !== this.image) {
                var r, i = this.image;
                if (void 0 === i.uuid && (i.uuid = An.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                    if (Array.isArray(i)) { r = []; for (var o = 0, a = i.length; o < a; o++) r.push(On.getDataURL(i[o])) } else r = On.getDataURL(i);
                    t.images[i.uuid] = { uuid: i.uuid, url: r }
                }
                n.image = i.uuid
            }
            return e || (t.textures[this.uuid] = n), n
        },
        dispose: function() { this.dispatchEvent({ type: "dispose" }) },
        transformUv: function(t) {
            if (300 !== this.mapping) return t;
            if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) {
                case Ot:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case It:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case Dt:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
            }
            if (t.y < 0 || 1 < t.y) switch (this.wrapT) {
                case Ot:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case It:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case Dt:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
            }
            return this.flipY && (t.y = 1 - t.y), t
        }
    }), Object.defineProperty(Dn.prototype, "needsUpdate", { set: function(t) {!0 === t && this.version++ } });
    var Nn = function(t, e, n, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), Object.defineProperty(this, "isVector4", { value: !0 }), this.x = t, this.y = e, this.z = n, this.w = r },
        Bn = { width: { configurable: !0 }, height: { configurable: !0 } };

    function Fn(t, e, n) { this.width = t, this.height = e, this.scissor = new Nn(0, 0, t, e), this.scissorTest = !1, this.viewport = new Nn(0, 0, t, e), n = n || {}, this.texture = new Dn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Ut, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null }

    function Un(t, e, n) { Fn.call(this, t, e, n), this.samples = 4 }
    Bn.width.get = function() { return this.z }, Bn.width.set = function(t) { this.z = t }, Bn.height.get = function() { return this.w }, Bn.height.set = function(t) { this.w = t }, Nn.prototype.set = function(t, e, n, r) { return this.x = t, this.y = e, this.z = n, this.w = r, this }, Nn.prototype.setScalar = function(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }, Nn.prototype.setX = function(t) { return this.x = t, this }, Nn.prototype.setY = function(t) { return this.y = t, this }, Nn.prototype.setZ = function(t) { return this.z = t, this }, Nn.prototype.setW = function(t) { return this.w = t, this }, Nn.prototype.setComponent = function(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }, Nn.prototype.getComponent = function(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
        }
    }, Nn.prototype.clone = function() { return new this.constructor(this.x, this.y, this.z, this.w) }, Nn.prototype.copy = function(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, Nn.prototype.add = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, Nn.prototype.addScalar = function(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, Nn.prototype.addVectors = function(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, Nn.prototype.addScaledVector = function(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, Nn.prototype.sub = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, Nn.prototype.subScalar = function(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, Nn.prototype.subVectors = function(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, Nn.prototype.multiplyScalar = function(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, Nn.prototype.applyMatrix4 = function(t) {
        var e = this.x,
            n = this.y,
            r = this.z,
            i = this.w,
            t = t.elements;
        return this.x = t[0] * e + t[4] * n + t[8] * r + t[12] * i, this.y = t[1] * e + t[5] * n + t[9] * r + t[13] * i, this.z = t[2] * e + t[6] * n + t[10] * r + t[14] * i, this.w = t[3] * e + t[7] * n + t[11] * r + t[15] * i, this
    }, Nn.prototype.divideScalar = function(t) { return this.multiplyScalar(1 / t) }, Nn.prototype.setAxisAngleFromQuaternion = function(t) { this.w = 2 * Math.acos(t.w); var e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, Nn.prototype.setAxisAngleFromRotationMatrix = function(t) {
        var e, n, r, i = t.elements,
            o = i[0],
            a = i[4],
            s = i[8],
            c = i[1],
            l = i[5],
            u = i[9],
            h = i[2],
            p = i[6],
            d = i[10];
        if (Math.abs(a - c) < .01 && Math.abs(s - h) < .01 && Math.abs(u - p) < .01) {
            if (Math.abs(a + c) < .1 && Math.abs(s + h) < .1 && Math.abs(u + p) < .1 && Math.abs(o + l + d - 3) < .1) return this.set(1, 0, 0, 0), this;
            y = Math.PI;
            var f = (o + 1) / 2,
                m = (l + 1) / 2,
                g = (d + 1) / 2,
                v = (a + c) / 4,
                t = (s + h) / 4,
                i = (u + p) / 4;
            return m < f && g < f ? r = f < .01 ? (e = 0, n = .707106781) : (n = v / (e = Math.sqrt(f)), t / e) : g < m ? r = m < .01 ? (n = 0, e = .707106781) : (e = v / (n = Math.sqrt(m)), i / n) : g < .01 ? (n = e = .707106781, r = 0) : (e = t / (r = Math.sqrt(g)), n = i / r), this.set(e, n, r, y), this
        }
        var y = Math.sqrt((p - u) * (p - u) + (s - h) * (s - h) + (c - a) * (c - a));
        return Math.abs(y) < .001 && (y = 1), this.x = (p - u) / y, this.y = (s - h) / y, this.z = (c - a) / y, this.w = Math.acos((o + l + d - 1) / 2), this
    }, Nn.prototype.min = function(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, Nn.prototype.max = function(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, Nn.prototype.clamp = function(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, Nn.prototype.clampScalar = function(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this }, Nn.prototype.clampLength = function(t, e) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, Nn.prototype.floor = function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, Nn.prototype.ceil = function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, Nn.prototype.round = function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, Nn.prototype.roundToZero = function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, Nn.prototype.negate = function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, Nn.prototype.dot = function(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, Nn.prototype.lengthSq = function() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, Nn.prototype.length = function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, Nn.prototype.manhattanLength = function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, Nn.prototype.normalize = function() { return this.divideScalar(this.length() || 1) }, Nn.prototype.setLength = function(t) { return this.normalize().multiplyScalar(t) }, Nn.prototype.lerp = function(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, Nn.prototype.lerpVectors = function(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this }, Nn.prototype.equals = function(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, Nn.prototype.fromArray = function(t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, Nn.prototype.toArray = function(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, Nn.prototype.fromBufferAttribute = function(t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this }, Nn.prototype.random = function() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this }, Object.defineProperties(Nn.prototype, Bn), Fn.prototype = Object.assign(Object.create(Mn.prototype), { constructor: Fn, isWebGLRenderTarget: !0, setSize: function(t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), Un.prototype = Object.assign(Object.create(Fn.prototype), { constructor: Un, isWebGLMultisampleRenderTarget: !0, copy: function(t) { return Fn.prototype.copy.call(this, t), this.samples = t.samples, this } });
    var zn = function(t, e, n, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), Object.defineProperty(this, "isQuaternion", { value: !0 }), this._x = t, this._y = e, this._z = n, this._w = r },
        Hn = { x: { configurable: !0 }, y: { configurable: !0 }, z: { configurable: !0 }, w: { configurable: !0 } };
    zn.slerp = function(t, e, n, r) { return n.copy(t).slerp(e, r) }, zn.slerpFlat = function(t, e, n, r, i, o, a) {
        var s = n[r + 0],
            c = n[r + 1],
            l = n[r + 2],
            u = n[r + 3],
            h = i[o + 0],
            p = i[o + 1],
            d = i[o + 2],
            f = i[o + 3];
        u === f && s === h && c === p && l === d || (n = 1 - a, i = 0 <= (r = s * h + c * p + l * d + u * f) ? 1 : -1, (o = 1 - r * r) > Number.EPSILON && (o = Math.sqrt(o), r = Math.atan2(o, r * i), n = Math.sin(n * r) / o, a = Math.sin(a * r) / o), s = s * n + h * (i = a * i), c = c * n + p * i, l = l * n + d * i, u = u * n + f * i, n === 1 - a && (s *= a = 1 / Math.sqrt(s * s + c * c + l * l + u * u), c *= a, l *= a, u *= a)), t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u
    }, zn.multiplyQuaternionsFlat = function(t, e, n, r, i, o) {
        var a = n[r],
            s = n[r + 1],
            c = n[r + 2],
            l = n[r + 3],
            u = i[o],
            n = i[o + 1],
            r = i[o + 2],
            o = i[o + 3];
        return t[e] = a * o + l * u + s * r - c * n, t[e + 1] = s * o + l * n + c * u - a * r, t[e + 2] = c * o + l * r + a * n - s * u, t[e + 3] = l * o - a * u - s * n - c * r, t
    }, Hn.x.get = function() { return this._x }, Hn.x.set = function(t) { this._x = t, this._onChangeCallback() }, Hn.y.get = function() { return this._y }, Hn.y.set = function(t) { this._y = t, this._onChangeCallback() }, Hn.z.get = function() { return this._z }, Hn.z.set = function(t) { this._z = t, this._onChangeCallback() }, Hn.w.get = function() { return this._w }, Hn.w.set = function(t) { this._w = t, this._onChangeCallback() }, zn.prototype.set = function(t, e, n, r) { return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this }, zn.prototype.clone = function() { return new this.constructor(this._x, this._y, this._z, this._w) }, zn.prototype.copy = function(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this }, zn.prototype.setFromEuler = function(t, e) {
        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        var n = t._x,
            r = t._y,
            i = t._z,
            o = t._order,
            a = Math.cos,
            t = Math.sin,
            s = a(n / 2),
            c = a(r / 2),
            l = a(i / 2),
            u = t(n / 2),
            h = t(r / 2),
            p = t(i / 2);
        switch (o) {
            case "XYZ":
                this._x = u * c * l + s * h * p, this._y = s * h * l - u * c * p, this._z = s * c * p + u * h * l, this._w = s * c * l - u * h * p;
                break;
            case "YXZ":
                this._x = u * c * l + s * h * p, this._y = s * h * l - u * c * p, this._z = s * c * p - u * h * l, this._w = s * c * l + u * h * p;
                break;
            case "ZXY":
                this._x = u * c * l - s * h * p, this._y = s * h * l + u * c * p, this._z = s * c * p + u * h * l, this._w = s * c * l - u * h * p;
                break;
            case "ZYX":
                this._x = u * c * l - s * h * p, this._y = s * h * l + u * c * p, this._z = s * c * p - u * h * l, this._w = s * c * l + u * h * p;
                break;
            case "YZX":
                this._x = u * c * l + s * h * p, this._y = s * h * l + u * c * p, this._z = s * c * p - u * h * l, this._w = s * c * l - u * h * p;
                break;
            case "XZY":
                this._x = u * c * l - s * h * p, this._y = s * h * l - u * c * p, this._z = s * c * p + u * h * l, this._w = s * c * l + u * h * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return !1 !== e && this._onChangeCallback(), this
    }, zn.prototype.setFromAxisAngle = function(t, e) {
        var n = e / 2,
            e = Math.sin(n);
        return this._x = t.x * e, this._y = t.y * e, this._z = t.z * e, this._w = Math.cos(n), this._onChangeCallback(), this
    }, zn.prototype.setFromRotationMatrix = function(t) {
        var e, n = t.elements,
            r = n[0],
            i = n[4],
            o = n[8],
            a = n[1],
            s = n[5],
            c = n[9],
            l = n[2],
            u = n[6],
            t = n[10],
            n = r + s + t;
        return 0 < n ? (n = .5 / Math.sqrt(n + 1), this._w = .25 / n, this._x = (u - c) * n, this._y = (o - l) * n, this._z = (a - i) * n) : s < r && t < r ? (e = 2 * Math.sqrt(1 + r - s - t), this._w = (u - c) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (o + l) / e) : t < s ? (e = 2 * Math.sqrt(1 + s - r - t), this._w = (o - l) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (c + u) / e) : (s = 2 * Math.sqrt(1 + t - r - s), this._w = (a - i) / s, this._x = (o + l) / s, this._y = (c + u) / s, this._z = .25 * s), this._onChangeCallback(), this
    }, zn.prototype.setFromUnitVectors = function(t, e) { var n = t.dot(e) + 1; return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0) : (this._x = 0, this._y = -t.z, this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x), this._w = n, this.normalize() }, zn.prototype.angleTo = function(t) { return 2 * Math.acos(Math.abs(An.clamp(this.dot(t), -1, 1))) }, zn.prototype.rotateTowards = function(t, e) {
        var n = this.angleTo(t);
        if (0 === n) return this;
        n = Math.min(1, e / n);
        return this.slerp(t, n), this
    }, zn.prototype.identity = function() { return this.set(0, 0, 0, 1) }, zn.prototype.inverse = function() { return this.conjugate() }, zn.prototype.conjugate = function() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }, zn.prototype.dot = function(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, zn.prototype.lengthSq = function() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, zn.prototype.length = function() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, zn.prototype.normalize = function() { var t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this }, zn.prototype.multiply = function(t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, zn.prototype.premultiply = function(t) { return this.multiplyQuaternions(t, this) }, zn.prototype.multiplyQuaternions = function(t, e) {
        var n = t._x,
            r = t._y,
            i = t._z,
            o = t._w,
            a = e._x,
            s = e._y,
            t = e._z,
            e = e._w;
        return this._x = n * e + o * a + r * t - i * s, this._y = r * e + o * s + i * a - n * t, this._z = i * e + o * t + n * s - r * a, this._w = o * e - n * a - r * s - i * t, this._onChangeCallback(), this
    }, zn.prototype.slerp = function(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        var n = this._x,
            r = this._y,
            i = this._z,
            o = this._w,
            a = o * t._w + n * t._x + r * t._y + i * t._z;
        if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), 1 <= a) return this._w = o, this._x = n, this._y = r, this._z = i, this;
        t = 1 - a * a;
        if (t <= Number.EPSILON) { var s = 1 - e; return this._w = s * o + e * this._w, this._x = s * n + e * this._x, this._y = s * r + e * this._y, this._z = s * i + e * this._z, this.normalize(), this._onChangeCallback(), this }
        s = Math.sqrt(t), t = Math.atan2(s, a), a = Math.sin((1 - e) * t) / s, s = Math.sin(e * t) / s;
        return this._w = o * a + this._w * s, this._x = n * a + this._x * s, this._y = r * a + this._y * s, this._z = i * a + this._z * s, this._onChangeCallback(), this
    }, zn.prototype.equals = function(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, zn.prototype.fromArray = function(t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this }, zn.prototype.toArray = function(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, zn.prototype.fromBufferAttribute = function(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this }, zn.prototype._onChange = function(t) { return this._onChangeCallback = t, this }, zn.prototype._onChangeCallback = function() {}, Object.defineProperties(zn.prototype, Hn);
    var kn = function(t, e, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), Object.defineProperty(this, "isVector3", { value: !0 }), this.x = t, this.y = e, this.z = n };
    kn.prototype.set = function(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this }, kn.prototype.setScalar = function(t) { return this.x = t, this.y = t, this.z = t, this }, kn.prototype.setX = function(t) { return this.x = t, this }, kn.prototype.setY = function(t) { return this.y = t, this }, kn.prototype.setZ = function(t) { return this.z = t, this }, kn.prototype.setComponent = function(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }, kn.prototype.getComponent = function(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
        }
    }, kn.prototype.clone = function() { return new this.constructor(this.x, this.y, this.z) }, kn.prototype.copy = function(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, kn.prototype.add = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, kn.prototype.addScalar = function(t) { return this.x += t, this.y += t, this.z += t, this }, kn.prototype.addVectors = function(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, kn.prototype.addScaledVector = function(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, kn.prototype.sub = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, kn.prototype.subScalar = function(t) { return this.x -= t, this.y -= t, this.z -= t, this }, kn.prototype.subVectors = function(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, kn.prototype.multiply = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, kn.prototype.multiplyScalar = function(t) { return this.x *= t, this.y *= t, this.z *= t, this }, kn.prototype.multiplyVectors = function(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, kn.prototype.applyEuler = function(t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Vn.setFromEuler(t)) }, kn.prototype.applyAxisAngle = function(t, e) { return this.applyQuaternion(Vn.setFromAxisAngle(t, e)) }, kn.prototype.applyMatrix3 = function(t) {
        var e = this.x,
            n = this.y,
            r = this.z,
            t = t.elements;
        return this.x = t[0] * e + t[3] * n + t[6] * r, this.y = t[1] * e + t[4] * n + t[7] * r, this.z = t[2] * e + t[5] * n + t[8] * r, this
    }, kn.prototype.applyNormalMatrix = function(t) { return this.applyMatrix3(t).normalize() }, kn.prototype.applyMatrix4 = function(t) {
        var e = this.x,
            n = this.y,
            r = this.z,
            i = t.elements,
            t = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
        return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * t, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * t, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * t, this
    }, kn.prototype.applyQuaternion = function(t) {
        var e = this.x,
            n = this.y,
            r = this.z,
            i = t.x,
            o = t.y,
            a = t.z,
            s = t.w,
            c = s * e + o * r - a * n,
            l = s * n + a * e - i * r,
            t = s * r + i * n - o * e,
            r = -i * e - o * n - a * r;
        return this.x = c * s + r * -i + l * -a - t * -o, this.y = l * s + r * -o + t * -i - c * -a, this.z = t * s + r * -a + c * -o - l * -i, this
    }, kn.prototype.project = function(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }, kn.prototype.unproject = function(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }, kn.prototype.transformDirection = function(t) {
        var e = this.x,
            n = this.y,
            r = this.z,
            t = t.elements;
        return this.x = t[0] * e + t[4] * n + t[8] * r, this.y = t[1] * e + t[5] * n + t[9] * r, this.z = t[2] * e + t[6] * n + t[10] * r, this.normalize()
    }, kn.prototype.divide = function(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, kn.prototype.divideScalar = function(t) { return this.multiplyScalar(1 / t) }, kn.prototype.min = function(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, kn.prototype.max = function(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, kn.prototype.clamp = function(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, kn.prototype.clampScalar = function(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }, kn.prototype.clampLength = function(t, e) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, kn.prototype.floor = function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, kn.prototype.ceil = function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, kn.prototype.round = function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, kn.prototype.roundToZero = function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, kn.prototype.negate = function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, kn.prototype.dot = function(t) { return this.x * t.x + this.y * t.y + this.z * t.z }, kn.prototype.lengthSq = function() { return this.x * this.x + this.y * this.y + this.z * this.z }, kn.prototype.length = function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, kn.prototype.manhattanLength = function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, kn.prototype.normalize = function() { return this.divideScalar(this.length() || 1) }, kn.prototype.setLength = function(t) { return this.normalize().multiplyScalar(t) }, kn.prototype.lerp = function(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, kn.prototype.lerpVectors = function(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this }, kn.prototype.cross = function(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }, kn.prototype.crossVectors = function(t, e) {
        var n = t.x,
            r = t.y,
            i = t.z,
            o = e.x,
            t = e.y,
            e = e.z;
        return this.x = r * e - i * t, this.y = i * o - n * e, this.z = n * t - r * o, this
    }, kn.prototype.projectOnVector = function(t) {
        var e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        e = t.dot(this) / e;
        return this.copy(t).multiplyScalar(e)
    }, kn.prototype.projectOnPlane = function(t) { return Gn.copy(this).projectOnVector(t), this.sub(Gn) }, kn.prototype.reflect = function(t) { return this.sub(Gn.copy(t).multiplyScalar(2 * this.dot(t))) }, kn.prototype.angleTo = function(t) {
        var e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        e = this.dot(t) / e;
        return Math.acos(An.clamp(e, -1, 1))
    }, kn.prototype.distanceTo = function(t) { return Math.sqrt(this.distanceToSquared(t)) }, kn.prototype.distanceToSquared = function(t) {
        var e = this.x - t.x,
            n = this.y - t.y,
            t = this.z - t.z;
        return e * e + n * n + t * t
    }, kn.prototype.manhattanDistanceTo = function(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, kn.prototype.setFromSpherical = function(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }, kn.prototype.setFromSphericalCoords = function(t, e, n) { var r = Math.sin(e) * t; return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this }, kn.prototype.setFromCylindrical = function(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }, kn.prototype.setFromCylindricalCoords = function(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this }, kn.prototype.setFromMatrixPosition = function(t) { t = t.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this }, kn.prototype.setFromMatrixScale = function(t) {
        var e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            t = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = n, this.z = t, this
    }, kn.prototype.setFromMatrixColumn = function(t, e) { return this.fromArray(t.elements, 4 * e) }, kn.prototype.setFromMatrix3Column = function(t, e) { return this.fromArray(t.elements, 3 * e) }, kn.prototype.equals = function(t) { return t.x === this.x && t.y === this.y && t.z === this.z }, kn.prototype.fromArray = function(t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, kn.prototype.toArray = function(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, kn.prototype.fromBufferAttribute = function(t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this }, kn.prototype.random = function() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this };
    var Gn = new kn,
        Vn = new zn,
        jn = function(t, e) { Object.defineProperty(this, "isBox3", { value: !0 }), this.min = void 0 !== t ? t : new kn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new kn(-1 / 0, -1 / 0, -1 / 0) };

    function Wn(t, e, n, r, i) {
        for (var o = 0, a = t.length - 3; o <= a; o += 3) {
            ir.fromArray(t, o);
            var s = i.x * Math.abs(ir.x) + i.y * Math.abs(ir.y) + i.z * Math.abs(ir.z),
                c = e.dot(ir),
                l = n.dot(ir),
                u = r.dot(ir);
            if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > s) return !1
        }
        return !0
    }
    jn.prototype.set = function(t, e) { return this.min.copy(t), this.max.copy(e), this }, jn.prototype.setFromArray = function(t) {
        for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
            var l = t[s],
                u = t[s + 1],
                h = t[s + 2];
            l < e && (e = l), u < n && (n = u), h < r && (r = h), i < l && (i = l), o < u && (o = u), a < h && (a = h)
        }
        return this.min.set(e, n, r), this.max.set(i, o, a), this
    }, jn.prototype.setFromBufferAttribute = function(t) {
        for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
            var l = t.getX(s),
                u = t.getY(s),
                h = t.getZ(s);
            l < e && (e = l), u < n && (n = u), h < r && (r = h), i < l && (i = l), o < u && (o = u), a < h && (a = h)
        }
        return this.min.set(e, n, r), this.max.set(i, o, a), this
    }, jn.prototype.setFromPoints = function(t) { this.makeEmpty(); for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }, jn.prototype.setFromCenterAndSize = function(t, e) { e = Xn.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(e), this.max.copy(t).add(e), this }, jn.prototype.setFromObject = function(t) { return this.makeEmpty(), this.expandByObject(t) }, jn.prototype.clone = function() { return (new this.constructor).copy(this) }, jn.prototype.copy = function(t) { return this.min.copy(t.min), this.max.copy(t.max), this }, jn.prototype.makeEmpty = function() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, jn.prototype.isEmpty = function() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, jn.prototype.getCenter = function(t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new kn), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, jn.prototype.getSize = function(t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new kn), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }, jn.prototype.expandByPoint = function(t) { return this.min.min(t), this.max.max(t), this }, jn.prototype.expandByVector = function(t) { return this.min.sub(t), this.max.add(t), this }, jn.prototype.expandByScalar = function(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, jn.prototype.expandByObject = function(t) {
        t.updateWorldMatrix(!1, !1);
        var e = t.geometry;
        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Yn.copy(e.boundingBox), Yn.applyMatrix4(t.matrixWorld), this.union(Yn));
        for (var n = t.children, r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
        return this
    }, jn.prototype.containsPoint = function(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, jn.prototype.containsBox = function(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, jn.prototype.getParameter = function(t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new kn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, jn.prototype.intersectsBox = function(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, jn.prototype.intersectsSphere = function(t) { return this.clampPoint(t.center, Xn), Xn.distanceToSquared(t.center) <= t.radius * t.radius }, jn.prototype.intersectsPlane = function(t) { var e, n = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x); return 0 < t.normal.y ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant }, jn.prototype.intersectsTriangle = function(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(er), nr.subVectors(this.max, er), Zn.subVectors(t.a, er), Jn.subVectors(t.b, er), Kn.subVectors(t.c, er), Qn.subVectors(Jn, Zn), $n.subVectors(Kn, Jn), tr.subVectors(Zn, Kn);
        t = [0, -Qn.z, Qn.y, 0, -$n.z, $n.y, 0, -tr.z, tr.y, Qn.z, 0, -Qn.x, $n.z, 0, -$n.x, tr.z, 0, -tr.x, -Qn.y, Qn.x, 0, -$n.y, $n.x, 0, -tr.y, tr.x, 0];
        return !!Wn(t, Zn, Jn, Kn, nr) && (!!Wn(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], Zn, Jn, Kn, nr) && (rr.crossVectors(Qn, $n), Wn(t = [rr.x, rr.y, rr.z], Zn, Jn, Kn, nr)))
    }, jn.prototype.clampPoint = function(t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new kn), e.copy(t).clamp(this.min, this.max) }, jn.prototype.distanceToPoint = function(t) { return Xn.copy(t).clamp(this.min, this.max).sub(t).length() }, jn.prototype.getBoundingSphere = function(t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(Xn).length(), t }, jn.prototype.intersect = function(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, jn.prototype.union = function(t) { return this.min.min(t.min), this.max.max(t.max), this }, jn.prototype.applyMatrix4 = function(t) { return this.isEmpty() || (qn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), qn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), qn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), qn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), qn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), qn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), qn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), qn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(qn)), this }, jn.prototype.translate = function(t) { return this.min.add(t), this.max.add(t), this }, jn.prototype.equals = function(t) { return t.min.equals(this.min) && t.max.equals(this.max) };
    var qn = [new kn, new kn, new kn, new kn, new kn, new kn, new kn, new kn],
        Xn = new kn,
        Yn = new jn,
        Zn = new kn,
        Jn = new kn,
        Kn = new kn,
        Qn = new kn,
        $n = new kn,
        tr = new kn,
        er = new kn,
        nr = new kn,
        rr = new kn,
        ir = new kn,
        or = new jn,
        ar = function(t, e) { this.center = void 0 !== t ? t : new kn, this.radius = void 0 !== e ? e : -1 };
    ar.prototype.set = function(t, e) { return this.center.copy(t), this.radius = e, this }, ar.prototype.setFromPoints = function(t, e) {
        var n = this.center;
        void 0 !== e ? n.copy(e) : or.setFromPoints(t).getCenter(n);
        for (var r = 0, i = 0, o = t.length; i < o; i++) r = Math.max(r, n.distanceToSquared(t[i]));
        return this.radius = Math.sqrt(r), this
    }, ar.prototype.clone = function() { return (new this.constructor).copy(this) }, ar.prototype.copy = function(t) { return this.center.copy(t.center), this.radius = t.radius, this }, ar.prototype.isEmpty = function() { return this.radius < 0 }, ar.prototype.makeEmpty = function() { return this.center.set(0, 0, 0), this.radius = -1, this }, ar.prototype.containsPoint = function(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, ar.prototype.distanceToPoint = function(t) { return t.distanceTo(this.center) - this.radius }, ar.prototype.intersectsSphere = function(t) { var e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, ar.prototype.intersectsBox = function(t) { return t.intersectsSphere(this) }, ar.prototype.intersectsPlane = function(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }, ar.prototype.clampPoint = function(t, e) { var n = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new kn), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }, ar.prototype.getBoundingBox = function(t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new jn), this.isEmpty() ? t.makeEmpty() : (t.set(this.center, this.center), t.expandByScalar(this.radius)), t }, ar.prototype.applyMatrix4 = function(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }, ar.prototype.translate = function(t) { return this.center.add(t), this }, ar.prototype.equals = function(t) { return t.center.equals(this.center) && t.radius === this.radius };
    var sr = new kn,
        cr = new kn,
        lr = new kn,
        ur = new kn,
        hr = new kn,
        pr = new kn,
        dr = new kn,
        fr = function(t, e) { this.origin = void 0 !== t ? t : new kn, this.direction = void 0 !== e ? e : new kn(0, 0, -1) };
    fr.prototype.set = function(t, e) { return this.origin.copy(t), this.direction.copy(e), this }, fr.prototype.clone = function() { return (new this.constructor).copy(this) }, fr.prototype.copy = function(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, fr.prototype.at = function(t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new kn), e.copy(this.direction).multiplyScalar(t).add(this.origin) }, fr.prototype.lookAt = function(t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, fr.prototype.recast = function(t) { return this.origin.copy(this.at(t, sr)), this }, fr.prototype.closestPointToPoint = function(t, e) {
        void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new kn), e.subVectors(t, this.origin);
        t = e.dot(this.direction);
        return t < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin)
    }, fr.prototype.distanceToPoint = function(t) { return Math.sqrt(this.distanceSqToPoint(t)) }, fr.prototype.distanceSqToPoint = function(t) { var e = sr.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (sr.copy(this.direction).multiplyScalar(e).add(this.origin), sr.distanceToSquared(t)) }, fr.prototype.distanceSqToSegment = function(t, e, n, r) {
        cr.copy(t).add(e).multiplyScalar(.5), lr.copy(e).sub(t).normalize(), ur.copy(this.origin).sub(cr);
        var i, o, a = .5 * t.distanceTo(e),
            s = -this.direction.dot(lr),
            c = ur.dot(this.direction),
            l = -ur.dot(lr),
            u = ur.lengthSq(),
            t = Math.abs(1 - s * s);
        return u = 0 < t ? (o = s * c - l, e = a * t, 0 <= (i = s * l - c) ? -e <= o ? o <= e ? (i *= t = 1 / t) * (i + s * (o *= t) + 2 * c) + o * (s * i + o + 2 * l) + u : (o = a, -(i = Math.max(0, -(s * o + c))) * i + o * (o + 2 * l) + u) : (o = -a, -(i = Math.max(0, -(s * o + c))) * i + o * (o + 2 * l) + u) : o <= -e ? -(i = Math.max(0, -(-s * a + c))) * i + (o = 0 < i ? -a : Math.min(Math.max(-a, -l), a)) * (o + 2 * l) + u : o <= e ? (i = 0, (o = Math.min(Math.max(-a, -l), a)) * (o + 2 * l) + u) : -(i = Math.max(0, -(s * a + c))) * i + (o = 0 < i ? a : Math.min(Math.max(-a, -l), a)) * (o + 2 * l) + u) : (o = 0 < s ? -a : a, -(i = Math.max(0, -(s * o + c))) * i + o * (o + 2 * l) + u), n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(lr).multiplyScalar(o).add(cr), u
    }, fr.prototype.intersectSphere = function(t, e) {
        sr.subVectors(t.center, this.origin);
        var n = sr.dot(this.direction),
            r = sr.dot(sr) - n * n,
            t = t.radius * t.radius;
        if (t < r) return null;
        t = Math.sqrt(t - r), r = n - t, t = n + t;
        return r < 0 && t < 0 ? null : r < 0 ? this.at(t, e) : this.at(r, e)
    }, fr.prototype.intersectsSphere = function(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }, fr.prototype.distanceToPlane = function(t) {
        var e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        e = -(this.origin.dot(t.normal) + t.constant) / e;
        return 0 <= e ? e : null
    }, fr.prototype.intersectPlane = function(t, e) { t = this.distanceToPlane(t); return null === t ? null : this.at(t, e) }, fr.prototype.intersectsPlane = function(t) { var e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }, fr.prototype.intersectBox = function(t, e) {
        var n, r, i, o = 1 / this.direction.x,
            a = 1 / this.direction.y,
            s = 1 / this.direction.z,
            c = this.origin,
            o = 0 <= o ? (n = (t.min.x - c.x) * o, (t.max.x - c.x) * o) : (n = (t.max.x - c.x) * o, (t.min.x - c.x) * o),
            a = 0 <= a ? (r = (t.min.y - c.y) * a, (t.max.y - c.y) * a) : (r = (t.max.y - c.y) * a, (t.min.y - c.y) * a);
        return a < n || o < r ? null : ((n < r || n != n) && (n = r), (a < o || o != o) && (o = a), (s = 0 <= s ? (i = (t.min.z - c.z) * s, (t.max.z - c.z) * s) : (i = (t.max.z - c.z) * s, (t.min.z - c.z) * s)) < n || o < i ? null : ((n < i || n != n) && (n = i), (s < o || o != o) && (o = s), o < 0 ? null : this.at(0 <= n ? n : o, e)))
    }, fr.prototype.intersectsBox = function(t) { return null !== this.intersectBox(t, sr) }, fr.prototype.intersectTriangle = function(t, e, n, r, i) {
        hr.subVectors(e, t), pr.subVectors(n, t), dr.crossVectors(hr, pr);
        n = this.direction.dot(dr);
        if (0 < n) {
            if (r) return null;
            o = 1
        } else {
            if (!(n < 0)) return null;
            o = -1, n = -n
        }
        ur.subVectors(this.origin, t);
        r = o * this.direction.dot(pr.crossVectors(ur, pr));
        if (r < 0) return null;
        t = o * this.direction.dot(hr.cross(ur));
        if (t < 0) return null;
        if (n < r + t) return null;
        var o = -o * ur.dot(dr);
        return o < 0 ? null : this.at(o / n, i)
    }, fr.prototype.applyMatrix4 = function(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }, fr.prototype.equals = function(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) };
    var mr = function() { Object.defineProperty(this, "isMatrix4", { value: !0 }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") };
    mr.prototype.set = function(t, e, n, r, i, o, a, s, c, l, u, h, p, d, f, m) { var g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this }, mr.prototype.identity = function() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, mr.prototype.clone = function() { return (new mr).fromArray(this.elements) }, mr.prototype.copy = function(t) {
        var e = this.elements,
            t = t.elements;
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this
    }, mr.prototype.copyPosition = function(t) {
        var e = this.elements,
            t = t.elements;
        return e[12] = t[12], e[13] = t[13], e[14] = t[14], this
    }, mr.prototype.extractBasis = function(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }, mr.prototype.makeBasis = function(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this }, mr.prototype.extractRotation = function(t) {
        var e = this.elements,
            n = t.elements,
            r = 1 / gr.setFromMatrixColumn(t, 0).length(),
            i = 1 / gr.setFromMatrixColumn(t, 1).length(),
            t = 1 / gr.setFromMatrixColumn(t, 2).length();
        return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * t, e[9] = n[9] * t, e[10] = n[10] * t, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }, mr.prototype.makeRotationFromEuler = function(t) {
        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var e, n, r, i, o, a, s, c, l, u, h, p = this.elements,
            d = t.x,
            f = t.y,
            m = t.z,
            g = Math.cos(d),
            v = Math.sin(d),
            y = Math.cos(f),
            _ = Math.sin(f),
            d = Math.cos(m),
            f = Math.sin(m);
        return "XYZ" === t.order ? (e = g * d, r = g * f, n = v * d, m = v * f, p[0] = y * d, p[4] = -y * f, p[8] = _, p[1] = r + n * _, p[5] = e - m * _, p[9] = -v * y, p[2] = m - e * _, p[6] = n + r * _, p[10] = g * y) : "YXZ" === t.order ? (i = y * d, e = y * f, n = _ * d, r = _ * f, p[0] = i + r * v, p[4] = n * v - e, p[8] = g * _, p[1] = g * f, p[5] = g * d, p[9] = -v, p[2] = e * v - n, p[6] = r + i * v, p[10] = g * y) : "ZXY" === t.order ? (s = y * d, i = y * f, o = _ * d, a = _ * f, p[0] = s - a * v, p[4] = -g * f, p[8] = o + i * v, p[1] = i + o * v, p[5] = g * d, p[9] = a - s * v, p[2] = -g * _, p[6] = v, p[10] = g * y) : "ZYX" === t.order ? (o = g * d, a = g * f, c = v * d, s = v * f, p[0] = y * d, p[4] = c * _ - a, p[8] = o * _ + s, p[1] = y * f, p[5] = s * _ + o, p[9] = a * _ - c, p[2] = -_, p[6] = v * y, p[10] = g * y) : "YZX" === t.order ? (u = g * y, c = g * _, l = v * y, h = v * _, p[0] = y * d, p[4] = h - u * f, p[8] = l * f + c, p[1] = f, p[5] = g * d, p[9] = -v * d, p[2] = -_ * d, p[6] = c * f + l, p[10] = u - h * f) : "XZY" === t.order && (l = g * y, u = g * _, h = v * y, t = v * _, p[0] = y * d, p[4] = -f, p[8] = _ * d, p[1] = l * f + t, p[5] = g * d, p[9] = u * f - h, p[2] = h * f - u, p[6] = v * d, p[10] = t * f + l), p[3] = 0, p[7] = 0, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, this
    }, mr.prototype.makeRotationFromQuaternion = function(t) { return this.compose(yr, t, _r) }, mr.prototype.lookAt = function(t, e, n) { var r = this.elements; return wr.subVectors(t, e), 0 === wr.lengthSq() && (wr.z = 1), wr.normalize(), xr.crossVectors(n, wr), 0 === xr.lengthSq() && (1 === Math.abs(n.z) ? wr.x += 1e-4 : wr.z += 1e-4, wr.normalize(), xr.crossVectors(n, wr)), xr.normalize(), br.crossVectors(wr, xr), r[0] = xr.x, r[4] = br.x, r[8] = wr.x, r[1] = xr.y, r[5] = br.y, r[9] = wr.y, r[2] = xr.z, r[6] = br.z, r[10] = wr.z, this }, mr.prototype.multiply = function(t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, mr.prototype.premultiply = function(t) { return this.multiplyMatrices(t, this) }, mr.prototype.multiplyMatrices = function(t, e) {
        var n = t.elements,
            r = e.elements,
            i = this.elements,
            o = n[0],
            a = n[4],
            s = n[8],
            c = n[12],
            l = n[1],
            u = n[5],
            h = n[9],
            p = n[13],
            d = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            y = n[7],
            _ = n[11],
            x = n[15],
            b = r[0],
            w = r[4],
            M = r[8],
            S = r[12],
            E = r[1],
            T = r[5],
            A = r[9],
            L = r[13],
            R = r[2],
            C = r[6],
            P = r[10],
            O = r[14],
            t = r[3],
            e = r[7],
            n = r[11],
            r = r[15];
        return i[0] = o * b + a * E + s * R + c * t, i[4] = o * w + a * T + s * C + c * e, i[8] = o * M + a * A + s * P + c * n, i[12] = o * S + a * L + s * O + c * r, i[1] = l * b + u * E + h * R + p * t, i[5] = l * w + u * T + h * C + p * e, i[9] = l * M + u * A + h * P + p * n, i[13] = l * S + u * L + h * O + p * r, i[2] = d * b + f * E + m * R + g * t, i[6] = d * w + f * T + m * C + g * e, i[10] = d * M + f * A + m * P + g * n, i[14] = d * S + f * L + m * O + g * r, i[3] = v * b + y * E + _ * R + x * t, i[7] = v * w + y * T + _ * C + x * e, i[11] = v * M + y * A + _ * P + x * n, i[15] = v * S + y * L + _ * O + x * r, this
    }, mr.prototype.multiplyScalar = function(t) { var e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, mr.prototype.determinant = function() {
        var t = this.elements,
            e = t[0],
            n = t[4],
            r = t[8],
            i = t[12],
            o = t[1],
            a = t[5],
            s = t[9],
            c = t[13],
            l = t[2],
            u = t[6],
            h = t[10],
            p = t[14];
        return t[3] * (+i * s * u - r * c * u - i * a * h + n * c * h + r * a * p - n * s * p) + t[7] * (+e * s * p - e * c * h + i * o * h - r * o * p + r * c * l - i * s * l) + t[11] * (+e * c * u - e * a * p - i * o * u + n * o * p + i * a * l - n * c * l) + t[15] * (-r * a * l - e * s * u + e * a * h + r * o * u - n * o * h + n * s * l)
    }, mr.prototype.transpose = function() {
        var t = this.elements,
            e = t[1];
        return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
    }, mr.prototype.setPosition = function(t, e, n) { var r = this.elements; return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this }, mr.prototype.getInverse = function(t, e) {
        void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
        var n = this.elements,
            r = t.elements,
            i = r[0],
            o = r[1],
            a = r[2],
            s = r[3],
            c = r[4],
            l = r[5],
            u = r[6],
            h = r[7],
            p = r[8],
            d = r[9],
            f = r[10],
            m = r[11],
            g = r[12],
            v = r[13],
            y = r[14],
            _ = r[15],
            x = d * y * h - v * f * h + v * u * m - l * y * m - d * u * _ + l * f * _,
            b = g * f * h - p * y * h - g * u * m + c * y * m + p * u * _ - c * f * _,
            e = p * v * h - g * d * h + g * l * m - c * v * m - p * l * _ + c * d * _,
            t = g * d * u - p * v * u - g * l * f + c * v * f + p * l * y - c * d * y,
            r = i * x + o * b + a * e + s * t;
        if (0 == r) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        r = 1 / r;
        return n[0] = x * r, n[1] = (v * f * s - d * y * s - v * a * m + o * y * m + d * a * _ - o * f * _) * r, n[2] = (l * y * s - v * u * s + v * a * h - o * y * h - l * a * _ + o * u * _) * r, n[3] = (d * u * s - l * f * s - d * a * h + o * f * h + l * a * m - o * u * m) * r, n[4] = b * r, n[5] = (p * y * s - g * f * s + g * a * m - i * y * m - p * a * _ + i * f * _) * r, n[6] = (g * u * s - c * y * s - g * a * h + i * y * h + c * a * _ - i * u * _) * r, n[7] = (c * f * s - p * u * s + p * a * h - i * f * h - c * a * m + i * u * m) * r, n[8] = e * r, n[9] = (g * d * s - p * v * s - g * o * m + i * v * m + p * o * _ - i * d * _) * r, n[10] = (c * v * s - g * l * s + g * o * h - i * v * h - c * o * _ + i * l * _) * r, n[11] = (p * l * s - c * d * s - p * o * h + i * d * h + c * o * m - i * l * m) * r, n[12] = t * r, n[13] = (p * v * a - g * d * a + g * o * f - i * v * f - p * o * y + i * d * y) * r, n[14] = (g * l * a - c * v * a - g * o * u + i * v * u + c * o * y - i * l * y) * r, n[15] = (c * d * a - p * l * a + p * o * u - i * d * u - c * o * f + i * l * f) * r, this
    }, mr.prototype.scale = function(t) {
        var e = this.elements,
            n = t.x,
            r = t.y,
            t = t.z;
        return e[0] *= n, e[4] *= r, e[8] *= t, e[1] *= n, e[5] *= r, e[9] *= t, e[2] *= n, e[6] *= r, e[10] *= t, e[3] *= n, e[7] *= r, e[11] *= t, this
    }, mr.prototype.getMaxScaleOnAxis = function() {
        var t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            t = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, t))
    }, mr.prototype.makeTranslation = function(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this }, mr.prototype.makeRotationX = function(t) {
        var e = Math.cos(t),
            t = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this
    }, mr.prototype.makeRotationY = function(t) {
        var e = Math.cos(t),
            t = Math.sin(t);
        return this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this
    }, mr.prototype.makeRotationZ = function(t) {
        var e = Math.cos(t),
            t = Math.sin(t);
        return this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }, mr.prototype.makeRotationAxis = function(t, e) {
        var n = Math.cos(e),
            r = Math.sin(e),
            i = 1 - n,
            o = t.x,
            a = t.y,
            s = t.z,
            e = i * o,
            t = i * a;
        return this.set(e * o + n, e * a - r * s, e * s + r * a, 0, e * a + r * s, t * a + n, t * s - r * o, 0, e * s - r * a, t * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
    }, mr.prototype.makeScale = function(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }, mr.prototype.makeShear = function(t, e, n) { return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this }, mr.prototype.compose = function(t, e, n) {
        var r = this.elements,
            i = e._x,
            o = e._y,
            a = e._z,
            s = e._w,
            c = i + i,
            l = o + o,
            u = a + a,
            h = i * c,
            p = i * l,
            d = i * u,
            e = o * l,
            i = o * u,
            o = a * u,
            a = s * c,
            c = s * l,
            l = s * u,
            s = n.x,
            u = n.y,
            n = n.z;
        return r[0] = (1 - (e + o)) * s, r[1] = (p + l) * s, r[2] = (d - c) * s, r[3] = 0, r[4] = (p - l) * u, r[5] = (1 - (h + o)) * u, r[6] = (i + a) * u, r[7] = 0, r[8] = (d + c) * n, r[9] = (i - a) * n, r[10] = (1 - (h + e)) * n, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
    }, mr.prototype.decompose = function(t, e, n) {
        var r = this.elements,
            i = gr.set(r[0], r[1], r[2]).length(),
            o = gr.set(r[4], r[5], r[6]).length(),
            a = gr.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], vr.copy(this);
        var s = 1 / i,
            t = 1 / o,
            r = 1 / a;
        return vr.elements[0] *= s, vr.elements[1] *= s, vr.elements[2] *= s, vr.elements[4] *= t, vr.elements[5] *= t, vr.elements[6] *= t, vr.elements[8] *= r, vr.elements[9] *= r, vr.elements[10] *= r, e.setFromRotationMatrix(vr), n.x = i, n.y = o, n.z = a, this
    }, mr.prototype.makePerspective = function(t, e, n, r, i, o) {
        void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        var a = this.elements,
            s = 2 * i / (e - t),
            c = 2 * i / (n - r),
            t = (e + t) / (e - t),
            n = (n + r) / (n - r),
            r = -(o + i) / (o - i),
            i = -2 * o * i / (o - i);
        return a[0] = s, a[4] = 0, a[8] = t, a[12] = 0, a[1] = 0, a[5] = c, a[9] = n, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = r, a[14] = i, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
    }, mr.prototype.makeOrthographic = function(t, e, n, r, i, o) {
        var a = this.elements,
            s = 1 / (e - t),
            c = 1 / (n - r),
            l = 1 / (o - i),
            t = (e + t) * s,
            r = (n + r) * c,
            i = (o + i) * l;
        return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -t, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -r, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -i, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
    }, mr.prototype.equals = function(t) {
        for (var e = this.elements, n = t.elements, r = 0; r < 16; r++)
            if (e[r] !== n[r]) return !1;
        return !0
    }, mr.prototype.fromArray = function(t, e) { void 0 === e && (e = 0); for (var n = 0; n < 16; n++) this.elements[n] = t[n + e]; return this }, mr.prototype.toArray = function(t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t };
    var gr = new kn,
        vr = new mr,
        yr = new kn(0, 0, 0),
        _r = new kn(1, 1, 1),
        xr = new kn,
        br = new kn,
        wr = new kn,
        Mr = function t(e, n, r, i) { void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === i && (i = t.DefaultOrder), Object.defineProperty(this, "isEuler", { value: !0 }), this._x = e, this._y = n, this._z = r, this._order = i },
        Sr = { x: { configurable: !0 }, y: { configurable: !0 }, z: { configurable: !0 }, order: { configurable: !0 } };
    Sr.x.get = function() { return this._x }, Sr.x.set = function(t) { this._x = t, this._onChangeCallback() }, Sr.y.get = function() { return this._y }, Sr.y.set = function(t) { this._y = t, this._onChangeCallback() }, Sr.z.get = function() { return this._z }, Sr.z.set = function(t) { this._z = t, this._onChangeCallback() }, Sr.order.get = function() { return this._order }, Sr.order.set = function(t) { this._order = t, this._onChangeCallback() }, Mr.prototype.set = function(t, e, n, r) { return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this._onChangeCallback(), this }, Mr.prototype.clone = function() { return new this.constructor(this._x, this._y, this._z, this._order) }, Mr.prototype.copy = function(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this }, Mr.prototype.setFromRotationMatrix = function(t, e, n) {
        var r = An.clamp,
            t = t.elements,
            i = t[0],
            o = t[4],
            a = t[8],
            s = t[1],
            c = t[5],
            l = t[9],
            u = t[2],
            h = t[6],
            p = t[10];
        switch (e = e || this._order) {
            case "XYZ":
                this._y = Math.asin(r(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-l, p), this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(h, c), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(s, c)) : (this._y = Math.atan2(-u, i), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(s, i));
                break;
            case "ZYX":
                this._y = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, p), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-o, c));
                break;
            case "YZX":
                this._z = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-l, c), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(a, p));
                break;
            case "XZY":
                this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-l, p), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
        }
        return this._order = e, !1 !== n && this._onChangeCallback(), this
    }, Mr.prototype.setFromQuaternion = function(t, e, n) { return Er.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Er, e, n) }, Mr.prototype.setFromVector3 = function(t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, Mr.prototype.reorder = function(t) { return Tr.setFromEuler(this), this.setFromQuaternion(Tr, t) }, Mr.prototype.equals = function(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, Mr.prototype.fromArray = function(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this }, Mr.prototype.toArray = function(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, Mr.prototype.toVector3 = function(t) { return t ? t.set(this._x, this._y, this._z) : new kn(this._x, this._y, this._z) }, Mr.prototype._onChange = function(t) { return this._onChangeCallback = t, this }, Mr.prototype._onChangeCallback = function() {}, Object.defineProperties(Mr.prototype, Sr), Mr.DefaultOrder = "XYZ", Mr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    var Er = new mr,
        Tr = new zn,
        Ar = function() { this.mask = 1 };
    Ar.prototype.set = function(t) { this.mask = 1 << t | 0 }, Ar.prototype.enable = function(t) { this.mask |= 1 << t | 0 }, Ar.prototype.enableAll = function() { this.mask = -1 }, Ar.prototype.toggle = function(t) { this.mask ^= 1 << t | 0 }, Ar.prototype.disable = function(t) { this.mask &= ~(1 << t | 0) }, Ar.prototype.disableAll = function() { this.mask = 0 }, Ar.prototype.test = function(t) { return 0 != (this.mask & t.mask) };
    var Lr = 0,
        Rr = new kn,
        Cr = new zn,
        Pr = new mr,
        Or = new kn,
        Ir = new kn,
        Dr = new kn,
        Nr = new zn,
        Br = new kn(1, 0, 0),
        Fr = new kn(0, 1, 0),
        Ur = new kn(0, 0, 1),
        zr = { type: "added" },
        Hr = { type: "removed" };

    function kr() {
        Object.defineProperty(this, "id", { value: Lr++ }), this.uuid = An.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = kr.DefaultUp.clone();
        var t = new kn,
            e = new Mr,
            n = new zn,
            r = new kn(1, 1, 1);
        e._onChange(function() { n.setFromEuler(e, !1) }), n._onChange(function() { e.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new mr }, normalMatrix: { value: new Pn } }), this.matrix = new mr, this.matrixWorld = new mr, this.matrixAutoUpdate = kr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Ar, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }
    kr.DefaultUp = new kn(0, 1, 0), kr.DefaultMatrixAutoUpdate = !0, kr.prototype = Object.assign(Object.create(Mn.prototype), {
        constructor: kr,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix4: function(t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) },
        applyQuaternion: function(t) { return this.quaternion.premultiply(t), this },
        setRotationFromAxisAngle: function(t, e) { this.quaternion.setFromAxisAngle(t, e) },
        setRotationFromEuler: function(t) { this.quaternion.setFromEuler(t, !0) },
        setRotationFromMatrix: function(t) { this.quaternion.setFromRotationMatrix(t) },
        setRotationFromQuaternion: function(t) { this.quaternion.copy(t) },
        rotateOnAxis: function(t, e) { return Cr.setFromAxisAngle(t, e), this.quaternion.multiply(Cr), this },
        rotateOnWorldAxis: function(t, e) { return Cr.setFromAxisAngle(t, e), this.quaternion.premultiply(Cr), this },
        rotateX: function(t) { return this.rotateOnAxis(Br, t) },
        rotateY: function(t) { return this.rotateOnAxis(Fr, t) },
        rotateZ: function(t) { return this.rotateOnAxis(Ur, t) },
        translateOnAxis: function(t, e) { return Rr.copy(t).applyQuaternion(this.quaternion), this.position.add(Rr.multiplyScalar(e)), this },
        translateX: function(t) { return this.translateOnAxis(Br, t) },
        translateY: function(t) { return this.translateOnAxis(Fr, t) },
        translateZ: function(t) { return this.translateOnAxis(Ur, t) },
        localToWorld: function(t) { return t.applyMatrix4(this.matrixWorld) },
        worldToLocal: function(t) { return t.applyMatrix4(Pr.getInverse(this.matrixWorld)) },
        lookAt: function(t, e, n) {
            t.isVector3 ? Or.copy(t) : Or.set(t, e, n);
            n = this.parent;
            this.updateWorldMatrix(!0, !1), Ir.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Pr.lookAt(Ir, Or, this.up) : Pr.lookAt(Or, Ir, this.up), this.quaternion.setFromRotationMatrix(Pr), n && (Pr.extractRotation(n.matrixWorld), Cr.setFromRotationMatrix(Pr), this.quaternion.premultiply(Cr.inverse()))
        },
        add: function(t) { var e = arguments; if (1 < arguments.length) { for (var n = 0; n < arguments.length; n++) this.add(e[n]); return this } return t === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", t) : t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), (t.parent = this).children.push(t), t.dispatchEvent(zr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this },
        remove: function(t) { var e = arguments; if (1 < arguments.length) { for (var n = 0; n < arguments.length; n++) this.remove(e[n]); return this } var r = this.children.indexOf(t); return -1 !== r && (t.parent = null, this.children.splice(r, 1), t.dispatchEvent(Hr)), this },
        attach: function(t) { return this.updateWorldMatrix(!0, !1), Pr.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Pr.multiply(t.parent.matrixWorld)), t.applyMatrix4(Pr), t.updateWorldMatrix(!1, !1), this.add(t), this },
        getObjectById: function(t) { return this.getObjectByProperty("id", t) },
        getObjectByName: function(t) { return this.getObjectByProperty("name", t) },
        getObjectByProperty: function(t, e) { if (this[t] === e) return this; for (var n = 0, r = this.children.length; n < r; n++) { var i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } },
        getWorldPosition: function(t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new kn), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) },
        getWorldQuaternion: function(t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new zn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ir, t, Dr), t },
        getWorldScale: function(t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new kn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ir, Nr, t), t },
        getWorldDirection: function(t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new kn), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() },
        raycast: function() {},
        traverse: function(t) { t(this); for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverse(t) },
        traverseVisible: function(t) { if (!1 !== this.visible) { t(this); for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t) } },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 },
        updateMatrixWorld: function(t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t = !(this.matrixWorldNeedsUpdate = !1)); for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t) },
        updateWorldMatrix: function(t, e) {
            var n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                for (var r = this.children, i = 0, o = r.length; i < o; i++) r[i].updateWorldMatrix(!1, !0)
        },
        toJSON: function(n) {
            var t = void 0 === n || "string" == typeof n,
                e = {};
            t && (n = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
            var r, i, o, a = {};

            function s(t, e) { return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(n)), e.uuid }
            if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), !1 === this.frustumCulled && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                a.geometry = s(n.geometries, this.geometry);
                var c = this.geometry.parameters;
                if (void 0 !== c && void 0 !== c.shapes) {
                    var l = c.shapes;
                    if (Array.isArray(l))
                        for (var u = 0, h = l.length; u < h; u++) {
                            var p = l[u];
                            s(n.shapes, p)
                        } else s(n.shapes, l)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (var d = [], f = 0, m = this.material.length; f < m; f++) d.push(s(n.materials, this.material[f]));
                    a.material = d
                } else a.material = s(n.materials, this.material);
            if (0 < this.children.length) { a.children = []; for (var g = 0; g < this.children.length; g++) a.children.push(this.children[g].toJSON(n).object) }
            return t && (r = v(n.geometries), i = v(n.materials), o = v(n.textures), c = v(n.images), t = v(n.shapes), 0 < r.length && (e.geometries = r), 0 < i.length && (e.materials = i), 0 < o.length && (e.textures = o), 0 < c.length && (e.images = c), 0 < t.length && (e.shapes = t)), e.object = a, e;

            function v(t) {
                var e, n = [];
                for (e in t) {
                    var r = t[e];
                    delete r.metadata, n.push(r)
                }
                return n
            }
        },
        clone: function(t) { return (new this.constructor).copy(this, t) },
        copy: function(t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (var n = 0; n < t.children.length; n++) {
                    var r = t.children[n];
                    this.add(r.clone())
                }
            return this
        }
    });
    var Gr = new kn,
        Vr = new kn,
        jr = new Pn,
        Wr = function(t, e) { Object.defineProperty(this, "isPlane", { value: !0 }), this.normal = void 0 !== t ? t : new kn(1, 0, 0), this.constant = void 0 !== e ? e : 0 };
    Wr.prototype.set = function(t, e) { return this.normal.copy(t), this.constant = e, this }, Wr.prototype.setComponents = function(t, e, n, r) { return this.normal.set(t, e, n), this.constant = r, this }, Wr.prototype.setFromNormalAndCoplanarPoint = function(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, Wr.prototype.setFromCoplanarPoints = function(t, e, n) { e = Gr.subVectors(n, e).cross(Vr.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(e, t), this }, Wr.prototype.clone = function() { return (new this.constructor).copy(this) }, Wr.prototype.copy = function(t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, Wr.prototype.normalize = function() { var t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, Wr.prototype.negate = function() { return this.constant *= -1, this.normal.negate(), this }, Wr.prototype.distanceToPoint = function(t) { return this.normal.dot(t) + this.constant }, Wr.prototype.distanceToSphere = function(t) { return this.distanceToPoint(t.center) - t.radius }, Wr.prototype.projectPoint = function(t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new kn), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }, Wr.prototype.intersectLine = function(t, e) {
        void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new kn);
        var n = t.delta(Gr),
            r = this.normal.dot(n);
        if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
        r = -(t.start.dot(this.normal) + this.constant) / r;
        return r < 0 || 1 < r ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
    }, Wr.prototype.intersectsLine = function(t) {
        var e = this.distanceToPoint(t.start),
            t = this.distanceToPoint(t.end);
        return e < 0 && 0 < t || t < 0 && 0 < e
    }, Wr.prototype.intersectsBox = function(t) { return t.intersectsPlane(this) }, Wr.prototype.intersectsSphere = function(t) { return t.intersectsPlane(this) }, Wr.prototype.coplanarPoint = function(t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new kn), t.copy(this.normal).multiplyScalar(-this.constant) }, Wr.prototype.applyMatrix4 = function(t, e) { e = e || jr.getNormalMatrix(t), t = this.coplanarPoint(Gr).applyMatrix4(t), e = this.normal.applyMatrix3(e).normalize(); return this.constant = -t.dot(e), this }, Wr.prototype.translate = function(t) { return this.constant -= t.dot(this.normal), this }, Wr.prototype.equals = function(t) { return t.normal.equals(this.normal) && t.constant === this.constant };
    var qr = new kn,
        Xr = new kn,
        Yr = new kn,
        Zr = new kn,
        Jr = new kn,
        Kr = new kn,
        Qr = new kn,
        $r = new kn,
        ti = new kn,
        ei = new kn,
        ni = function(t, e, n) { this.a = void 0 !== t ? t : new kn, this.b = void 0 !== e ? e : new kn, this.c = void 0 !== n ? n : new kn };
    ni.getNormal = function(t, e, n, r) {
        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new kn), r.subVectors(n, e), qr.subVectors(t, e), r.cross(qr);
        e = r.lengthSq();
        return 0 < e ? r.multiplyScalar(1 / Math.sqrt(e)) : r.set(0, 0, 0)
    }, ni.getBarycoord = function(t, e, n, r, i) {
        qr.subVectors(r, e), Xr.subVectors(n, e), Yr.subVectors(t, e);
        var o = qr.dot(qr),
            a = qr.dot(Xr),
            r = qr.dot(Yr),
            n = Xr.dot(Xr),
            t = Xr.dot(Yr),
            e = o * n - a * a;
        if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new kn), 0 == e) return i.set(-2, -1, -1);
        e = 1 / e, n = (n * r - a * t) * e, e *= o * t - a * r;
        return i.set(1 - n - e, e, n)
    }, ni.containsPoint = function(t, e, n, r) { return this.getBarycoord(t, e, n, r, Zr), 0 <= Zr.x && 0 <= Zr.y && Zr.x + Zr.y <= 1 }, ni.getUV = function(t, e, n, r, i, o, a, s) { return this.getBarycoord(t, e, n, r, Zr), s.set(0, 0), s.addScaledVector(i, Zr.x), s.addScaledVector(o, Zr.y), s.addScaledVector(a, Zr.z), s }, ni.isFrontFacing = function(t, e, n, r) { return qr.subVectors(n, e), Xr.subVectors(t, e), qr.cross(Xr).dot(r) < 0 }, ni.prototype.set = function(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }, ni.prototype.setFromPointsAndIndices = function(t, e, n, r) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this }, ni.prototype.clone = function() { return (new this.constructor).copy(this) }, ni.prototype.copy = function(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, ni.prototype.getArea = function() { return qr.subVectors(this.c, this.b), Xr.subVectors(this.a, this.b), .5 * qr.cross(Xr).length() }, ni.prototype.getMidpoint = function(t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new kn), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, ni.prototype.getNormal = function(t) { return ni.getNormal(this.a, this.b, this.c, t) }, ni.prototype.getPlane = function(t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Wr), t.setFromCoplanarPoints(this.a, this.b, this.c) }, ni.prototype.getBarycoord = function(t, e) { return ni.getBarycoord(t, this.a, this.b, this.c, e) }, ni.prototype.getUV = function(t, e, n, r, i) { return ni.getUV(t, this.a, this.b, this.c, e, n, r, i) }, ni.prototype.containsPoint = function(t) { return ni.containsPoint(t, this.a, this.b, this.c) }, ni.prototype.isFrontFacing = function(t) { return ni.isFrontFacing(this.a, this.b, this.c, t) }, ni.prototype.intersectsBox = function(t) { return t.intersectsTriangle(this) }, ni.prototype.closestPointToPoint = function(t, e) {
        void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new kn);
        var n = this.a,
            r = this.b,
            i = this.c;
        Jr.subVectors(r, n), Kr.subVectors(i, n), $r.subVectors(t, n);
        var o = Jr.dot($r),
            a = Kr.dot($r);
        if (o <= 0 && a <= 0) return e.copy(n);
        ti.subVectors(t, r);
        var s = Jr.dot(ti),
            c = Kr.dot(ti);
        if (0 <= s && c <= s) return e.copy(r);
        var l = o * c - s * a;
        if (l <= 0 && 0 <= o && s <= 0) return h = o / (o - s), e.copy(n).addScaledVector(Jr, h);
        ei.subVectors(t, i);
        var u = Jr.dot(ei),
            t = Kr.dot(ei);
        if (0 <= t && u <= t) return e.copy(i);
        o = u * a - o * t;
        if (o <= 0 && 0 <= a && t <= 0) return p = a / (a - t), e.copy(n).addScaledVector(Kr, p);
        a = s * t - u * c;
        if (a <= 0 && 0 <= c - s && 0 <= u - t) return Qr.subVectors(i, r), p = (c - s) / (c - s + (u - t)), e.copy(r).addScaledVector(Qr, p);
        var a = 1 / (a + o + l),
            h = o * a,
            p = l * a;
        return e.copy(n).addScaledVector(Jr, h).addScaledVector(Kr, p)
    }, ni.prototype.equals = function(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) };
    var ri = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 },
        ii = { h: 0, s: 0, l: 0 },
        oi = { h: 0, s: 0, l: 0 };

    function ai(t, e, n) { return n < 0 && (n += 1), 1 < n && --n, n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t }

    function si(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) }

    function ci(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 }
    var li = function(t, e, n) { return Object.defineProperty(this, "isColor", { value: !0 }), void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) };
    li.prototype.set = function(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, li.prototype.setScalar = function(t) { return this.r = t, this.g = t, this.b = t, this }, li.prototype.setHex = function(t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, li.prototype.setRGB = function(t, e, n) { return this.r = t, this.g = e, this.b = n, this }, li.prototype.setHSL = function(t, e, n) { return t = An.euclideanModulo(t, 1), e = An.clamp(e, 0, 1), n = An.clamp(n, 0, 1), 0 === e ? this.r = this.g = this.b = n : (e = 2 * n - (n = n <= .5 ? n * (1 + e) : n + e - n * e), this.r = ai(e, n, t + 1 / 3), this.g = ai(e, n, t), this.b = ai(e, n, t - 1 / 3)), this }, li.prototype.setStyle = function(e) {
        function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") }
        if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
            var n, r = c[1],
                i = c[2];
            switch (r) {
                case "rgb":
                case "rgba":
                    if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this;
                    if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this;
                    break;
                case "hsl":
                case "hsla":
                    if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) {
                        var o = parseFloat(n[1]) / 360,
                            a = parseInt(n[2], 10) / 100,
                            s = parseInt(n[3], 10) / 100;
                        return t(n[5]), this.setHSL(o, a, s)
                    }
            }
        } else if (c = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
            var r = c[1],
                c = r.length;
            if (3 === c) return this.r = parseInt(r.charAt(0) + r.charAt(0), 16) / 255, this.g = parseInt(r.charAt(1) + r.charAt(1), 16) / 255, this.b = parseInt(r.charAt(2) + r.charAt(2), 16) / 255, this;
            if (6 === c) return this.r = parseInt(r.charAt(0) + r.charAt(1), 16) / 255, this.g = parseInt(r.charAt(2) + r.charAt(3), 16) / 255, this.b = parseInt(r.charAt(4) + r.charAt(5), 16) / 255, this
        }
        return e && 0 < e.length ? this.setColorName(e) : this
    }, li.prototype.setColorName = function(t) { var e = ri[t]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this }, li.prototype.clone = function() { return new this.constructor(this.r, this.g, this.b) }, li.prototype.copy = function(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, li.prototype.copyGammaToLinear = function(t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, li.prototype.copyLinearToGamma = function(t, e) {
        void 0 === e && (e = 2);
        e = 0 < e ? 1 / e : 1;
        return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
    }, li.prototype.convertGammaToLinear = function(t) { return this.copyGammaToLinear(this, t), this }, li.prototype.convertLinearToGamma = function(t) { return this.copyLinearToGamma(this, t), this }, li.prototype.copySRGBToLinear = function(t) { return this.r = si(t.r), this.g = si(t.g), this.b = si(t.b), this }, li.prototype.copyLinearToSRGB = function(t) { return this.r = ci(t.r), this.g = ci(t.g), this.b = ci(t.b), this }, li.prototype.convertSRGBToLinear = function() { return this.copySRGBToLinear(this), this }, li.prototype.convertLinearToSRGB = function() { return this.copyLinearToSRGB(this), this }, li.prototype.getHex = function() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, li.prototype.getHexString = function() { return ("000000" + this.getHex().toString(16)).slice(-6) }, li.prototype.getHSL = function(t) {
        void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 });
        var e, n = this.r,
            r = this.g,
            i = this.b,
            o = Math.max(n, r, i),
            a = Math.min(n, r, i),
            s = (a + o) / 2;
        if (a === o) l = e = 0;
        else {
            var c = o - a,
                l = s <= .5 ? c / (o + a) : c / (2 - o - a);
            switch (o) {
                case n:
                    e = (r - i) / c + (r < i ? 6 : 0);
                    break;
                case r:
                    e = (i - n) / c + 2;
                    break;
                case i:
                    e = (n - r) / c + 4
            }
            e /= 6
        }
        return t.h = e, t.s = l, t.l = s, t
    }, li.prototype.getStyle = function() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, li.prototype.offsetHSL = function(t, e, n) { return this.getHSL(ii), ii.h += t, ii.s += e, ii.l += n, this.setHSL(ii.h, ii.s, ii.l), this }, li.prototype.add = function(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, li.prototype.addColors = function(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, li.prototype.addScalar = function(t) { return this.r += t, this.g += t, this.b += t, this }, li.prototype.sub = function(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, li.prototype.multiply = function(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, li.prototype.multiplyScalar = function(t) { return this.r *= t, this.g *= t, this.b *= t, this }, li.prototype.lerp = function(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, li.prototype.lerpHSL = function(t, e) {
        this.getHSL(ii), t.getHSL(oi);
        var n = An.lerp(ii.h, oi.h, e),
            t = An.lerp(ii.s, oi.s, e),
            e = An.lerp(ii.l, oi.l, e);
        return this.setHSL(n, t, e), this
    }, li.prototype.equals = function(t) { return t.r === this.r && t.g === this.g && t.b === this.b }, li.prototype.fromArray = function(t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, li.prototype.toArray = function(t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, li.prototype.fromBufferAttribute = function(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this }, li.prototype.toJSON = function() { return this.getHex() }, li.NAMES = ri, li.prototype.r = 1, li.prototype.g = 1, li.prototype.b = 1;
    var ui = function(t, e, n, r, i, o) { this.a = t, this.b = e, this.c = n, this.normal = r && r.isVector3 ? r : new kn, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new li, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0 };
    ui.prototype.clone = function() { return (new this.constructor).copy(this) }, ui.prototype.copy = function(t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone(); for (var r = 0, i = t.vertexColors.length; r < i; r++) this.vertexColors[r] = t.vertexColors[r].clone(); return this };
    var hi = 0;

    function pi() { Object.defineProperty(this, "id", { value: hi++ }), this.uuid = An.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = q, this.side = X, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = ct, this.blendDst = lt, this.blendEquation = $, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = yt, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = _n, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = yn, this.stencilZFail = yn, this.stencilZPass = yn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 }

    function di(t) { pi.call(this), this.type = "MeshBasicMaterial", this.color = new li(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = N, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t) }
    pi.prototype = Object.assign(Object.create(Mn.prototype), {
        constructor: pi,
        isMaterial: !0,
        onBeforeCompile: function() {},
        customProgramCacheKey: function() { return this.onBeforeCompile.toString() },
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n, r = t[e];
                    void 0 !== r ? "shading" !== e ? void 0 !== (n = this[e]) ? n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[e] = r : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : (console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === r) : console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            e && (t = { textures: {}, images: {} });
            var n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };

            function r(t) {
                var e, n = [];
                for (e in t) {
                    var r = t[e];
                    delete r.metadata, n.push(r)
                }
                return n
            }
            return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== q && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== X && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e && (e = r(t.textures), t = r(t.images), 0 < e.length && (n.textures = e), 0 < t.length && (n.images = t)), n
        },
        clone: function() { return (new this.constructor).copy(this) },
        copy: function(t) {
            this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
            var e = t.clippingPlanes,
                n = null;
            if (null !== e)
                for (var r = e.length, n = new Array(r), i = 0; i !== r; ++i) n[i] = e[i].clone();
            return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
        },
        dispose: function() { this.dispatchEvent({ type: "dispose" }) }
    }), Object.defineProperty(pi.prototype, "needsUpdate", { set: function(t) {!0 === t && this.version++ } }), ((di.prototype = Object.create(pi.prototype)).constructor = di).prototype.isMeshBasicMaterial = !0, di.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this };
    var fi = new kn,
        mi = new Ln;

    function gi(t, e, n) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = xn, this.updateRange = { offset: 0, count: -1 }, this.version = 0
    }

    function vi(t, e, n) { gi.call(this, new Int8Array(t), e, n) }

    function yi(t, e, n) { gi.call(this, new Uint8Array(t), e, n) }

    function _i(t, e, n) { gi.call(this, new Uint8ClampedArray(t), e, n) }

    function xi(t, e, n) { gi.call(this, new Int16Array(t), e, n) }

    function bi(t, e, n) { gi.call(this, new Uint16Array(t), e, n) }

    function wi(t, e, n) { gi.call(this, new Int32Array(t), e, n) }

    function Mi(t, e, n) { gi.call(this, new Uint32Array(t), e, n) }

    function Si(t, e, n) { gi.call(this, new Float32Array(t), e, n) }

    function Ei(t, e, n) { gi.call(this, new Float64Array(t), e, n) }
    Object.defineProperty(gi.prototype, "needsUpdate", { set: function(t) {!0 === t && this.version++ } }), Object.assign(gi.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(t) { return this.usage = t, this },
        copy: function(t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this },
        copyAt: function(t, e, n) { t *= this.itemSize, n *= e.itemSize; for (var r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r]; return this },
        copyArray: function(t) { return this.array.set(t), this },
        copyColorsArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new li), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new Ln), e[n++] = o.x, e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new kn), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new Nn), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
            }
            return this
        },
        applyMatrix3: function(t) {
            if (2 === this.itemSize)
                for (var e = 0, n = this.count; e < n; e++) mi.fromBufferAttribute(this, e), mi.applyMatrix3(t), this.setXY(e, mi.x, mi.y);
            else if (3 === this.itemSize)
                for (var r = 0, i = this.count; r < i; r++) fi.fromBufferAttribute(this, r), fi.applyMatrix3(t), this.setXYZ(r, fi.x, fi.y, fi.z);
            return this
        },
        applyMatrix4: function(t) { for (var e = 0, n = this.count; e < n; e++) fi.x = this.getX(e), fi.y = this.getY(e), fi.z = this.getZ(e), fi.applyMatrix4(t), this.setXYZ(e, fi.x, fi.y, fi.z); return this },
        applyNormalMatrix: function(t) { for (var e = 0, n = this.count; e < n; e++) fi.x = this.getX(e), fi.y = this.getY(e), fi.z = this.getZ(e), fi.applyNormalMatrix(t), this.setXYZ(e, fi.x, fi.y, fi.z); return this },
        transformDirection: function(t) { for (var e = 0, n = this.count; e < n; e++) fi.x = this.getX(e), fi.y = this.getY(e), fi.z = this.getZ(e), fi.transformDirection(t), this.setXYZ(e, fi.x, fi.y, fi.z); return this },
        set: function(t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this },
        getX: function(t) { return this.array[t * this.itemSize] },
        setX: function(t, e) { return this.array[t * this.itemSize] = e, this },
        getY: function(t) { return this.array[t * this.itemSize + 1] },
        setY: function(t, e) { return this.array[t * this.itemSize + 1] = e, this },
        getZ: function(t) { return this.array[t * this.itemSize + 2] },
        setZ: function(t, e) { return this.array[t * this.itemSize + 2] = e, this },
        getW: function(t) { return this.array[t * this.itemSize + 3] },
        setW: function(t, e) { return this.array[t * this.itemSize + 3] = e, this },
        setXY: function(t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this },
        setXYZ: function(t, e, n, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this },
        setXYZW: function(t, e, n, r, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this },
        onUpload: function(t) { return this.onUploadCallback = t, this },
        clone: function() { return new this.constructor(this.array, this.itemSize).copy(this) },
        toJSON: function() { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } }
    }), (vi.prototype = Object.create(gi.prototype)).constructor = vi, (yi.prototype = Object.create(gi.prototype)).constructor = yi, (_i.prototype = Object.create(gi.prototype)).constructor = _i, (xi.prototype = Object.create(gi.prototype)).constructor = xi, (bi.prototype = Object.create(gi.prototype)).constructor = bi, (wi.prototype = Object.create(gi.prototype)).constructor = wi, (Mi.prototype = Object.create(gi.prototype)).constructor = Mi, (Si.prototype = Object.create(gi.prototype)).constructor = Si, (Ei.prototype = Object.create(gi.prototype)).constructor = Ei;

    function Ti() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 }

    function Ai(t) { if (0 === t.length) return -1 / 0; for (var e = t[0], n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]); return e }
    Ti.prototype.computeGroups = function(t) {
        for (var e, n = [], r = void 0, i = t.faces, o = 0; o < i.length; o++) {
            var a = i[o];
            a.materialIndex !== r && (r = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), e = { start: 3 * o, materialIndex: r })
        }
        void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), this.groups = n
    }, Ti.prototype.fromGeometry = function(t) {
        var e, n = t.faces,
            r = t.vertices,
            i = t.faceVertexUvs,
            o = i[0] && 0 < i[0].length,
            a = i[1] && 0 < i[1].length,
            s = t.morphTargets,
            c = s.length;
        if (0 < c) {
            e = [];
            for (var l = 0; l < c; l++) e[l] = { name: s[l].name, data: [] };
            this.morphTargets.position = e
        }
        var u, h = t.morphNormals,
            p = h.length;
        if (0 < p) {
            u = [];
            for (var d = 0; d < p; d++) u[d] = { name: h[d].name, data: [] };
            this.morphTargets.normal = u
        }
        var f = t.skinIndices,
            m = t.skinWeights,
            g = f.length === r.length,
            v = m.length === r.length;
        0 < r.length && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        for (var y = 0; y < n.length; y++) {
            var _ = n[y];
            this.vertices.push(r[_.a], r[_.b], r[_.c]);
            var x = _.vertexNormals;
            3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (w = _.normal, this.normals.push(w, w, w));
            var b, w = _.vertexColors;
            3 === w.length ? this.colors.push(w[0], w[1], w[2]) : (w = _.color, this.colors.push(w, w, w)), !0 === o && (void 0 !== (b = i[0][y]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", y), this.uvs.push(new Ln, new Ln, new Ln))), !0 === a && (void 0 !== (b = i[1][y]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", y), this.uvs2.push(new Ln, new Ln, new Ln)));
            for (var M = 0; M < c; M++) {
                var S = s[M].vertices;
                e[M].data.push(S[_.a], S[_.b], S[_.c])
            }
            for (var E = 0; E < p; E++) {
                var T = h[E].vertexNormals[y];
                u[E].data.push(T.a, T.b, T.c)
            }
            g && this.skinIndices.push(f[_.a], f[_.b], f[_.c]), v && this.skinWeights.push(m[_.a], m[_.b], m[_.c])
        }
        return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
    };
    var Li = 1,
        Ri = new mr,
        Ci = new kr,
        Pi = new kn,
        Oi = new jn,
        Ii = new jn,
        Di = new kn;

    function Ni() { Object.defineProperty(this, "id", { value: Li += 2 }), this.uuid = An.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} }
    Ni.prototype = Object.assign(Object.create(Mn.prototype), {
        constructor: Ni,
        isBufferGeometry: !0,
        getIndex: function() { return this.index },
        setIndex: function(t) { Array.isArray(t) ? this.index = new(65535 < Ai(t) ? Mi : bi)(t, 1) : this.index = t },
        getAttribute: function(t) { return this.attributes[t] },
        setAttribute: function(t, e) { return this.attributes[t] = e, this },
        deleteAttribute: function(t) { return delete this.attributes[t], this },
        addGroup: function(t, e, n) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== n ? n : 0 }) },
        clearGroups: function() { this.groups = [] },
        setDrawRange: function(t, e) { this.drawRange.start = t, this.drawRange.count = e },
        applyMatrix4: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
            var n = this.attributes.normal;
            void 0 !== n && (e = (new Pn).getNormalMatrix(t), n.applyNormalMatrix(e), n.needsUpdate = !0);
            n = this.attributes.tangent;
            return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function(t) { return Ri.makeRotationX(t), this.applyMatrix4(Ri), this },
        rotateY: function(t) { return Ri.makeRotationY(t), this.applyMatrix4(Ri), this },
        rotateZ: function(t) { return Ri.makeRotationZ(t), this.applyMatrix4(Ri), this },
        translate: function(t, e, n) { return Ri.makeTranslation(t, e, n), this.applyMatrix4(Ri), this },
        scale: function(t, e, n) { return Ri.makeScale(t, e, n), this.applyMatrix4(Ri), this },
        lookAt: function(t) { return Ci.lookAt(t), Ci.updateMatrix(), this.applyMatrix4(Ci.matrix), this },
        center: function() { return this.computeBoundingBox(), this.boundingBox.getCenter(Pi).negate(), this.translate(Pi.x, Pi.y, Pi.z), this },
        setFromObject: function(t) { var e, n, r = t.geometry; return t.isPoints || t.isLine ? (e = new Si(3 * r.vertices.length, 3), n = new Si(3 * r.colors.length, 3), this.setAttribute("position", e.copyVector3sArray(r.vertices)), this.setAttribute("color", n.copyColorsArray(r.colors)), r.lineDistances && r.lineDistances.length === r.vertices.length && (n = new Si(r.lineDistances.length, 1), this.setAttribute("lineDistance", n.copyArray(r.lineDistances))), null !== r.boundingSphere && (this.boundingSphere = r.boundingSphere.clone()), null !== r.boundingBox && (this.boundingBox = r.boundingBox.clone())) : t.isMesh && r && r.isGeometry && this.fromGeometry(r), this },
        setFromPoints: function(t) {
            for (var e = [], n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new Si(e, 3)), this
        },
        updateFromObject: function(t) {
            var e, n, r = t.geometry;
            if (t.isMesh) {
                var i = r.__directGeometry;
                if (!0 === r.elementsNeedUpdate && (i = void 0, r.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(r);
                i.verticesNeedUpdate = r.verticesNeedUpdate, i.normalsNeedUpdate = r.normalsNeedUpdate, i.colorsNeedUpdate = r.colorsNeedUpdate, i.uvsNeedUpdate = r.uvsNeedUpdate, i.groupsNeedUpdate = r.groupsNeedUpdate, r.verticesNeedUpdate = !1, r.normalsNeedUpdate = !1, r.colorsNeedUpdate = !1, r.uvsNeedUpdate = !1, r.groupsNeedUpdate = !1, r = i
            }
            return !0 === r.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(r.vertices), i.needsUpdate = !0), r.verticesNeedUpdate = !1), !0 === r.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(r.normals), e.needsUpdate = !0), r.normalsNeedUpdate = !1), !0 === r.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(r.colors), e.needsUpdate = !0), r.colorsNeedUpdate = !1), r.uvsNeedUpdate && (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(r.uvs), n.needsUpdate = !0), r.uvsNeedUpdate = !1), r.lineDistancesNeedUpdate && (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(r.lineDistances), n.needsUpdate = !0), r.lineDistancesNeedUpdate = !1), r.groupsNeedUpdate && (r.computeGroups(t.geometry), this.groups = r.groups, r.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(t) { return t.__directGeometry = (new Ti).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) },
        fromDirectGeometry: function(t) {
            var e, n, r, i, o = new Float32Array(3 * t.vertices.length);
            for (r in this.setAttribute("position", new gi(o, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.setAttribute("normal", new gi(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.setAttribute("color", new gi(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (n = new Float32Array(2 * t.uvs.length), this.setAttribute("uv", new gi(n, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (n = new Float32Array(2 * t.uvs2.length), this.setAttribute("uv2", new gi(n, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups, t.morphTargets) {
                for (var a = [], s = t.morphTargets[r], c = 0, l = s.length; c < l; c++) {
                    var u = s[c],
                        h = new Si(3 * u.data.length, 3);
                    h.name = u.name, a.push(h.copyVector3sArray(u.data))
                }
                this.morphAttributes[r] = a
            }
            return 0 < t.skinIndices.length && (i = new Si(4 * t.skinIndices.length, 4), this.setAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new Si(4 * t.skinWeights.length, 4), this.setAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new jn);
            var t = this.attributes.position,
                e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new kn(-1 / 0, -1 / 0, -1 / 0), new kn(1 / 0, 1 / 0, 1 / 0));
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t), e)
                    for (var n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        Oi.setFromBufferAttribute(i), this.morphTargetsRelative ? (Di.addVectors(this.boundingBox.min, Oi.min), this.boundingBox.expandByPoint(Di), Di.addVectors(this.boundingBox.max, Oi.max), this.boundingBox.expandByPoint(Di)) : (this.boundingBox.expandByPoint(Oi.min), this.boundingBox.expandByPoint(Oi.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new ar);
            var t = this.attributes.position,
                e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new kn, 1 / 0);
            if (t) {
                var n = this.boundingSphere.center;
                if (Oi.setFromBufferAttribute(t), e)
                    for (var r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        Ii.setFromBufferAttribute(o), this.morphTargetsRelative ? (Di.addVectors(Oi.min, Ii.min), Oi.expandByPoint(Di), Di.addVectors(Oi.max, Ii.max), Oi.expandByPoint(Di)) : (Oi.expandByPoint(Ii.min), Oi.expandByPoint(Ii.max))
                    }
                Oi.getCenter(n);
                for (var a = 0, s = 0, c = t.count; s < c; s++) Di.fromBufferAttribute(t, s), a = Math.max(a, n.distanceToSquared(Di));
                if (e)
                    for (var l = 0, u = e.length; l < u; l++)
                        for (var h = e[l], p = this.morphTargetsRelative, d = 0, f = h.count; d < f; d++) Di.fromBufferAttribute(h, d), p && (Pi.fromBufferAttribute(t, d), Di.add(Pi)), a = Math.max(a, n.distanceToSquared(Di));
                this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index,
                e = this.getAttribute("position");
            if (void 0 !== e) {
                var n = this.getAttribute("normal");
                if (void 0 === n) n = new gi(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                else
                    for (var r = 0, i = n.count; r < i; r++) n.setXYZ(r, 0, 0, 0);
                var o = new kn,
                    a = new kn,
                    s = new kn,
                    c = new kn,
                    l = new kn,
                    u = new kn,
                    h = new kn,
                    p = new kn;
                if (t)
                    for (var d = 0, f = t.count; d < f; d += 3) {
                        var m = t.getX(d + 0),
                            g = t.getX(d + 1),
                            v = t.getX(d + 2);
                        o.fromBufferAttribute(e, m), a.fromBufferAttribute(e, g), s.fromBufferAttribute(e, v), h.subVectors(s, a), p.subVectors(o, a), h.cross(p), c.fromBufferAttribute(n, m), l.fromBufferAttribute(n, g), u.fromBufferAttribute(n, v), c.add(h), l.add(h), u.add(h), n.setXYZ(m, c.x, c.y, c.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z)
                    } else
                        for (var y = 0, _ = e.count; y < _; y += 3) o.fromBufferAttribute(e, y + 0), a.fromBufferAttribute(e, y + 1), s.fromBufferAttribute(e, y + 2), h.subVectors(s, a), p.subVectors(o, a), h.cross(p), n.setXYZ(y + 0, h.x, h.y, h.z), n.setXYZ(y + 1, h.x, h.y, h.z), n.setXYZ(y + 2, h.x, h.y, h.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n, r = this.attributes;
                for (n in r)
                    if (void 0 !== t.attributes[n])
                        for (var i = r[n].array, o = t.attributes[n], a = o.array, o = o.itemSize * e, s = Math.min(a.length, i.length - o), c = 0, l = o; c < s; c++, l++) i[l] = a[c];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: function() { for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++) Di.fromBufferAttribute(t, e), Di.normalize(), t.setXYZ(e, Di.x, Di.y, Di.z) },
        toNonIndexed: function() {
            function t(t, e) { for (var n = t.array, r = t.itemSize, t = t.normalized, i = new n.constructor(e.length * r), o = 0, a = 0, s = 0, c = e.length; s < c; s++) { o = e[s] * r; for (var l = 0; l < r; l++) i[a++] = n[o++] } return new gi(i, r, t) }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var e, n = new Ni,
                r = this.index.array,
                i = this.attributes;
            for (e in i) {
                var o = t(i[e], r);
                n.setAttribute(e, o)
            }
            var a, s = this.morphAttributes;
            for (a in s) {
                for (var c = [], l = s[a], u = 0, h = l.length; u < h; u++) {
                    var p = t(l[u], r);
                    c.push(p)
                }
                n.morphAttributes[a] = c
            }
            n.morphTargetsRelative = this.morphTargetsRelative;
            for (var d = this.groups, f = 0, m = d.length; f < m; f++) {
                var g = d[f];
                n.addGroup(g.start, g.count, g.materialIndex)
            }
            return n
        },
        toJSON: function() {
            var t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) { var e, n = this.parameters; for (e in n) void 0 !== n[e] && (t[e] = n[e]); return t }
            t.data = { attributes: {} };
            var r = this.index;
            null !== r && (t.data.index = { type: r.array.constructor.name, array: Array.prototype.slice.call(r.array) });
            var i, o = this.attributes;
            for (i in o) {
                var a = o[i],
                    s = a.toJSON(t.data);
                "" !== a.name && (s.name = a.name), t.data.attributes[i] = s
            }
            var c, l = {},
                u = !1;
            for (c in this.morphAttributes) {
                for (var h = this.morphAttributes[c], p = [], d = 0, f = h.length; d < f; d++) {
                    var m = h[d],
                        g = m.toJSON(t.data);
                    "" !== m.name && (g.name = m.name), p.push(g)
                }
                0 < p.length && (l[c] = p, u = !0)
            }
            u && (t.data.morphAttributes = l, t.data.morphTargetsRelative = this.morphTargetsRelative);
            r = this.groups;
            0 < r.length && (t.data.groups = JSON.parse(JSON.stringify(r)));
            r = this.boundingSphere;
            return null !== r && (t.data.boundingSphere = { center: r.center.toArray(), radius: r.radius }), t
        },
        clone: function() { return (new Ni).copy(this) },
        copy: function(t) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            var e = {};
            this.name = t.name;
            var n = t.index;
            null !== n && this.setIndex(n.clone(e));
            var r, i = t.attributes;
            for (r in i) {
                var o = i[r];
                this.setAttribute(r, o.clone(e))
            }
            var a, s = t.morphAttributes;
            for (a in s) {
                for (var c = [], l = s[a], u = 0, h = l.length; u < h; u++) c.push(l[u].clone(e));
                this.morphAttributes[a] = c
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            for (var p = t.groups, d = 0, f = p.length; d < f; d++) {
                var m = p[d];
                this.addGroup(m.start, m.count, m.materialIndex)
            }
            n = t.boundingBox;
            null !== n && (this.boundingBox = n.clone());
            n = t.boundingSphere;
            return null !== n && (this.boundingSphere = n.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
        },
        dispose: function() { this.dispatchEvent({ type: "dispose" }) }
    });
    var Bi = new mr,
        Fi = new fr,
        Ui = new ar,
        zi = new kn,
        Hi = new kn,
        ki = new kn,
        Gi = new kn,
        Vi = new kn,
        ji = new kn,
        Wi = new kn,
        qi = new kn,
        Xi = new kn,
        Yi = new Ln,
        Zi = new Ln,
        Ji = new Ln,
        Ki = new kn,
        Qi = new kn;

    function $i(t, e) { kr.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Ni, this.material = void 0 !== e ? e : new di, this.updateMorphTargets() }

    function to(t, e, n, r, i, o, a, s) {
        e = e.side === j ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, e.side !== Y, s);
        if (null === e) return null;
        Qi.copy(s), Qi.applyMatrix4(t.matrixWorld);
        s = n.ray.origin.distanceTo(Qi);
        return s < n.near || s > n.far ? null : { distance: s, point: Qi.clone(), object: t }
    }

    function eo(t, e, n, r, i, o, a, s, c, l, u, h) {
        zi.fromBufferAttribute(i, l), Hi.fromBufferAttribute(i, u), ki.fromBufferAttribute(i, h);
        var p = t.morphTargetInfluences;
        if (e.morphTargets && o && p) {
            Wi.set(0, 0, 0), qi.set(0, 0, 0), Xi.set(0, 0, 0);
            for (var d = 0, f = o.length; d < f; d++) {
                var m = p[d],
                    g = o[d];
                0 !== m && (Gi.fromBufferAttribute(g, l), Vi.fromBufferAttribute(g, u), ji.fromBufferAttribute(g, h), a ? (Wi.addScaledVector(Gi, m), qi.addScaledVector(Vi, m), Xi.addScaledVector(ji, m)) : (Wi.addScaledVector(Gi.sub(zi), m), qi.addScaledVector(Vi.sub(Hi), m), Xi.addScaledVector(ji.sub(ki), m)))
            }
            zi.add(Wi), Hi.add(qi), ki.add(Xi)
        }
        t.isSkinnedMesh && (t.boneTransform(l, zi), t.boneTransform(u, Hi), t.boneTransform(h, ki));
        r = to(t, e, n, r, zi, Hi, ki, Ki);
        return r && (s && (Yi.fromBufferAttribute(s, l), Zi.fromBufferAttribute(s, u), Ji.fromBufferAttribute(s, h), r.uv = ni.getUV(Ki, zi, Hi, ki, Yi, Zi, Ji, new Ln)), c && (Yi.fromBufferAttribute(c, l), Zi.fromBufferAttribute(c, u), Ji.fromBufferAttribute(c, h), r.uv2 = ni.getUV(Ki, zi, Hi, ki, Yi, Zi, Ji, new Ln)), c = new ui(l, u, h), ni.getNormal(zi, Hi, ki, c.normal), r.face = c), r
    }
    $i.prototype = Object.assign(Object.create(kr.prototype), {
        constructor: $i,
        isMesh: !0,
        copy: function(t) { return kr.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this },
        updateMorphTargets: function() {
            var t = this.geometry;
            if (t.isBufferGeometry) {
                var e = t.morphAttributes,
                    n = Object.keys(e);
                if (0 < n.length) {
                    var r = e[n[0]];
                    if (void 0 !== r) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (var i = 0, o = r.length; i < o; i++) {
                            var a = r[i].name || String(i);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = i
                        }
                    }
                }
            } else {
                t = t.morphTargets;
                void 0 !== t && 0 < t.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function(t, e) {
            var n = this.geometry,
                r = this.material,
                i = this.matrixWorld;
            if (void 0 !== r && (null === n.boundingSphere && n.computeBoundingSphere(), Ui.copy(n.boundingSphere), Ui.applyMatrix4(i), !1 !== t.ray.intersectsSphere(Ui) && (Bi.getInverse(i), Fi.copy(t.ray).applyMatrix4(Bi), null === n.boundingBox || !1 !== Fi.intersectsBox(n.boundingBox))))
                if (n.isBufferGeometry) {
                    var o = n.index,
                        a = n.attributes.position,
                        s = n.morphAttributes.position,
                        c = n.morphTargetsRelative,
                        l = n.attributes.uv,
                        u = n.attributes.uv2,
                        h = n.groups,
                        p = n.drawRange;
                    if (null !== o)
                        if (Array.isArray(r))
                            for (var d = 0, f = h.length; d < f; d++)
                                for (var m = h[d], g = r[m.materialIndex], v = Math.max(m.start, p.start), y = Math.min(m.start + m.count, p.start + p.count); v < y; v += 3) {
                                    var _, x = o.getX(v),
                                        b = o.getX(v + 1),
                                        w = o.getX(v + 2);
                                    (_ = eo(this, g, t, Fi, a, s, c, l, u, x, b, w)) && (_.faceIndex = Math.floor(v / 3), _.face.materialIndex = m.materialIndex, e.push(_))
                                } else
                                    for (var M = Math.max(0, p.start), S = Math.min(o.count, p.start + p.count); M < S; M += 3) {
                                        var E = o.getX(M),
                                            T = o.getX(M + 1),
                                            A = o.getX(M + 2);
                                        (_ = eo(this, r, t, Fi, a, s, c, l, u, E, T, A)) && (_.faceIndex = Math.floor(M / 3), e.push(_))
                                    } else if (void 0 !== a)
                                        if (Array.isArray(r))
                                            for (var L = 0, R = h.length; L < R; L++)
                                                for (var C = h[L], P = r[C.materialIndex], O = Math.max(C.start, p.start), I = Math.min(C.start + C.count, p.start + p.count); O < I; O += 3)(_ = eo(this, P, t, Fi, a, s, c, l, u, O, O + 1, O + 2)) && (_.faceIndex = Math.floor(O / 3), _.face.materialIndex = C.materialIndex, e.push(_));
                                        else
                                            for (var D = Math.max(0, p.start), N = Math.min(a.count, p.start + p.count); D < N; D += 3)(_ = eo(this, r, t, Fi, a, s, c, l, u, D, D + 1, D + 2)) && (_.faceIndex = Math.floor(D / 3), e.push(_))
                } else if (n.isGeometry) {
                var B, F = Array.isArray(r),
                    U = n.vertices,
                    z = n.faces,
                    n = n.faceVertexUvs[0];
                0 < n.length && (B = n);
                for (var H = 0, k = z.length; H < k; H++) {
                    var G, V, j, W = z[H],
                        q = F ? r[W.materialIndex] : r;
                    void 0 !== q && (G = U[W.a], V = U[W.b], j = U[W.c], (_ = to(this, q, t, Fi, G, V, j, Ki)) && (B && B[H] && (q = B[H], Yi.copy(q[0]), Zi.copy(q[1]), Ji.copy(q[2]), _.uv = ni.getUV(Ki, G, V, j, Yi, Zi, Ji, new Ln)), _.face = W, _.faceIndex = H, e.push(_)))
                }
            }
        }
    });
    var no = 0,
        ro = new mr,
        io = new kr,
        oo = new kn;

    function ao() {
        Object.defineProperty(this, "id", { value: no += 2 }), this.uuid = An.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }
    ao.prototype = Object.assign(Object.create(Mn.prototype), {
        constructor: ao,
        isGeometry: !0,
        applyMatrix4: function(t) {
            for (var e = (new Pn).getNormalMatrix(t), n = 0, r = this.vertices.length; n < r; n++) this.vertices[n].applyMatrix4(t);
            for (var i = 0, o = this.faces.length; i < o; i++) {
                var a = this.faces[i];
                a.normal.applyMatrix3(e).normalize();
                for (var s = 0, c = a.vertexNormals.length; s < c; s++) a.vertexNormals[s].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function(t) { return ro.makeRotationX(t), this.applyMatrix4(ro), this },
        rotateY: function(t) { return ro.makeRotationY(t), this.applyMatrix4(ro), this },
        rotateZ: function(t) { return ro.makeRotationZ(t), this.applyMatrix4(ro), this },
        translate: function(t, e, n) { return ro.makeTranslation(t, e, n), this.applyMatrix4(ro), this },
        scale: function(t, e, n) { return ro.makeScale(t, e, n), this.applyMatrix4(ro), this },
        lookAt: function(t) { return io.lookAt(t), io.updateMatrix(), this.applyMatrix4(io.matrix), this },
        fromBufferGeometry: function(t) {
            var a = this,
                e = null !== t.index ? t.index : void 0,
                n = t.attributes;
            if (void 0 === n.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
            var r = n.position,
                s = n.normal,
                c = n.color,
                l = n.uv,
                u = n.uv2;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var i = 0; i < r.count; i++) a.vertices.push((new kn).fromBufferAttribute(r, i)), void 0 !== c && a.colors.push((new li).fromBufferAttribute(c, i));

            function o(t, e, n, r) {
                var i = void 0 === c ? [] : [a.colors[t].clone(), a.colors[e].clone(), a.colors[n].clone()],
                    o = void 0 === s ? [] : [(new kn).fromBufferAttribute(s, t), (new kn).fromBufferAttribute(s, e), (new kn).fromBufferAttribute(s, n)],
                    r = new ui(t, e, n, o, i, r);
                a.faces.push(r), void 0 !== l && a.faceVertexUvs[0].push([(new Ln).fromBufferAttribute(l, t), (new Ln).fromBufferAttribute(l, e), (new Ln).fromBufferAttribute(l, n)]), void 0 !== u && a.faceVertexUvs[1].push([(new Ln).fromBufferAttribute(u, t), (new Ln).fromBufferAttribute(u, e), (new Ln).fromBufferAttribute(u, n)])
            }
            var h = t.groups;
            if (0 < h.length)
                for (var p = 0; p < h.length; p++)
                    for (var d = h[p], f = d.start, m = f, g = f + d.count; m < g; m += 3) void 0 !== e ? o(e.getX(m), e.getX(m + 1), e.getX(m + 2), d.materialIndex) : o(m, m + 1, m + 2, d.materialIndex);
            else if (void 0 !== e)
                for (var v = 0; v < e.count; v += 3) o(e.getX(v), e.getX(v + 1), e.getX(v + 2));
            else
                for (var y = 0; y < r.count; y += 3) o(y, y + 1, y + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: function() { return this.computeBoundingBox(), this.boundingBox.getCenter(oo).negate(), this.translate(oo.x, oo.y, oo.z), this },
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                n = 0 === e ? 1 : 1 / e,
                e = new mr;
            return e.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(e), this
        },
        computeFaceNormals: function() {
            for (var t = new kn, e = new kn, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n],
                    o = this.vertices[i.a],
                    a = this.vertices[i.b],
                    s = this.vertices[i.c];
                t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), i.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            void 0 === t && (t = !0);
            for (var e = new Array(this.vertices.length), n = 0, r = this.vertices.length; n < r; n++) e[n] = new kn;
            if (t)
                for (var i = new kn, o = new kn, a = 0, s = this.faces.length; a < s; a++) {
                    var c = this.faces[a],
                        l = this.vertices[c.a],
                        u = this.vertices[c.b],
                        h = this.vertices[c.c];
                    i.subVectors(h, u), o.subVectors(l, u), i.cross(o), e[c.a].add(i), e[c.b].add(i), e[c.c].add(i)
                } else {
                    this.computeFaceNormals();
                    for (var p = 0, d = this.faces.length; p < d; p++) {
                        var f = this.faces[p];
                        e[f.a].add(f.normal), e[f.b].add(f.normal), e[f.c].add(f.normal)
                    }
                }
            for (var m = 0, g = this.vertices.length; m < g; m++) e[m].normalize();
            for (var v = 0, y = this.faces.length; v < y; v++) {
                var _ = this.faces[v],
                    x = _.vertexNormals;
                3 === x.length ? (x[0].copy(e[_.a]), x[1].copy(e[_.b]), x[2].copy(e[_.c])) : (x[0] = e[_.a].clone(), x[1] = e[_.b].clone(), x[2] = e[_.c].clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            this.computeFaceNormals();
            for (var t = 0, e = this.faces.length; t < e; t++) {
                var n = this.faces[t],
                    r = n.vertexNormals;
                3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            for (var t = 0, e = this.faces.length; t < e; t++) {
                var n = this.faces[t];
                n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
                for (var r = 0, i = n.vertexNormals.length; r < i; r++) n.__originalVertexNormals[r] ? n.__originalVertexNormals[r].copy(n.vertexNormals[r]) : n.__originalVertexNormals[r] = n.vertexNormals[r].clone()
            }
            var o = new ao;
            o.faces = this.faces;
            for (var a = 0, s = this.morphTargets.length; a < s; a++) {
                if (!this.morphNormals[a]) {
                    this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [];
                    for (var c = this.morphNormals[a].faceNormals, l = this.morphNormals[a].vertexNormals, u = 0, h = this.faces.length; u < h; u++) {
                        var p = new kn,
                            d = { a: new kn, b: new kn, c: new kn };
                        c.push(p), l.push(d)
                    }
                }
                var f = this.morphNormals[a];
                o.vertices = this.morphTargets[a].vertices, o.computeFaceNormals(), o.computeVertexNormals();
                for (var m = 0, g = this.faces.length; m < g; m++) {
                    var v = this.faces[m],
                        y = f.faceNormals[m],
                        _ = f.vertexNormals[m];
                    y.copy(v.normal), _.a.copy(v.vertexNormals[0]), _.b.copy(v.vertexNormals[1]), _.c.copy(v.vertexNormals[2])
                }
            }
            for (var x = 0, b = this.faces.length; x < b; x++) {
                var w = this.faces[x];
                w.normal = w.__originalFaceNormal, w.vertexNormals = w.__originalVertexNormals
            }
        },
        computeBoundingBox: function() { null === this.boundingBox && (this.boundingBox = new jn), this.boundingBox.setFromPoints(this.vertices) },
        computeBoundingSphere: function() { null === this.boundingSphere && (this.boundingSphere = new ar), this.boundingSphere.setFromPoints(this.vertices) },
        merge: function(t, e, n) {
            if (t && t.isGeometry) {
                var r, i = this.vertices.length,
                    o = this.vertices,
                    a = t.vertices,
                    s = this.faces,
                    c = t.faces,
                    l = this.colors,
                    u = t.colors;
                void 0 === n && (n = 0), void 0 !== e && (r = (new Pn).getNormalMatrix(e));
                for (var h = 0, p = a.length; h < p; h++) {
                    var d = a[h].clone();
                    void 0 !== e && d.applyMatrix4(e), o.push(d)
                }
                for (var f = 0, m = u.length; f < m; f++) l.push(u[f].clone());
                for (var g = 0, v = c.length; g < v; g++) {
                    var y = c[g],
                        _ = void 0,
                        x = void 0,
                        b = y.vertexNormals,
                        w = y.vertexColors,
                        M = new ui(y.a + i, y.b + i, y.c + i);
                    M.normal.copy(y.normal), void 0 !== r && M.normal.applyMatrix3(r).normalize();
                    for (var S = 0, E = b.length; S < E; S++) _ = b[S].clone(), void 0 !== r && _.applyMatrix3(r).normalize(), M.vertexNormals.push(_);
                    M.color.copy(y.color);
                    for (var T = 0, A = w.length; T < A; T++) x = w[T], M.vertexColors.push(x.clone());
                    M.materialIndex = y.materialIndex + n, s.push(M)
                }
                for (var L = 0, R = t.faceVertexUvs.length; L < R; L++) {
                    var C = t.faceVertexUvs[L];
                    void 0 === this.faceVertexUvs[L] && (this.faceVertexUvs[L] = []);
                    for (var P = 0, O = C.length; P < O; P++) {
                        for (var I = C[P], D = [], N = 0, B = I.length; N < B; N++) D.push(I[N].clone());
                        this.faceVertexUvs[L].push(D)
                    }
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        },
        mergeMesh: function(t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) },
        mergeVertices: function() {
            for (var t = {}, e = [], n = [], r = Math.pow(10, 4), i = 0, o = this.vertices.length; i < o; i++) {
                var a = this.vertices[i],
                    a = Math.round(a.x * r) + "_" + Math.round(a.y * r) + "_" + Math.round(a.z * r);
                void 0 === t[a] ? (t[a] = i, e.push(this.vertices[i]), n[i] = e.length - 1) : n[i] = n[t[a]]
            }
            for (var s = [], c = 0, l = this.faces.length; c < l; c++) {
                var u = this.faces[c];
                u.a = n[u.a], u.b = n[u.b], u.c = n[u.c];
                for (var h = [u.a, u.b, u.c], p = 0; p < 3; p++)
                    if (h[p] === h[(p + 1) % 3]) { s.push(c); break }
            }
            for (var d = s.length - 1; 0 <= d; d--) {
                var f = s[d];
                this.faces.splice(f, 1);
                for (var m = 0, g = this.faceVertexUvs.length; m < g; m++) this.faceVertexUvs[m].splice(f, 1)
            }
            var v = this.vertices.length - e.length;
            return this.vertices = e, v
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (var e = 0, n = t.length; e < n; e++) {
                var r = t[e];
                this.vertices.push(new kn(r.x, r.y, r.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
            t.sort(function(t, e) { return t.materialIndex - e.materialIndex });
            var r, i, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            o && o.length === e && (r = []), a && a.length === e && (i = []);
            for (var s = 0; s < e; s++) {
                var c = t[s]._id;
                r && r.push(o[c]), i && i.push(a[c])
            }
            r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function() {
            var t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { var e, n = this.parameters; for (e in n) void 0 !== n[e] && (t[e] = n[e]); return t }
            for (var r = [], i = 0; i < this.vertices.length; i++) {
                var o = this.vertices[i];
                r.push(o.x, o.y, o.z)
            }
            for (var a = [], s = [], c = {}, l = [], u = {}, h = [], p = {}, d = 0; d < this.faces.length; d++) {
                var f, m = this.faces[d],
                    g = void 0 !== this.faceVertexUvs[0][d],
                    v = 0 < m.normal.length(),
                    y = 0 < m.vertexNormals.length,
                    _ = 1 !== m.color.r || 1 !== m.color.g || 1 !== m.color.b,
                    x = 0 < m.vertexColors.length;
                f = b(2, 3, g), f = b(f, 4, v), f = b(f, 5, y), f = b(f, 6, _), f = b(f, 7, x), a.push(f), a.push(m.a, m.b, m.c), a.push(m.materialIndex), g && (g = this.faceVertexUvs[0][d], a.push(S(g[0]), S(g[1]), S(g[2]))), v && a.push(w(m.normal)), y && (y = m.vertexNormals, a.push(w(y[0]), w(y[1]), w(y[2]))), _ && a.push(M(m.color)), x && (m = m.vertexColors, a.push(M(m[0]), M(m[1]), M(m[2])))
            }

            function b(t, e, n) { return n ? t | 1 << e : t & ~(1 << e) }

            function w(t) { var e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== c[e] || (c[e] = s.length / 3, s.push(t.x, t.y, t.z)), c[e] }

            function M(t) { var e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== u[e] || (u[e] = l.length, l.push(t.getHex())), u[e] }

            function S(t) { var e = t.x.toString() + t.y.toString(); return void 0 !== p[e] || (p[e] = h.length / 2, h.push(t.x, t.y)), p[e] }
            return t.data = {}, t.data.vertices = r, t.data.normals = s, 0 < l.length && (t.data.colors = l), 0 < h.length && (t.data.uvs = [h]), t.data.faces = a, t
        },
        clone: function() { return (new ao).copy(this) },
        copy: function(t) {
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            for (var e = t.vertices, n = 0, r = e.length; n < r; n++) this.vertices.push(e[n].clone());
            for (var i = t.colors, o = 0, a = i.length; o < a; o++) this.colors.push(i[o].clone());
            for (var s = t.faces, c = 0, l = s.length; c < l; c++) this.faces.push(s[c].clone());
            for (var u = 0, h = t.faceVertexUvs.length; u < h; u++) {
                var p = t.faceVertexUvs[u];
                void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                for (var d = 0, f = p.length; d < f; d++) {
                    for (var m = p[d], g = [], v = 0, y = m.length; v < y; v++) {
                        var _ = m[v];
                        g.push(_.clone())
                    }
                    this.faceVertexUvs[u].push(g)
                }
            }
            for (var x = t.morphTargets, b = 0, w = x.length; b < w; b++) {
                var M = {};
                if (M.name = x[b].name, void 0 !== x[b].vertices) { M.vertices = []; for (var S = 0, E = x[b].vertices.length; S < E; S++) M.vertices.push(x[b].vertices[S].clone()) }
                if (void 0 !== x[b].normals) { M.normals = []; for (var T = 0, A = x[b].normals.length; T < A; T++) M.normals.push(x[b].normals[T].clone()) }
                this.morphTargets.push(M)
            }
            for (var L = t.morphNormals, R = 0, C = L.length; R < C; R++) {
                var P = {};
                if (void 0 !== L[R].vertexNormals) {
                    P.vertexNormals = [];
                    for (var O = 0, I = L[R].vertexNormals.length; O < I; O++) {
                        var D = L[R].vertexNormals[O],
                            N = {};
                        N.a = D.a.clone(), N.b = D.b.clone(), N.c = D.c.clone(), P.vertexNormals.push(N)
                    }
                }
                if (void 0 !== L[R].faceNormals) { P.faceNormals = []; for (var B = 0, F = L[R].faceNormals.length; B < F; B++) P.faceNormals.push(L[R].faceNormals[B].clone()) }
                this.morphNormals.push(P)
            }
            for (var U = t.skinWeights, z = 0, H = U.length; z < H; z++) this.skinWeights.push(U[z].clone());
            for (var k = t.skinIndices, G = 0, V = k.length; G < V; G++) this.skinIndices.push(k[G].clone());
            for (var j = t.lineDistances, W = 0, q = j.length; W < q; W++) this.lineDistances.push(j[W]);
            var X = t.boundingBox;
            null !== X && (this.boundingBox = X.clone());
            X = t.boundingSphere;
            return null !== X && (this.boundingSphere = X.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function() { this.dispatchEvent({ type: "dispose" }) }
    });
    var so = function(a) {
            function t(t, e, n, r, i, o) { a.call(this), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: r, heightSegments: i, depthSegments: o }, this.fromBufferGeometry(new co(t, e, n, r, i, o)), this.mergeVertices() }
            return a && (t.__proto__ = a), (t.prototype = Object.create(a && a.prototype)).constructor = t
        }(ao),
        co = function(s) {
            function t(t, e, n, r, i, o) {
                void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === i && (i = 1), void 0 === o && (o = 1), s.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: r, heightSegments: i, depthSegments: o };
                var P = this;
                r = Math.floor(r), i = Math.floor(i), o = Math.floor(o);
                var O = [],
                    I = [],
                    D = [],
                    N = [],
                    B = 0,
                    F = 0;

                function a(t, e, n, r, i, o, a, s, c, l, u) {
                    for (var h = o / c, p = a / l, d = o / 2, f = a / 2, m = s / 2, g = c + 1, v = l + 1, y = 0, _ = 0, x = new kn, b = 0; b < v; b++)
                        for (var w = b * p - f, M = 0; M < g; M++) {
                            var S = M * h - d;
                            x[t] = S * r, x[e] = w * i, x[n] = m, I.push(x.x, x.y, x.z), x[t] = 0, x[e] = 0, x[n] = 0 < s ? 1 : -1, D.push(x.x, x.y, x.z), N.push(M / c), N.push(1 - b / l), y += 1
                        }
                    for (var E = 0; E < l; E++)
                        for (var T = 0; T < c; T++) {
                            var A = B + T + g * E,
                                L = B + T + g * (E + 1),
                                R = B + (T + 1) + g * (E + 1),
                                C = B + (T + 1) + g * E;
                            O.push(A, L, C), O.push(L, R, C), _ += 6
                        }
                    P.addGroup(F, _, u), F += _, B += y
                }
                a("z", "y", "x", -1, -1, n, e, t, o, i, 0), a("z", "y", "x", 1, -1, n, e, -t, o, i, 1), a("x", "z", "y", 1, 1, t, n, e, r, o, 2), a("x", "z", "y", 1, -1, t, n, -e, r, o, 3), a("x", "y", "z", 1, -1, t, e, n, r, i, 4), a("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(O), this.setAttribute("position", new Si(I, 3)), this.setAttribute("normal", new Si(D, 3)), this.setAttribute("uv", new Si(N, 2))
            }
            return s && (t.__proto__ = s), (t.prototype = Object.create(s && s.prototype)).constructor = t
        }(Ni);

    function lo(t) {
        var e, n = {};
        for (e in t)
            for (var r in n[e] = {}, t[e]) {
                var i = t[e][r];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? n[e][r] = i.clone() : Array.isArray(i) ? n[e][r] = i.slice() : n[e][r] = i
            }
        return n
    }

    function uo(t) { for (var e = {}, n = 0; n < t.length; n++) { var r, i = lo(t[n]); for (r in i) e[r] = i[r] } return e }
    var ho = { clone: lo, merge: uo },
        po = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fo = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

    function mo(t) { pi.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = po, this.fragmentShader = fo, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) }

    function go() { kr.call(this), this.type = "Camera", this.matrixWorldInverse = new mr, this.projectionMatrix = new mr, this.projectionMatrixInverse = new mr }

    function vo(t, e, n, r) { go.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() }((mo.prototype = Object.create(pi.prototype)).constructor = mo).prototype.isShaderMaterial = !0, mo.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = lo(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this }, mo.prototype.toJSON = function(t) {
        var e, n = pi.prototype.toJSON.call(this, t);
        for (e in n.glslVersion = this.glslVersion, n.uniforms = {}, this.uniforms) {
            var r = this.uniforms[e].value;
            r && r.isTexture ? n.uniforms[e] = { type: "t", value: r.toJSON(t).uuid } : r && r.isColor ? n.uniforms[e] = { type: "c", value: r.getHex() } : r && r.isVector2 ? n.uniforms[e] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? n.uniforms[e] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? n.uniforms[e] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? n.uniforms[e] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? n.uniforms[e] = { type: "m4", value: r.toArray() } : n.uniforms[e] = { value: r }
        }
        0 < Object.keys(this.defines).length && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader;
        var i, o = {};
        for (i in this.extensions) !0 === this.extensions[i] && (o[i] = !0);
        return 0 < Object.keys(o).length && (n.extensions = o), n
    }, go.prototype = Object.assign(Object.create(kr.prototype), { constructor: go, isCamera: !0, copy: function(t, e) { return kr.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function(t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new kn), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function(t) { kr.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, updateWorldMatrix: function(t, e) { kr.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function() { return (new this.constructor).copy(this) } }), vo.prototype = Object.assign(Object.create(go.prototype), {
        constructor: vo,
        isPerspectiveCamera: !0,
        copy: function(t, e) { return go.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this },
        setFocalLength: function(t) {
            t = .5 * this.getFilmHeight() / t;
            this.fov = 2 * An.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
        },
        getFocalLength: function() { var t = Math.tan(.5 * An.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t },
        getEffectiveFOV: function() { return 2 * An.RAD2DEG * Math.atan(Math.tan(.5 * An.DEG2RAD * this.fov) / this.zoom) },
        getFilmWidth: function() { return this.filmGauge * Math.min(this.aspect, 1) },
        getFilmHeight: function() { return this.filmGauge / Math.max(this.aspect, 1) },
        setViewOffset: function(t, e, n, r, i, o) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() },
        clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() },
        updateProjectionMatrix: function() {
            var t, e = this.near,
                n = e * Math.tan(.5 * An.DEG2RAD * this.fov) / this.zoom,
                r = 2 * n,
                i = this.aspect * r,
                o = -.5 * i,
                a = this.view;
            null !== this.view && this.view.enabled && (t = a.fullWidth, s = a.fullHeight, o += a.offsetX * i / t, n -= a.offsetY * r / s, i *= a.width / t, r *= a.height / s);
            var s = this.filmOffset;
            0 !== s && (o += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, n, n - r, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) { t = kr.prototype.toJSON.call(this, t); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t }
    });

    function yo(t, e, a) {
        var o, s, c, l, u, h;
        kr.call(this), this.type = "CubeCamera", !0 === a.isWebGLCubeRenderTarget ? (this.renderTarget = a, (o = new vo(90, 1, t, e)).layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new kn(1, 0, 0)), this.add(o), (s = new vo(90, 1, t, e)).layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new kn(-1, 0, 0)), this.add(s), (c = new vo(90, 1, t, e)).layers = this.layers, c.up.set(0, 0, 1), c.lookAt(new kn(0, 1, 0)), this.add(c), (l = new vo(90, 1, t, e)).layers = this.layers, l.up.set(0, 0, -1), l.lookAt(new kn(0, -1, 0)), this.add(l), (u = new vo(90, 1, t, e)).layers = this.layers, u.up.set(0, -1, 0), u.lookAt(new kn(0, 0, 1)), this.add(u), (h = new vo(90, 1, t, e)).layers = this.layers, h.up.set(0, -1, 0), h.lookAt(new kn(0, 0, -1)), this.add(h), this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = t.xr.enabled,
                r = t.getRenderTarget();
            t.xr.enabled = !1;
            var i = a.texture.generateMipmaps;
            a.texture.generateMipmaps = !1, t.setRenderTarget(a, 0), t.render(e, o), t.setRenderTarget(a, 1), t.render(e, s), t.setRenderTarget(a, 2), t.render(e, c), t.setRenderTarget(a, 3), t.render(e, l), t.setRenderTarget(a, 4), t.render(e, u), a.texture.generateMipmaps = i, t.setRenderTarget(a, 5), t.render(e, h), t.setRenderTarget(r), t.xr.enabled = n
        }, this.clear = function(t, e, n, r) {
            for (var i = t.getRenderTarget(), o = 0; o < 6; o++) t.setRenderTarget(a, o), t.clear(e, n, r);
            t.setRenderTarget(i)
        }) : console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.")
    }

    function _o(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), Fn.call(this, t, t, e), this.texture.isWebGLCubeRenderTargetTexture = !0 }

    function xo(t, e, n, r, i, o, a, s, c, l, u, h) { Dn.call(this, null, o, a, s, c, l, r, i, u, h), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = void 0 !== c ? c : Nt, this.minFilter = void 0 !== l ? l : Nt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 }(yo.prototype = Object.create(kr.prototype)).constructor = yo, ((_o.prototype = Object.create(Fn.prototype)).constructor = _o).prototype.isWebGLCubeRenderTarget = !0, _o.prototype.fromEquirectangularTexture = function(t, e) {
        this.texture.type = e.type, this.texture.format = ee, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
        var n = { tEquirect: { value: null } },
            r = "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
            i = "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",
            o = new co(5, 5, 5),
            i = new mo({ name: "CubemapFromEquirect", uniforms: lo(n), vertexShader: r, fragmentShader: i, side: j, blending: W });
        i.uniforms.tEquirect.value = e;
        o = new $i(o, i), i = e.minFilter;
        return e.minFilter === Ht && (e.minFilter = Ut), new yo(1, 10, this).update(t, o), e.minFilter = i, o.geometry.dispose(), o.material.dispose(), this
    }, ((xo.prototype = Object.create(Dn.prototype)).constructor = xo).prototype.isDataTexture = !0;
    var bo = new ar,
        wo = new kn,
        Mo = function(t, e, n, r, i, o) { this.planes = [void 0 !== t ? t : new Wr, void 0 !== e ? e : new Wr, void 0 !== n ? n : new Wr, void 0 !== r ? r : new Wr, void 0 !== i ? i : new Wr, void 0 !== o ? o : new Wr] };

    function So() {
        var n = null,
            t = !1,
            r = null,
            i = null;

        function o(t, e) { r(t, e), i = n.requestAnimationFrame(o) }
        return { start: function() {!0 !== t && null !== r && (i = n.requestAnimationFrame(o), t = !0) }, stop: function() { n.cancelAnimationFrame(i), t = !1 }, setAnimationLoop: function(t) { r = t }, setContext: function(t) { n = t } }
    }

    function Eo(c, t) {
        var l = t.isWebGL2,
            u = new WeakMap;
        return {
            get: function(t) { return t.isInterleavedBufferAttribute && (t = t.data), u.get(t) },
            remove: function(t) {
                t.isInterleavedBufferAttribute && (t = t.data);
                var e = u.get(t);
                e && (c.deleteBuffer(e.buffer), u.delete(t))
            },
            update: function(t, e) {
                var n, r, i, o, a, s;
                t.isGLBufferAttribute ? (!(s = u.get(t)) || s.version < t.version) && u.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version }) : (t.isInterleavedBufferAttribute && (t = t.data), void 0 === (n = u.get(t)) ? u.set(t, (i = e, o = (r = t).array, a = r.usage, s = c.createBuffer(), c.bindBuffer(i, s), c.bufferData(i, o, a), r.onUploadCallback(), a = 5126, o instanceof Float32Array ? a = 5126 : o instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : o instanceof Uint16Array ? a = 5123 : o instanceof Int16Array ? a = 5122 : o instanceof Uint32Array ? a = 5125 : o instanceof Int32Array ? a = 5124 : o instanceof Int8Array ? a = 5120 : o instanceof Uint8Array && (a = 5121), { buffer: s, type: a, bytesPerElement: o.BYTES_PER_ELEMENT, version: r.version })) : n.version < t.version && (a = n.buffer, o = e, e = (r = t).array, r = r.updateRange, c.bindBuffer(o, a), -1 === r.count ? c.bufferSubData(o, 0, e) : (l ? c.bufferSubData(o, r.offset * e.BYTES_PER_ELEMENT, e, r.offset, r.count) : c.bufferSubData(o, r.offset * e.BYTES_PER_ELEMENT, e.subarray(r.offset, r.offset + r.count)), r.count = -1), n.version = t.version))
            }
        }
    }
    Mo.prototype.set = function(t, e, n, r, i, o) { var a = this.planes; return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this }, Mo.prototype.clone = function() { return (new this.constructor).copy(this) }, Mo.prototype.copy = function(t) { for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]); return this }, Mo.prototype.setFromProjectionMatrix = function(t) {
        var e = this.planes,
            n = t.elements,
            r = n[0],
            i = n[1],
            o = n[2],
            a = n[3],
            s = n[4],
            c = n[5],
            l = n[6],
            u = n[7],
            h = n[8],
            p = n[9],
            d = n[10],
            f = n[11],
            m = n[12],
            g = n[13],
            t = n[14],
            n = n[15];
        return e[0].setComponents(a - r, u - s, f - h, n - m).normalize(), e[1].setComponents(a + r, u + s, f + h, n + m).normalize(), e[2].setComponents(a + i, u + c, f + p, n + g).normalize(), e[3].setComponents(a - i, u - c, f - p, n - g).normalize(), e[4].setComponents(a - o, u - l, f - d, n - t).normalize(), e[5].setComponents(a + o, u + l, f + d, n + t).normalize(), this
    }, Mo.prototype.intersectsObject = function(t) { var e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), bo.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(bo) }, Mo.prototype.intersectsSprite = function(t) { return bo.center.set(0, 0, 0), bo.radius = .7071067811865476, bo.applyMatrix4(t.matrixWorld), this.intersectsSphere(bo) }, Mo.prototype.intersectsSphere = function(t) {
        for (var e = this.planes, n = t.center, r = -t.radius, i = 0; i < 6; i++)
            if (e[i].distanceToPoint(n) < r) return !1;
        return !0
    }, Mo.prototype.intersectsBox = function(t) { for (var e = this.planes, n = 0; n < 6; n++) { var r = e[n]; if (wo.x = (0 < r.normal.x ? t.max : t.min).x, wo.y = (0 < r.normal.y ? t.max : t.min).y, wo.z = (0 < r.normal.z ? t.max : t.min).z, r.distanceToPoint(wo) < 0) return !1 } return !0 }, Mo.prototype.containsPoint = function(t) {
        for (var e = this.planes, n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0) return !1;
        return !0
    };
    var To = function(i) {
            function t(t, e, n, r) { i.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: r }, this.fromBufferGeometry(new Ao(t, e, n, r)), this.mergeVertices() }
            return i && (t.__proto__ = i), (t.prototype = Object.create(i && i.prototype)).constructor = t
        }(ao),
        Ao = function(T) {
            function t(t, e, n, r) {
                T.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: r };
                for (var i = (t = t || 1) / 2, o = (e = e || 1) / 2, a = Math.floor(n) || 1, s = Math.floor(r) || 1, c = a + 1, l = s + 1, u = t / a, h = e / s, p = [], d = [], f = [], m = [], g = 0; g < l; g++)
                    for (var v = g * h - o, y = 0; y < c; y++) {
                        var _ = y * u - i;
                        d.push(_, -v, 0), f.push(0, 0, 1), m.push(y / a), m.push(1 - g / s)
                    }
                for (var x = 0; x < s; x++)
                    for (var b = 0; b < a; b++) {
                        var w = b + c * x,
                            M = b + c * (x + 1),
                            S = b + 1 + c * (x + 1),
                            E = b + 1 + c * x;
                        p.push(w, M, E), p.push(M, S, E)
                    }
                this.setIndex(p), this.setAttribute("position", new Si(d, 3)), this.setAttribute("normal", new Si(f, 3)), this.setAttribute("uv", new Si(m, 2))
            }
            return T && (t.__proto__ = T), (t.prototype = Object.create(T && T.prototype)).constructor = t
        }(Ni),
        Lo = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" },
        Ro = { common: { diffuse: { value: new li(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Pn }, uv2Transform: { value: new Pn }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Ln(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new li(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new li(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Pn } }, sprite: { diffuse: { value: new li(15658734) }, opacity: { value: 1 }, center: { value: new Ln(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Pn } } },
        Co = { basic: { uniforms: uo([Ro.common, Ro.specularmap, Ro.envmap, Ro.aomap, Ro.lightmap, Ro.fog]), vertexShader: Lo.meshbasic_vert, fragmentShader: Lo.meshbasic_frag }, lambert: { uniforms: uo([Ro.common, Ro.specularmap, Ro.envmap, Ro.aomap, Ro.lightmap, Ro.emissivemap, Ro.fog, Ro.lights, { emissive: { value: new li(0) } }]), vertexShader: Lo.meshlambert_vert, fragmentShader: Lo.meshlambert_frag }, phong: { uniforms: uo([Ro.common, Ro.specularmap, Ro.envmap, Ro.aomap, Ro.lightmap, Ro.emissivemap, Ro.bumpmap, Ro.normalmap, Ro.displacementmap, Ro.fog, Ro.lights, { emissive: { value: new li(0) }, specular: { value: new li(1118481) }, shininess: { value: 30 } }]), vertexShader: Lo.meshphong_vert, fragmentShader: Lo.meshphong_frag }, standard: { uniforms: uo([Ro.common, Ro.envmap, Ro.aomap, Ro.lightmap, Ro.emissivemap, Ro.bumpmap, Ro.normalmap, Ro.displacementmap, Ro.roughnessmap, Ro.metalnessmap, Ro.fog, Ro.lights, { emissive: { value: new li(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Lo.meshphysical_vert, fragmentShader: Lo.meshphysical_frag }, toon: { uniforms: uo([Ro.common, Ro.aomap, Ro.lightmap, Ro.emissivemap, Ro.bumpmap, Ro.normalmap, Ro.displacementmap, Ro.gradientmap, Ro.fog, Ro.lights, { emissive: { value: new li(0) } }]), vertexShader: Lo.meshtoon_vert, fragmentShader: Lo.meshtoon_frag }, matcap: { uniforms: uo([Ro.common, Ro.bumpmap, Ro.normalmap, Ro.displacementmap, Ro.fog, { matcap: { value: null } }]), vertexShader: Lo.meshmatcap_vert, fragmentShader: Lo.meshmatcap_frag }, points: { uniforms: uo([Ro.points, Ro.fog]), vertexShader: Lo.points_vert, fragmentShader: Lo.points_frag }, dashed: { uniforms: uo([Ro.common, Ro.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Lo.linedashed_vert, fragmentShader: Lo.linedashed_frag }, depth: { uniforms: uo([Ro.common, Ro.displacementmap]), vertexShader: Lo.depth_vert, fragmentShader: Lo.depth_frag }, normal: { uniforms: uo([Ro.common, Ro.bumpmap, Ro.normalmap, Ro.displacementmap, { opacity: { value: 1 } }]), vertexShader: Lo.normal_vert, fragmentShader: Lo.normal_frag }, sprite: { uniforms: uo([Ro.sprite, Ro.fog]), vertexShader: Lo.sprite_vert, fragmentShader: Lo.sprite_frag }, background: { uniforms: { uvTransform: { value: new Pn }, t2D: { value: null } }, vertexShader: Lo.background_vert, fragmentShader: Lo.background_frag }, cube: { uniforms: uo([Ro.envmap, { opacity: { value: 1 } }]), vertexShader: Lo.cube_vert, fragmentShader: Lo.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Lo.equirect_vert, fragmentShader: Lo.equirect_frag }, distanceRGBA: { uniforms: uo([Ro.common, Ro.displacementmap, { referencePosition: { value: new kn }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Lo.distanceRGBA_vert, fragmentShader: Lo.distanceRGBA_frag }, shadow: { uniforms: uo([Ro.lights, Ro.fog, { color: { value: new li(0) }, opacity: { value: 1 } }]), vertexShader: Lo.shadow_vert, fragmentShader: Lo.shadow_frag } };

    function Po(o, a, n, s, r) {
        var c, l, u = new li(0),
            h = 0,
            p = null,
            d = 0,
            f = null;

        function m(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, r) }
        return {
            getClearColor: function() { return u },
            setClearColor: function(t, e) { u.set(t), m(u, h = void 0 !== e ? e : 1) },
            getClearAlpha: function() { return h },
            setClearAlpha: function(t) { m(u, h = t) },
            render: function(t, e, n, r) {
                var i = !0 === e.isScene ? e.background : null;
                i && i.isTexture && (i = a.get(i)), (e = (e = o.xr).getSession && e.getSession()) && "additive" === e.environmentBlendMode && (i = null), null === i ? m(u, h) : i && i.isColor && (m(i, 1), r = !0), (o.autoClear || r) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), i && (i.isCubeTexture || i.isWebGLCubeRenderTarget || i.isWebGLCubeRenderTargetTexture || i.mapping === Ct) ? (void 0 === l && ((l = new $i(new co(1, 1, 1), new mo({ name: "BackgroundCubeMaterial", uniforms: lo(Co.cube.uniforms), vertexShader: Co.cube.vertexShader, fragmentShader: Co.cube.fragmentShader, side: j, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(l.material, "envMap", { get: function() { return this.uniforms.envMap.value } }), s.update(l)), i.isWebGLCubeRenderTarget && (i = i.texture), l.material.uniforms.envMap.value = i, l.material.uniforms.flipEnvMap.value = i.isCubeTexture ? -1 : 1, p === i && d === i.version && f === o.toneMapping || (l.material.needsUpdate = !0, d = (p = i).version, f = o.toneMapping), t.unshift(l, l.geometry, l.material, 0, 0, null)) : i && i.isTexture && (void 0 === c && ((c = new $i(new Ao(2, 2), new mo({ name: "BackgroundMaterial", uniforms: lo(Co.background.uniforms), vertexShader: Co.background.vertexShader, fragmentShader: Co.background.fragmentShader, side: X, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", { get: function() { return this.uniforms.t2D.value } }), s.update(c)), !0 === (c.material.uniforms.t2D.value = i).matrixAutoUpdate && i.updateMatrix(), c.material.uniforms.uvTransform.value.copy(i.matrix), p === i && d === i.version && f === o.toneMapping || (c.material.needsUpdate = !0, d = (p = i).version, f = o.toneMapping), t.unshift(c, c.geometry, c.material, 0, 0, null))
            }
        }
    }

    function Oo(b, w, M, S) {
        var o = b.getParameter(34921),
            s = S.isWebGL2 ? null : w.get("OES_vertex_array_object"),
            c = S.isWebGL2 || null !== s,
            l = {},
            t = p(null),
            u = t;

        function h(t) { return S.isWebGL2 ? b.bindVertexArray(t) : s.bindVertexArrayOES(t) }

        function a(t) { return S.isWebGL2 ? b.deleteVertexArray(t) : s.deleteVertexArrayOES(t) }

        function p(t) { for (var e = [], n = [], r = [], i = 0; i < o; i++) e[i] = 0, n[i] = 0, r[i] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: r, object: t, attributes: {}, index: null } }

        function E() { for (var t = u.newAttributes, e = 0, n = t.length; e < n; e++) t[e] = 0 }

        function T(t) { A(t, 0) }

        function A(t, e) {
            var n = u.newAttributes,
                r = u.enabledAttributes,
                i = u.attributeDivisors;
            n[t] = 1, 0 === r[t] && (b.enableVertexAttribArray(t), r[t] = 1), i[t] !== e && ((S.isWebGL2 ? b : w.get("ANGLE_instanced_arrays"))[S.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), i[t] = e)
        }

        function L() { for (var t = u.newAttributes, e = u.enabledAttributes, n = 0, r = e.length; n < r; n++) e[n] !== t[n] && (b.disableVertexAttribArray(n), e[n] = 0) }

        function R(t, e, n, r, i, o) {!0 !== S.isWebGL2 || 5124 !== n && 5125 !== n ? b.vertexAttribPointer(t, e, n, r, i, o) : b.vertexAttribIPointer(t, e, n, i, o) }

        function d() { e(), u !== t && h((u = t).object) }

        function e() { t.geometry = null, t.program = null, t.wireframe = !1 }
        return {
            setup: function(t, e, n, r, i) {
                var o, a = !1;
                c ? (o = function(t, e, n) {
                    var r = !0 === n.wireframe,
                        n = l[t.id];
                    void 0 === n && (n = {}, l[t.id] = n);
                    t = n[e.id];
                    void 0 === t && (t = {}, n[e.id] = t);
                    e = t[r];
                    void 0 === e && (e = p(function() { if (S.isWebGL2) return b.createVertexArray(); return s.createVertexArrayOES() }()), t[r] = e);
                    return e
                }(r, n, e), u !== o && h((u = o).object), (a = function(t, e) {
                    var n, r = u.attributes,
                        i = t.attributes;
                    if (Object.keys(r).length !== Object.keys(i).length) return !0;
                    for (n in i) {
                        var o = r[n],
                            a = i[n];
                        if (void 0 === o) return !0;
                        if (o.attribute !== a) return !0;
                        if (o.data !== a.data) return !0
                    }
                    return u.index !== e
                }(r, i)) && function(t, e) {
                    var n, r = {},
                        i = t.attributes;
                    for (n in i) {
                        var o = i[n],
                            a = {};
                        (a.attribute = o).data && (a.data = o.data), r[n] = a
                    }
                    u.attributes = r, u.index = e
                }(r, i)) : (o = !0 === e.wireframe, u.geometry === r.id && u.program === n.id && u.wireframe === o || (u.geometry = r.id, u.program = n.id, u.wireframe = o, a = !0)), !0 === t.isInstancedMesh && (a = !0), null !== i && M.update(i, 34963), a && (function(t, e, n, r) {
                    if (!1 === S.isWebGL2 && (t.isInstancedMesh || r.isInstancedBufferGeometry) && null === w.get("ANGLE_instanced_arrays")) return;
                    E();
                    var i, o = r.attributes,
                        a = n.getAttributes(),
                        s = e.defaultAttributeValues;
                    for (i in a) {
                        var c = a[i];
                        if (0 <= c) {
                            var l = o[i];
                            if (void 0 !== l) {
                                var u, h, p, d, f, m = l.normalized,
                                    g = l.itemSize,
                                    v = M.get(l);
                                void 0 !== v && (u = v.buffer, h = v.type, p = v.bytesPerElement, l.isInterleavedBufferAttribute ? (d = l.data, f = d.stride, v = l.offset, d && d.isInstancedInterleavedBuffer ? (A(c, d.meshPerAttribute), void 0 === r._maxInstanceCount && (r._maxInstanceCount = d.meshPerAttribute * d.count)) : T(c), b.bindBuffer(34962, u), R(c, g, h, m, f * p, v * p)) : (l.isInstancedBufferAttribute ? (A(c, l.meshPerAttribute), void 0 === r._maxInstanceCount && (r._maxInstanceCount = l.meshPerAttribute * l.count)) : T(c), b.bindBuffer(34962, u), R(c, g, h, m, 0, 0)))
                            } else if ("instanceMatrix" === i) {
                                m = M.get(t.instanceMatrix);
                                void 0 !== m && (_ = m.buffer, y = m.type, A(c + 0, 1), A(c + 1, 1), A(c + 2, 1), A(c + 3, 1), b.bindBuffer(34962, _), b.vertexAttribPointer(c + 0, 4, y, !1, 64, 0), b.vertexAttribPointer(c + 1, 4, y, !1, 64, 16), b.vertexAttribPointer(c + 2, 4, y, !1, 64, 32), b.vertexAttribPointer(c + 3, 4, y, !1, 64, 48))
                            } else if ("instanceColor" === i) {
                                var y, _ = M.get(t.instanceColor);
                                void 0 !== _ && (y = _.buffer, _ = _.type, A(c, 1), b.bindBuffer(34962, y), b.vertexAttribPointer(c, 3, _, !1, 12, 0))
                            } else if (void 0 !== s) {
                                var x = s[i];
                                if (void 0 !== x) switch (x.length) {
                                    case 2:
                                        b.vertexAttrib2fv(c, x);
                                        break;
                                    case 3:
                                        b.vertexAttrib3fv(c, x);
                                        break;
                                    case 4:
                                        b.vertexAttrib4fv(c, x);
                                        break;
                                    default:
                                        b.vertexAttrib1fv(c, x)
                                }
                            }
                        }
                    }
                    L()
                }(t, e, n, r), null !== i && b.bindBuffer(34963, M.get(i).buffer))
            },
            reset: d,
            resetDefaultState: e,
            dispose: function() {
                for (var t in d(), l) {
                    var e, n = l[t];
                    for (e in n) {
                        var r, i = n[e];
                        for (r in i) a(i[r].object), delete i[r];
                        delete n[e]
                    }
                    delete l[t]
                }
            },
            releaseStatesOfGeometry: function(t) {
                if (void 0 !== l[t.id]) {
                    var e, n = l[t.id];
                    for (e in n) {
                        var r, i = n[e];
                        for (r in i) a(i[r].object), delete i[r];
                        delete n[e]
                    }
                    delete l[t.id]
                }
            },
            releaseStatesOfProgram: function(t) {
                for (var e in l) {
                    var n = l[e];
                    if (void 0 !== n[t.id]) {
                        var r, i = n[t.id];
                        for (r in i) a(i[r].object), delete i[r];
                        delete n[t.id]
                    }
                }
            },
            initAttributes: E,
            enableAttribute: T,
            disableUnusedAttributes: L
        }
    }

    function Io(o, a, s, t) {
        var c, l = t.isWebGL2;
        this.setMode = function(t) { c = t }, this.render = function(t, e) { o.drawArrays(c, t, e), s.update(e, c, 1) }, this.renderInstances = function(t, e, n) {
            if (0 !== n) {
                var r, i;
                if (l) r = o, i = "drawArraysInstanced";
                else if (i = "drawArraysInstancedANGLE", null === (r = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                r[i](c, t, e, n), s.update(e, c, n)
            }
        }
    }

    function Do(e, n, t) {
        var r;

        function i(t) {
            if ("highp" === t) {
                if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                t = "mediump"
            }
            return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
            a = void 0 !== t.precision ? t.precision : "highp",
            s = i(a);
        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
        var c = !0 === t.logarithmicDepthBuffer,
            l = e.getParameter(34930),
            u = e.getParameter(35660),
            h = e.getParameter(3379),
            p = e.getParameter(34076),
            d = e.getParameter(34921),
            f = e.getParameter(36347),
            m = e.getParameter(36348),
            g = e.getParameter(36349),
            s = 0 < u,
            t = o || !!n.get("OES_texture_float");
        return { isWebGL2: o, getMaxAnisotropy: function() { if (void 0 !== r) return r; var t = n.get("EXT_texture_filter_anisotropic"); return r = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: i, precision: a, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: u, maxTextureSize: h, maxCubemapSize: p, maxAttributes: d, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: s, floatFragmentTextures: t, floatVertexTextures: s && t, maxSamples: o ? e.getParameter(36183) : 0 }
    }

    function No(l) {
        var u = this,
            h = null,
            p = 0,
            d = !1,
            f = !1,
            m = new Wr,
            g = new Pn,
            v = { value: null, needsUpdate: !1 };

        function y() { v.value !== h && (v.value = h, v.needsUpdate = 0 < p), u.numPlanes = p, u.numIntersection = 0 }

        function _(t, e, n, r) {
            var i = null !== t ? t.length : 0,
                o = null;
            if (0 !== i) {
                if (o = v.value, !0 !== r || null === o) {
                    var r = n + 4 * i,
                        a = e.matrixWorldInverse;
                    g.getNormalMatrix(a), (null === o || o.length < r) && (o = new Float32Array(r));
                    for (var s = 0, c = n; s !== i; ++s, c += 4) m.copy(t[s]).applyMatrix4(a, g), m.normal.toArray(o, c), o[c + 3] = m.constant
                }
                v.value = o, v.needsUpdate = !0
            }
            return u.numPlanes = i, u.numIntersection = 0, o
        }
        this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, n) { var r = 0 !== t.length || e || 0 !== p || d; return d = e, h = _(t, n, 0), p = t.length, r }, this.beginShadows = function() { f = !0, _(null) }, this.endShadows = function() { f = !1, y() }, this.setState = function(t, e, n) {
            var r = t.clippingPlanes,
                i = t.clipIntersection,
                o = t.clipShadows,
                t = l.get(t);
            if (!d || null === r || 0 === r.length || f && !o) f ? _(null) : y();
            else {
                var o = f ? 0 : p,
                    a = 4 * o,
                    s = t.clippingState || null;
                v.value = s, s = _(r, e, a, n);
                for (var c = 0; c !== a; ++c) s[c] = h[c];
                t.clippingState = s, this.numIntersection = i ? this.numPlanes : 0, this.numPlanes += o
            }
        }
    }

    function Bo(o) {
        var a = new WeakMap;

        function s(t, e) { return e === Lt ? t.mapping = Tt : e === Rt && (t.mapping = At), t }
        return {
            get: function(t) {
                if (t && t.isTexture) {
                    var e = t.mapping;
                    if (e === Lt || e === Rt) {
                        if (a.has(t)) return s(a.get(t).texture, t.mapping);
                        var n = t.image;
                        if (n && 0 < n.height) {
                            var r = o.getRenderList(),
                                i = o.getRenderTarget(),
                                e = o.getRenderState(),
                                n = new _o(n.height / 2);
                            return n.fromEquirectangularTexture(o, t), a.set(t, n), o.setRenderTarget(i), o.setRenderList(r), o.setRenderState(e), s(n.texture, t.mapping)
                        }
                        return null
                    }
                }
                return t
            },
            dispose: function() { a = new WeakMap }
        }
    }

    function Fo(n) {
        var r = {};
        return {
            has: function(t) {
                if (void 0 !== r[t]) return null !== r[t];
                var e;
                switch (t) {
                    case "WEBGL_depth_texture":
                        e = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        e = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        e = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        e = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        e = n.getExtension(t)
                }
                return null !== (r[t] = e)
            },
            get: function(t) { return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), r[t] }
        }
    }

    function Uo(t, v, i, o) {
        var a = new WeakMap,
            y = new WeakMap;

        function s(t) {
            var e, n = t.target,
                r = a.get(n);
            for (e in null !== r.index && v.remove(r.index), r.attributes) v.remove(r.attributes[e]);
            n.removeEventListener("dispose", s), a.delete(n);
            t = y.get(r);
            t && (v.remove(t), y.delete(r)), o.releaseStatesOfGeometry(n), !0 === n.isInstancedBufferGeometry && delete n._maxInstanceCount, i.memory.geometries--
        }

        function r(t) {
            var e = [],
                n = t.index,
                r = t.attributes.position,
                i = 0;
            if (null !== n)
                for (var o = n.array, i = n.version, a = 0, s = o.length; a < s; a += 3) {
                    var c = o[a + 0],
                        l = o[a + 1],
                        u = o[a + 2];
                    e.push(c, l, l, u, u, c)
                } else {
                    var h = r.array;
                    i = r.version;
                    for (var p = 0, d = h.length / 3 - 1; p < d; p += 3) {
                        var f = p + 0,
                            m = p + 1,
                            g = p + 2;
                        e.push(f, m, m, g, g, f)
                    }
                }
            h = new(65535 < Ai(e) ? Mi : bi)(e, 1);
            h.version = i;
            i = y.get(t);
            i && v.remove(i), y.set(t, h)
        }
        return {
            get: function(t, e) { var n = a.get(e); return n || (e.addEventListener("dispose", s), e.isBufferGeometry ? n = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Ni).setFromObject(t)), n = e._bufferGeometry), a.set(e, n), i.memory.geometries++, n) },
            update: function(t) {
                var e, n = t.attributes;
                for (e in n) v.update(n[e], 34962);
                var r, i = t.morphAttributes;
                for (r in i)
                    for (var o = i[r], a = 0, s = o.length; a < s; a++) v.update(o[a], 34962)
            },
            getWireframeAttribute: function(t) { var e, n = y.get(t); return (!n || null !== (e = t.index) && n.version < e.version) && r(t), y.get(t) }
        }
    }

    function zo(o, a, s, t) {
        var c, l, u, h = t.isWebGL2;
        this.setMode = function(t) { c = t }, this.setIndex = function(t) { l = t.type, u = t.bytesPerElement }, this.render = function(t, e) { o.drawElements(c, e, l, t * u), s.update(e, c, 1) }, this.renderInstances = function(t, e, n) {
            if (0 !== n) {
                var r, i;
                if (h) r = o, i = "drawElementsInstanced";
                else if (i = "drawElementsInstancedANGLE", null === (r = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                r[i](c, e, l, t * u, n), s.update(e, c, n)
            }
        }
    }

    function Ho(t) {
        var r = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
            memory: { geometries: 0, textures: 0 },
            render: r,
            programs: null,
            autoReset: !0,
            reset: function() { r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0 },
            update: function(t, e, n) {
                switch (r.calls++, e) {
                    case 4:
                        r.triangles += n * (t / 3);
                        break;
                    case 1:
                        r.lines += n * (t / 2);
                        break;
                    case 3:
                        r.lines += n * (t - 1);
                        break;
                    case 2:
                        r.lines += n * t;
                        break;
                    case 0:
                        r.points += n * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", e)
                }
            }
        }
    }

    function ko(t, e) { return t[0] - e[0] }

    function Go(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) }

    function Vo(v) {
        for (var y = {}, _ = new Float32Array(8), x = [], t = 0; t < 8; t++) x[t] = [t, 0];
        return {
            update: function(t, e, n, r) {
                var i = t.morphTargetInfluences,
                    o = void 0 === i ? 0 : i.length,
                    a = y[e.id];
                if (void 0 === a) {
                    a = [];
                    for (var s = 0; s < o; s++) a[s] = [s, 0];
                    y[e.id] = a
                }
                for (var c = 0; c < o; c++) {
                    var l = a[c];
                    l[0] = c, l[1] = i[c]
                }
                a.sort(Go);
                for (var u = 0; u < 8; u++) u < o && a[u][1] ? (x[u][0] = a[u][0], x[u][1] = a[u][1]) : (x[u][0] = Number.MAX_SAFE_INTEGER, x[u][1] = 0);
                x.sort(ko);
                for (var h = n.morphTargets && e.morphAttributes.position, p = n.morphNormals && e.morphAttributes.normal, d = 0, f = 0; f < 8; f++) {
                    var m = x[f],
                        g = m[0],
                        m = m[1];
                    g !== Number.MAX_SAFE_INTEGER && m ? (h && e.getAttribute("morphTarget" + f) !== h[g] && e.setAttribute("morphTarget" + f, h[g]), p && e.getAttribute("morphNormal" + f) !== p[g] && e.setAttribute("morphNormal" + f, p[g]), d += _[f] = m) : (h && void 0 !== e.getAttribute("morphTarget" + f) && e.deleteAttribute("morphTarget" + f), p && void 0 !== e.getAttribute("morphNormal" + f) && e.deleteAttribute("morphNormal" + f), _[f] = 0)
                }
                n = e.morphTargetsRelative ? 1 : 1 - d, r.getUniforms().setValue(v, "morphTargetBaseInfluence", n), r.getUniforms().setValue(v, "morphTargetInfluences", _)
            }
        }
    }

    function jo(t, i, o, a) {
        var s = new WeakMap;
        return {
            update: function(t) {
                var e = a.render.frame,
                    n = t.geometry,
                    r = i.get(t, n);
                return s.get(r) !== e && (n.isGeometry && r.updateFromObject(t), i.update(r), s.set(r, e)), t.isInstancedMesh && (o.update(t.instanceMatrix, 34962), null !== t.instanceColor && o.update(t.instanceColor, 34962)), r
            },
            dispose: function() { s = new WeakMap }
        }
    }

    function Wo(t, e, n, r, i, o, a, s, c, l) { Dn.call(this, t = void 0 !== t ? t : [], e = void 0 !== e ? e : Tt, n, r, i, o, a = void 0 !== a ? a : te, s, c, l), this.flipY = !1 }

    function qo(t, e, n, r) { Dn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: r || 1 }, this.magFilter = Nt, this.minFilter = Nt, this.wrapR = It, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 }

    function Xo(t, e, n, r) { Dn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: r || 1 }, this.magFilter = Nt, this.minFilter = Nt, this.wrapR = It, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 }
    Co.physical = { uniforms: uo([Co.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Ln(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new li(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: Lo.meshphysical_vert, fragmentShader: Lo.meshphysical_frag }, ((Wo.prototype = Object.create(Dn.prototype)).constructor = Wo).prototype.isCubeTexture = !0, Object.defineProperty(Wo.prototype, "images", { get: function() { return this.image }, set: function(t) { this.image = t } }), ((qo.prototype = Object.create(Dn.prototype)).constructor = qo).prototype.isDataTexture2DArray = !0, ((Xo.prototype = Object.create(Dn.prototype)).constructor = Xo).prototype.isDataTexture3D = !0;
    var Yo = new Dn,
        Zo = new qo,
        Jo = new Xo,
        Ko = new Wo,
        Qo = [],
        $o = [],
        ta = new Float32Array(16),
        ea = new Float32Array(9),
        na = new Float32Array(4);

    function ra(t, e, n) {
        var r = t[0];
        if (r <= 0 || 0 < r) return t;
        var i = e * n,
            o = Qo[i];
        if (void 0 === o && (o = new Float32Array(i), Qo[i] = o), 0 !== e) { r.toArray(o, 0); for (var a = 1, s = 0; a !== e; ++a) s += n, t[a].toArray(o, s) }
        return o
    }

    function ia(t, e) {
        if (t.length === e.length) {
            for (var n = 0, r = t.length; n < r; n++)
                if (t[n] !== e[n]) return;
            return 1
        }
    }

    function oa(t, e) { for (var n = 0, r = e.length; n < r; n++) t[n] = e[n] }

    function aa(t, e) {
        var n = $o[e];
        void 0 === n && (n = new Int32Array(e), $o[e] = n);
        for (var r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
        return n
    }

    function sa(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
    }

    function ca(t, e) {
        var n = this.cache;
        void 0 !== e.x ? n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y) : ia(n, e) || (t.uniform2fv(this.addr, e), oa(n, e))
    }

    function la(t, e) {
        var n = this.cache;
        void 0 !== e.x ? n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z) : void 0 !== e.r ? n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b) : ia(n, e) || (t.uniform3fv(this.addr, e), oa(n, e))
    }

    function ua(t, e) {
        var n = this.cache;
        void 0 !== e.x ? n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w) : ia(n, e) || (t.uniform4fv(this.addr, e), oa(n, e))
    }

    function ha(t, e) {
        var n = this.cache,
            r = e.elements;
        void 0 === r ? ia(n, e) || (t.uniformMatrix2fv(this.addr, !1, e), oa(n, e)) : ia(n, r) || (na.set(r), t.uniformMatrix2fv(this.addr, !1, na), oa(n, r))
    }

    function pa(t, e) {
        var n = this.cache,
            r = e.elements;
        void 0 === r ? ia(n, e) || (t.uniformMatrix3fv(this.addr, !1, e), oa(n, e)) : ia(n, r) || (ea.set(r), t.uniformMatrix3fv(this.addr, !1, ea), oa(n, r))
    }

    function da(t, e) {
        var n = this.cache,
            r = e.elements;
        void 0 === r ? ia(n, e) || (t.uniformMatrix4fv(this.addr, !1, e), oa(n, e)) : ia(n, r) || (ta.set(r), t.uniformMatrix4fv(this.addr, !1, ta), oa(n, r))
    }

    function fa(t, e, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || Yo, i)
    }

    function ma(t, e, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || Zo, i)
    }

    function ga(t, e, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || Jo, i)
    }

    function va(t, e, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || Ko, i)
    }

    function ya(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
    }

    function _a(t, e) {
        var n = this.cache;
        ia(n, e) || (t.uniform2iv(this.addr, e), oa(n, e))
    }

    function xa(t, e) {
        var n = this.cache;
        ia(n, e) || (t.uniform3iv(this.addr, e), oa(n, e))
    }

    function ba(t, e) {
        var n = this.cache;
        ia(n, e) || (t.uniform4iv(this.addr, e), oa(n, e))
    }

    function wa(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
    }

    function Ma(t, e) { t.uniform1fv(this.addr, e) }

    function Sa(t, e) { t.uniform1iv(this.addr, e) }

    function Ea(t, e) { t.uniform2iv(this.addr, e) }

    function Ta(t, e) { t.uniform3iv(this.addr, e) }

    function Aa(t, e) { t.uniform4iv(this.addr, e) }

    function La(t, e) {
        e = ra(e, this.size, 2);
        t.uniform2fv(this.addr, e)
    }

    function Ra(t, e) {
        e = ra(e, this.size, 3);
        t.uniform3fv(this.addr, e)
    }

    function Ca(t, e) {
        e = ra(e, this.size, 4);
        t.uniform4fv(this.addr, e)
    }

    function Pa(t, e) {
        e = ra(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, e)
    }

    function Oa(t, e) {
        e = ra(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, e)
    }

    function Ia(t, e) {
        e = ra(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, e)
    }

    function Da(t, e, n) {
        var r = e.length,
            i = aa(n, r);
        t.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o) n.safeSetTexture2D(e[o] || Yo, i[o])
    }

    function Na(t, e, n) {
        var r = e.length,
            i = aa(n, r);
        t.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o) n.safeSetTextureCube(e[o] || Ko, i[o])
    }

    function Ba(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
            switch (t) {
                case 5126:
                    return sa;
                case 35664:
                    return ca;
                case 35665:
                    return la;
                case 35666:
                    return ua;
                case 35674:
                    return ha;
                case 35675:
                    return pa;
                case 35676:
                    return da;
                case 5124:
                case 35670:
                    return ya;
                case 35667:
                case 35671:
                    return _a;
                case 35668:
                case 35672:
                    return xa;
                case 35669:
                case 35673:
                    return ba;
                case 5125:
                    return wa;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return fa;
                case 35679:
                case 36299:
                case 36307:
                    return ga;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return va;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return ma
            }
        }(e.type)
    }

    function Fa(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
            switch (t) {
                case 5126:
                    return Ma;
                case 35664:
                    return La;
                case 35665:
                    return Ra;
                case 35666:
                    return Ca;
                case 35674:
                    return Pa;
                case 35675:
                    return Oa;
                case 35676:
                    return Ia;
                case 5124:
                case 35670:
                    return Sa;
                case 35667:
                case 35671:
                    return Ea;
                case 35668:
                case 35672:
                    return Ta;
                case 35669:
                case 35673:
                    return Aa;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Da;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Na
            }
        }(e.type)
    }

    function Ua(t) { this.id = t, this.seq = [], this.map = {} }
    Fa.prototype.updateCache = function(t) {
        var e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), oa(e, t)
    }, Ua.prototype.setValue = function(t, e, n) {
        for (var r = this.seq, i = 0, o = r.length; i !== o; ++i) {
            var a = r[i];
            a.setValue(t, e[a.id], n)
        }
    };
    var za = /([\w\d_]+)(\])?(\[|\.)?/g;

    function Ha(t, e) { t.seq.push(e), t.map[e.id] = e }

    function ka(t, e) {
        this.seq = [], this.map = {};
        for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
            var i = t.getActiveUniform(e, r);
            ! function(t, e, n) {
                var r = t.name,
                    i = r.length;
                for (za.lastIndex = 0;;) {
                    var o = za.exec(r),
                        a = za.lastIndex,
                        s = o[1],
                        c = "]" === o[2],
                        o = o[3];
                    if (c && (s |= 0), void 0 === o || "[" === o && a + 2 === i) { Ha(n, new(void 0 === o ? Ba : Fa)(s, t, e)); break }
                    o = n.map[s];
                    void 0 === o && Ha(n, o = new Ua(s)), n = o
                }
            }(i, t.getUniformLocation(e, i.name), this)
        }
    }

    function Ga(t, e, n) { e = t.createShader(e); return t.shaderSource(e, n), t.compileShader(e), e }
    ka.prototype.setValue = function(t, e, n, r) {
        e = this.map[e];
        void 0 !== e && e.setValue(t, n, r)
    }, ka.prototype.setOptional = function(t, e, n) {
        e = e[n];
        void 0 !== e && this.setValue(t, n, e)
    }, ka.upload = function(t, e, n, r) {
        for (var i = 0, o = e.length; i !== o; ++i) {
            var a = e[i],
                s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(t, s.value, r)
        }
    }, ka.seqWithValue = function(t, e) {
        for (var n = [], r = 0, i = t.length; r !== i; ++r) {
            var o = t[r];
            o.id in e && n.push(o)
        }
        return n
    };
    var Va = 0;

    function ja(t) {
        switch (t) {
            case an:
                return ["Linear", "( value )"];
            case sn:
                return ["sRGB", "( value )"];
            case ln:
                return ["RGBE", "( value )"];
            case hn:
                return ["RGBM", "( value, 7.0 )"];
            case pn:
                return ["RGBM", "( value, 16.0 )"];
            case dn:
                return ["RGBD", "( value, 256.0 )"];
            case cn:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case un:
                return ["LogLuv", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
        }
    }

    function Wa(t, e, n) {
        var r = t.getShaderParameter(e, 35713),
            i = t.getShaderInfoLog(e).trim();
        return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function(t) { for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n]; return e.join("\n") }(t.getShaderSource(e))
    }

    function qa(t, e) { e = ja(e); return "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }" }

    function Xa(t) { return "" !== t }

    function Ya(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) }

    function Za(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) }
    var Ja = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Ka(t) { return t.replace(Ja, Qa) }

    function Qa(t, e) { var n = Lo[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return Ka(n) }
    var $a = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        ts = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function es(t) { return t.replace(ts, rs).replace($a, ns) }

    function ns(t, e, n, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), rs(0, e, n, r) }

    function rs(t, e, n, r) { for (var i = "", o = parseInt(e); o < parseInt(n); o++) i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o); return i }

    function is(t) { var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e }

    function os(t, e, n, r) {
        var i, o, a = t.getContext(),
            s = n.defines,
            c = n.vertexShader,
            l = n.fragmentShader,
            u = (m = "SHADOWMAP_TYPE_BASIC", (f = n).shadowMapType === O ? m = "SHADOWMAP_TYPE_PCF" : f.shadowMapType === I ? m = "SHADOWMAP_TYPE_PCF_SOFT" : f.shadowMapType === D && (m = "SHADOWMAP_TYPE_VSM"), m),
            h = function(t) {
                var e = "ENVMAP_TYPE_CUBE";
                if (t.envMap) switch (t.envMapMode) {
                    case Tt:
                    case At:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case Ct:
                    case Pt:
                        e = "ENVMAP_TYPE_CUBE_UV"
                }
                return e
            }(n),
            p = function(t) {
                var e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap) switch (t.envMapMode) {
                    case At:
                    case Pt:
                        e = "ENVMAP_MODE_REFRACTION"
                }
                return e
            }(n),
            d = function(t) {
                var e = "ENVMAP_BLENDING_NONE";
                if (t.envMap) switch (t.combine) {
                    case N:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case B:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case F:
                        e = "ENVMAP_BLENDING_ADD"
                }
                return e
            }(n),
            f = 0 < t.gammaFactor ? t.gammaFactor : 1,
            m = n.isWebGL2 ? "" : [(g = n).extensionDerivatives || g.envMapCubeUV || g.bumpMap || g.tangentSpaceNormalMap || g.clearcoatNormalMap || g.flatShading || "physical" === g.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (g.extensionFragDepth || g.logarithmicDepthBuffer) && g.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", g.extensionDrawBuffers && g.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (g.extensionShaderTextureLOD || g.envMap) && g.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Xa).join("\n"),
            g = function(t) { var e, n = []; for (e in t) { var r = t[e];!1 !== r && n.push("#define " + e + " " + r) } return n.join("\n") }(s),
            v = a.createProgram(),
            s = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial ? (0 < (i = [g].filter(Xa).join("\n")).length && (i += "\n"), 0 < (o = [m, g].filter(Xa).join("\n")).length && (o += "\n")) : (i = [is(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Xa).join("\n"), o = [m, is(n), "#define SHADER_NAME " + n.shaderName, g, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Et ? "#define TONE_MAPPING" : "", n.toneMapping !== Et ? Lo.tonemapping_pars_fragment : "", n.toneMapping !== Et ? function(t, e) {
            var n;
            switch (e) {
                case U:
                    n = "Linear";
                    break;
                case z:
                    n = "Reinhard";
                    break;
                case H:
                    n = "OptimizedCineon";
                    break;
                case Mt:
                    n = "ACESFilmic";
                    break;
                case St:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Lo.encodings_pars_fragment, n.map ? qa("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? qa("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? qa("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? qa("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? qa("lightMapTexelToLinear", n.lightMapEncoding) : "", (y = "linearToOutputTexel", _ = ja(_ = n.outputEncoding), "vec4 " + y + "( vec4 value ) { return LinearTo" + _[0] + _[1] + "; }"), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Xa).join("\n")), c = Za(c = Ya(c = Ka(c), n), n), l = Za(l = Ya(l = Ka(l), n), n), c = es(c), l = es(l), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (s = "#version 300 es\n", i = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, o = ["#define varying in", n.glslVersion === wn ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === wn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + o);
        var y, _, x, b, p = s + o + l,
            d = Ga(a, 35633, s + i + c),
            u = Ga(a, 35632, p);
        return a.attachShader(v, d), a.attachShader(v, u), void 0 !== n.index0AttributeName ? a.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && a.bindAttribLocation(v, 0, "position"), a.linkProgram(v), t.debug.checkShaderErrors && (y = a.getProgramInfoLog(v).trim(), _ = a.getShaderInfoLog(d).trim(), l = a.getShaderInfoLog(u).trim(), !(c = s = !0) === a.getProgramParameter(v, 35714) ? (s = !1, p = Wa(a, d, "vertex"), t = Wa(a, u, "fragment"), console.error("THREE.WebGLProgram: shader error: ", a.getError(), "35715", a.getProgramParameter(v, 35715), "gl.getProgramInfoLog", y, p, t)) : "" !== y ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", y) : "" !== _ && "" !== l || (c = !1), c && (this.diagnostics = { runnable: s, programLog: y, vertexShader: { log: _, prefix: i }, fragmentShader: { log: l, prefix: o } })), a.deleteShader(d), a.deleteShader(u), this.getUniforms = function() { return void 0 === x && (x = new ka(a, v)), x }, this.getAttributes = function() {
            return void 0 === b && (b = function(t, e) {
                for (var n = {}, r = t.getProgramParameter(e, 35721), i = 0; i < r; i++) {
                    var o = t.getActiveAttrib(e, i).name;
                    n[o] = t.getAttribLocation(e, o)
                }
                return n
            }(a, v)), b
        }, this.destroy = function() { r.releaseStatesOfProgram(this), a.deleteProgram(v), this.program = void 0 }, this.name = n.shaderName, this.id = Va++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = d, this.fragmentShader = u, this
    }

    function as(h, p, d, f, a, m) {
        var s = [],
            g = f.isWebGL2,
            v = f.logarithmicDepthBuffer,
            y = f.floatVertexTextures,
            _ = f.maxVertexUniforms,
            x = f.vertexTextures,
            b = f.precision,
            w = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
            i = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

        function M(t) { var e; return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = an, e }
        return {
            getParameters: function(t, e, n, r, i) {
                var o, a, s = r.fog,
                    c = t.isMeshStandardMaterial ? r.environment : null,
                    r = p.get(t.envMap || c),
                    c = w[t.type],
                    l = i.isSkinnedMesh ? (l = (a = i).skeleton.bones, y ? 1024 : (a = Math.floor((_ - 20) / 4), (a = Math.min(a, l.length)) < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " + a + "."), 0) : a)) : 0;
                null !== t.precision && (b = f.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", b, "instead."), a = c ? (o = (u = Co[c]).vertexShader, u.fragmentShader) : (o = t.vertexShader, t.fragmentShader);
                var u = h.getRenderTarget();
                return { isWebGL2: g, shaderID: c, shaderName: t.type, vertexShader: o, fragmentShader: a, defines: t.defines, isRawShaderMaterial: !0 === t.isRawShaderMaterial, glslVersion: t.glslVersion, precision: b, instancing: !0 === i.isInstancedMesh, instancingColor: !0 === i.isInstancedMesh && null !== i.instanceColor, supportsVertexTextures: x, outputEncoding: null !== u ? M(u.texture) : h.outputEncoding, map: !!t.map, mapEncoding: M(t.map), matcap: !!t.matcap, matcapEncoding: M(t.matcap), envMap: !!r, envMapMode: r && r.mapping, envMapEncoding: M(r), envMapCubeUV: !!r && (r.mapping === Ct || r.mapping === Pt), lightMap: !!t.lightMap, lightMapEncoding: M(t.lightMap), aoMap: !!t.aoMap, emissiveMap: !!t.emissiveMap, emissiveMapEncoding: M(t.emissiveMap), bumpMap: !!t.bumpMap, normalMap: !!t.normalMap, objectSpaceNormalMap: t.normalMapType === vn, tangentSpaceNormalMap: t.normalMapType === gn, clearcoatMap: !!t.clearcoatMap, clearcoatRoughnessMap: !!t.clearcoatRoughnessMap, clearcoatNormalMap: !!t.clearcoatNormalMap, displacementMap: !!t.displacementMap, roughnessMap: !!t.roughnessMap, metalnessMap: !!t.metalnessMap, specularMap: !!t.specularMap, alphaMap: !!t.alphaMap, gradientMap: !!t.gradientMap, sheen: !!t.sheen, transmissionMap: !!t.transmissionMap, combine: t.combine, vertexTangents: t.normalMap && t.vertexTangents, vertexColors: t.vertexColors, vertexUvs: !!(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatMap || t.clearcoatRoughnessMap || t.clearcoatNormalMap || t.displacementMap || t.transmissionMap), uvsVertexOnly: !(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatNormalMap || t.transmissionMap || !t.displacementMap), fog: !!s, useFog: t.fog, fogExp2: s && s.isFogExp2, flatShading: t.flatShading, sizeAttenuation: t.sizeAttenuation, logarithmicDepthBuffer: v, skinning: t.skinning && 0 < l, maxBones: l, useVertexTexture: y, morphTargets: t.morphTargets, morphNormals: t.morphNormals, maxMorphTargets: h.maxMorphTargets, maxMorphNormals: h.maxMorphNormals, numDirLights: e.directional.length, numPointLights: e.point.length, numSpotLights: e.spot.length, numRectAreaLights: e.rectArea.length, numHemiLights: e.hemi.length, numDirLightShadows: e.directionalShadowMap.length, numPointLightShadows: e.pointShadowMap.length, numSpotLightShadows: e.spotShadowMap.length, numClippingPlanes: m.numPlanes, numClipIntersection: m.numIntersection, dithering: t.dithering, shadowMapEnabled: h.shadowMap.enabled && 0 < n.length, shadowMapType: h.shadowMap.type, toneMapping: t.toneMapped ? h.toneMapping : Et, physicallyCorrectLights: h.physicallyCorrectLights, premultipliedAlpha: t.premultipliedAlpha, alphaTest: t.alphaTest, doubleSided: t.side === Y, flipSided: t.side === j, depthPacking: void 0 !== t.depthPacking && t.depthPacking, index0AttributeName: t.index0AttributeName, extensionDerivatives: t.extensions && t.extensions.derivatives, extensionFragDepth: t.extensions && t.extensions.fragDepth, extensionDrawBuffers: t.extensions && t.extensions.drawBuffers, extensionShaderTextureLOD: t.extensions && t.extensions.shaderTextureLOD, rendererExtensionFragDepth: g || d.has("EXT_frag_depth"), rendererExtensionDrawBuffers: g || d.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: g || d.has("EXT_shader_texture_lod"), customProgramCacheKey: t.customProgramCacheKey() }
            },
            getProgramCacheKey: function(t) {
                var e = [];
                if (t.shaderID ? e.push(t.shaderID) : (e.push(t.fragmentShader), e.push(t.vertexShader)), void 0 !== t.defines)
                    for (var n in t.defines) e.push(n), e.push(t.defines[n]);
                if (!1 === t.isRawShaderMaterial) {
                    for (var r = 0; r < i.length; r++) e.push(t[i[r]]);
                    e.push(h.outputEncoding), e.push(h.gammaFactor)
                }
                return e.push(t.customProgramCacheKey), e.join()
            },
            getUniforms: function(t) { var e = w[t.type]; return e ? (e = Co[e], ho.clone(e.uniforms)) : t.uniforms },
            acquireProgram: function(t, e) { for (var n, r = 0, i = s.length; r < i; r++) { var o = s[r]; if (o.cacheKey === e) {++(n = o).usedTimes; break } } return void 0 === n && (n = new os(h, e, t, a), s.push(n)), n },
            releaseProgram: function(t) {
                var e;
                0 == --t.usedTimes && (e = s.indexOf(t), s[e] = s[s.length - 1], s.pop(), t.destroy())
            },
            programs: s
        }
    }

    function ss() { var r = new WeakMap; return { get: function(t) { var e = r.get(t); return void 0 === e && (e = {}, r.set(t, e)), e }, remove: function(t) { r.delete(t) }, update: function(t, e, n) { r.get(t)[e] = n }, dispose: function() { r = new WeakMap } } }

    function cs(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id }

    function ls(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id }

    function us(c) {
        var l = [],
            u = 0,
            a = [],
            s = [],
            h = { id: -1 };

        function p(t, e, n, r, i, o) {
            var a = l[u],
                s = c.get(n);
            return void 0 === a ? (a = { id: t.id, object: t, geometry: e, material: n, program: s.program || h, groupOrder: r, renderOrder: t.renderOrder, z: i, group: o }, l[u] = a) : (a.id = t.id, a.object = t, a.geometry = e, a.material = n, a.program = s.program || h, a.groupOrder = r, a.renderOrder = t.renderOrder, a.z = i, a.group = o), u++, a
        }
        return {
            opaque: a,
            transparent: s,
            init: function() { u = 0, a.length = 0, s.length = 0 },
            push: function(t, e, n, r, i, o) { o = p(t, e, n, r, i, o), (!0 === n.transparent ? s : a).push(o) },
            unshift: function(t, e, n, r, i, o) { o = p(t, e, n, r, i, o), (!0 === n.transparent ? s : a).unshift(o) },
            finish: function() {
                for (var t = u, e = l.length; t < e; t++) {
                    var n = l[t];
                    if (null === n.id) break;
                    n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                }
            },
            sort: function(t, e) { 1 < a.length && a.sort(t || cs), 1 < s.length && s.sort(e || ls) }
        }
    }

    function hs(i) { var o = new WeakMap; return { get: function(t, e) { var n, r = o.get(t); return void 0 === r ? (n = new us(i), o.set(t, new WeakMap), o.get(t).set(e, n)) : void 0 === (n = r.get(e)) && (n = new us(i), r.set(e, n)), n }, dispose: function() { o = new WeakMap } } }

    function ps() {
        var n = {};
        return {
            get: function(t) {
                if (void 0 !== n[t.id]) return n[t.id];
                var e;
                switch (t.type) {
                    case "DirectionalLight":
                        e = { direction: new kn, color: new li };
                        break;
                    case "SpotLight":
                        e = { position: new kn, direction: new kn, color: new li, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                        break;
                    case "PointLight":
                        e = { position: new kn, color: new li, distance: 0, decay: 0 };
                        break;
                    case "HemisphereLight":
                        e = { direction: new kn, skyColor: new li, groundColor: new li };
                        break;
                    case "RectAreaLight":
                        e = { color: new li, position: new kn, halfWidth: new kn, halfHeight: new kn }
                }
                return n[t.id] = e
            }
        }
    }
    var ds = 0;

    function fs(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) }

    function ms() {
        for (var n, R = new ps, C = (n = {}, {
                get: function(t) {
                    if (void 0 !== n[t.id]) return n[t.id];
                    var e;
                    switch (t.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Ln };
                            break;
                        case "PointLight":
                            e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Ln, shadowCameraNear: 1, shadowCameraFar: 1e3 }
                    }
                    return n[t.id] = e
                }
            }), P = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, t = 0; t < 9; t++) P.probe.push(new kn);
        var O = new kn,
            I = new mr,
            D = new mr;
        return {
            setup: function(t, e, n) {
                for (var r = 0, i = 0, o = 0, a = 0; a < 9; a++) P.probe[a].set(0, 0, 0);
                var s = 0,
                    c = 0,
                    l = 0,
                    u = 0,
                    h = 0,
                    p = 0,
                    d = 0,
                    f = 0,
                    m = n.matrixWorldInverse;
                t.sort(fs);
                for (var g = 0, v = t.length; g < v; g++) {
                    var y, _, x, b, w, M = t[g],
                        S = M.color,
                        E = M.intensity,
                        T = M.distance,
                        A = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
                    if (M.isAmbientLight) r += S.r * E, i += S.g * E, o += S.b * E;
                    else if (M.isLightProbe)
                        for (var L = 0; L < 9; L++) P.probe[L].addScaledVector(M.sh.coefficients[L], E);
                    else M.isDirectionalLight ? ((x = R.get(M)).color.copy(M.color).multiplyScalar(M.intensity), x.direction.setFromMatrixPosition(M.matrixWorld), O.setFromMatrixPosition(M.target.matrixWorld), x.direction.sub(O), x.direction.transformDirection(m), M.castShadow && (y = M.shadow, (_ = C.get(M)).shadowBias = y.bias, _.shadowNormalBias = y.normalBias, _.shadowRadius = y.radius, _.shadowMapSize = y.mapSize, P.directionalShadow[s] = _, P.directionalShadowMap[s] = A, P.directionalShadowMatrix[s] = M.shadow.matrix, p++), P.directional[s] = x, s++) : M.isSpotLight ? ((_ = R.get(M)).position.setFromMatrixPosition(M.matrixWorld), _.position.applyMatrix4(m), _.color.copy(S).multiplyScalar(E), _.distance = T, _.direction.setFromMatrixPosition(M.matrixWorld), O.setFromMatrixPosition(M.target.matrixWorld), _.direction.sub(O), _.direction.transformDirection(m), _.coneCos = Math.cos(M.angle), _.penumbraCos = Math.cos(M.angle * (1 - M.penumbra)), _.decay = M.decay, M.castShadow && (x = M.shadow, (T = C.get(M)).shadowBias = x.bias, T.shadowNormalBias = x.normalBias, T.shadowRadius = x.radius, T.shadowMapSize = x.mapSize, P.spotShadow[l] = T, P.spotShadowMap[l] = A, P.spotShadowMatrix[l] = M.shadow.matrix, f++), P.spot[l] = _, l++) : M.isRectAreaLight ? ((b = R.get(M)).color.copy(S).multiplyScalar(E), b.position.setFromMatrixPosition(M.matrixWorld), b.position.applyMatrix4(m), D.identity(), I.copy(M.matrixWorld), I.premultiply(m), D.extractRotation(I), b.halfWidth.set(.5 * M.width, 0, 0), b.halfHeight.set(0, .5 * M.height, 0), b.halfWidth.applyMatrix4(D), b.halfHeight.applyMatrix4(D), P.rectArea[u] = b, u++) : M.isPointLight ? ((w = R.get(M)).position.setFromMatrixPosition(M.matrixWorld), w.position.applyMatrix4(m), w.color.copy(M.color).multiplyScalar(M.intensity), w.distance = M.distance, w.decay = M.decay, M.castShadow && (S = M.shadow, (b = C.get(M)).shadowBias = S.bias, b.shadowNormalBias = S.normalBias, b.shadowRadius = S.radius, b.shadowMapSize = S.mapSize, b.shadowCameraNear = S.camera.near, b.shadowCameraFar = S.camera.far, P.pointShadow[c] = b, P.pointShadowMap[c] = A, P.pointShadowMatrix[c] = M.shadow.matrix, d++), P.point[c] = w, c++) : M.isHemisphereLight && ((w = R.get(M)).direction.setFromMatrixPosition(M.matrixWorld), w.direction.transformDirection(m), w.direction.normalize(), w.skyColor.copy(M.color).multiplyScalar(E), w.groundColor.copy(M.groundColor).multiplyScalar(E), P.hemi[h] = w, h++)
                }
                0 < u && (P.rectAreaLTC1 = Ro.LTC_1, P.rectAreaLTC2 = Ro.LTC_2), P.ambient[0] = r, P.ambient[1] = i, P.ambient[2] = o, (n = P.hash).directionalLength === s && n.pointLength === c && n.spotLength === l && n.rectAreaLength === u && n.hemiLength === h && n.numDirectionalShadows === p && n.numPointShadows === d && n.numSpotShadows === f || (P.directional.length = s, P.spot.length = l, P.rectArea.length = u, P.point.length = c, P.hemi.length = h, P.directionalShadow.length = p, P.directionalShadowMap.length = p, P.pointShadow.length = d, P.pointShadowMap.length = d, P.spotShadow.length = f, P.spotShadowMap.length = f, P.directionalShadowMatrix.length = p, P.pointShadowMatrix.length = d, P.spotShadowMatrix.length = f, n.directionalLength = s, n.pointLength = c, n.spotLength = l, n.rectAreaLength = u, n.hemiLength = h, n.numDirectionalShadows = p, n.numPointShadows = d, n.numSpotShadows = f, P.version = ds++)
            },
            state: P
        }
    }

    function gs() {
        var e = new ms,
            n = [],
            r = [];
        return { init: function() { n.length = 0, r.length = 0 }, state: { lightsArray: n, shadowsArray: r, lights: e }, setupLights: function(t) { e.setup(n, r, t) }, pushLight: function(t) { n.push(t) }, pushShadow: function(t) { r.push(t) } }
    }

    function vs() { var r = new WeakMap; return { get: function(t, e) { var n; return !1 === r.has(t) ? (n = new gs, r.set(t, new WeakMap), r.get(t).set(e, n)) : !1 === r.get(t).has(e) ? (n = new gs, r.get(t).set(e, n)) : n = r.get(t).get(e), n }, dispose: function() { r = new WeakMap } } }

    function ys(t) { pi.call(this), this.type = "MeshDepthMaterial", this.depthPacking = fn, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) }

    function _s(t) { pi.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new kn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) }((ys.prototype = Object.create(pi.prototype)).constructor = ys).prototype.isMeshDepthMaterial = !0, ys.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, ((_s.prototype = Object.create(pi.prototype)).constructor = _s).prototype.isMeshDistanceMaterial = !0, _s.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this };
    var xs = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
        bs = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

    function ws(v, y, _) {
        var x = new Mo,
            b = new Ln,
            w = new Ln,
            M = new Nn,
            i = [],
            o = [],
            p = {},
            d = { 0: j, 1: X, 2: Y },
            S = new mo({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Ln }, radius: { value: 4 } }, vertexShader: bs, fragmentShader: xs }),
            E = S.clone();
        E.defines.HORIZONAL_PASS = 1;
        var t = new Ni;
        t.setAttribute("position", new gi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        var T = new $i(t, S),
            A = this;

        function f(t, e, n) {
            var r = t << 0 | e << 1 | n << 2,
                n = i[r];
            return void 0 === n && (n = new ys({ depthPacking: mn, morphTargets: t, skinning: e }), i[r] = n), n
        }

        function m(t, e, n) {
            var r = t << 0 | e << 1 | n << 2,
                n = o[r];
            return void 0 === n && (n = new _s({ morphTargets: t, skinning: e }), o[r] = n), n
        }

        function L(t, e, n, r, i, o, a) {
            var s, c, l = null,
                u = f,
                h = t.customDepthMaterial;
            return !0 === r.isPointLight && (u = m, h = t.customDistanceMaterial), l = void 0 === h ? (!(s = !1) === n.morphTargets && (s = e.morphAttributes && e.morphAttributes.position && 0 < e.morphAttributes.position.length), !(c = !1) === t.isSkinnedMesh && (!0 === n.skinning ? c = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)), u(s, c, !0 === t.isInstancedMesh)) : h, v.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length && (c = l.uuid, t = n.uuid, void 0 === (h = p[c]) && (h = {}, p[c] = h), void 0 === (c = h[t]) && (c = l.clone(), h[t] = c), l = c), l.visible = n.visible, l.wireframe = n.wireframe, l.side = a === D ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], l.clipShadows = n.clipShadows, l.clippingPlanes = n.clippingPlanes, l.clipIntersection = n.clipIntersection, l.wireframeLinewidth = n.wireframeLinewidth, l.linewidth = n.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = i, l.farDistance = o), l
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = O, this.render = function(t, e, n) {
            if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== t.length) {
                var r = v.getRenderTarget(),
                    i = v.getActiveCubeFace(),
                    o = v.getActiveMipmapLevel(),
                    a = v.state;
                a.setBlending(W), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1);
                for (var s = 0, c = t.length; s < c; s++) {
                    var l = t[s],
                        u = l.shadow;
                    if (!1 !== u.autoUpdate || !1 !== u.needsUpdate)
                        if (void 0 !== u) {
                            b.copy(u.mapSize);
                            var h, p, d = u.getFrameExtents();
                            b.multiply(d), w.copy(u.mapSize), (b.x > _ || b.y > _) && (b.x > _ && (w.x = Math.floor(_ / d.x), b.x = w.x * d.x, u.mapSize.x = w.x), b.y > _ && (w.y = Math.floor(_ / d.y), b.y = w.y * d.y, u.mapSize.y = w.y)), null !== u.map || u.isPointLightShadow || this.type !== D || (h = { minFilter: Ut, magFilter: Ut, format: ee }, u.map = new Fn(b.x, b.y, h), u.map.texture.name = l.name + ".shadowMap", u.mapPass = new Fn(b.x, b.y, h), u.camera.updateProjectionMatrix()), null === u.map && (p = { minFilter: Nt, magFilter: Nt, format: ee }, u.map = new Fn(b.x, b.y, p), u.map.texture.name = l.name + ".shadowMap", u.camera.updateProjectionMatrix()), v.setRenderTarget(u.map), v.clear();
                            for (var f = u.getViewportCount(), m = 0; m < f; m++) {
                                var g = u.getViewport(m);
                                M.set(w.x * g.x, w.y * g.y, w.x * g.z, w.y * g.w), a.viewport(M), u.updateMatrices(l, m), x = u.getFrustum(),
                                    function t(e, n, r, i, o) {
                                        if (!1 === e.visible) return;
                                        var a = e.layers.test(n.layers);
                                        if (a && (e.isMesh || e.isLine || e.isPoints) && (e.castShadow || e.receiveShadow && o === D) && (!e.frustumCulled || x.intersectsObject(e))) {
                                            e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld);
                                            var s = y.update(e),
                                                c = e.material;
                                            if (Array.isArray(c))
                                                for (var l = s.groups, u = 0, h = l.length; u < h; u++) {
                                                    var p = l[u],
                                                        d = c[p.materialIndex];
                                                    d && d.visible && (d = L(e, s, d, i, r.near, r.far, o), v.renderBufferDirect(r, null, s, d, e, p))
                                                } else c.visible && (a = L(e, s, c, i, r.near, r.far, o), v.renderBufferDirect(r, null, s, a, e, null))
                                        }
                                        var f = e.children;
                                        for (var m = 0, g = f.length; m < g; m++) t(f[m], n, r, i, o)
                                    }(e, n, u.camera, l, this.type)
                            }
                            u.isPointLightShadow || this.type !== D || (d = u, h = n, p = void 0, p = y.update(T), S.uniforms.shadow_pass.value = d.map.texture, S.uniforms.resolution.value = d.mapSize, S.uniforms.radius.value = d.radius, v.setRenderTarget(d.mapPass), v.clear(), v.renderBufferDirect(h, null, p, S, T, null), E.uniforms.shadow_pass.value = d.mapPass.texture, E.uniforms.resolution.value = d.mapSize, E.uniforms.radius.value = d.radius, v.setRenderTarget(d.map), v.clear(), v.renderBufferDirect(h, null, p, E, T, null)), u.needsUpdate = !1
                        } else console.warn("THREE.WebGLShadowMap:", l, "has no shadow.")
                }
                A.needsUpdate = !1, v.setRenderTarget(r, i, o)
            }
        }
    }

    function Ms(u, t, e) {
        var n = e.isWebGL2;
        var r = new function() {
                var e = !1,
                    o = new Nn,
                    n = null,
                    a = new Nn(0, 0, 0, 0);
                return { setMask: function(t) { n === t || e || (u.colorMask(t, t, t, t), n = t) }, setLocked: function(t) { e = t }, setClear: function(t, e, n, r, i) {!0 === i && (t *= r, e *= r, n *= r), o.set(t, e, n, r), !1 === a.equals(o) && (u.clearColor(t, e, n, r), a.copy(o)) }, reset: function() { e = !1, n = null, a.set(-1, 0, 0, 0) } }
            },
            i = new function() {
                var e = !1,
                    n = null,
                    r = null,
                    i = null;
                return {
                    setTest: function(t) {
                        (t ? O : I)(2929)
                    },
                    setMask: function(t) { n === t || e || (u.depthMask(t), n = t) },
                    setFunc: function(t) {
                        if (r !== t) {
                            if (t) switch (t) {
                                case mt:
                                    u.depthFunc(512);
                                    break;
                                case gt:
                                    u.depthFunc(519);
                                    break;
                                case vt:
                                    u.depthFunc(513);
                                    break;
                                case yt:
                                    u.depthFunc(515);
                                    break;
                                case _t:
                                    u.depthFunc(514);
                                    break;
                                case xt:
                                    u.depthFunc(518);
                                    break;
                                case bt:
                                    u.depthFunc(516);
                                    break;
                                case wt:
                                    u.depthFunc(517);
                                    break;
                                default:
                                    u.depthFunc(515)
                            } else u.depthFunc(515);
                            r = t
                        }
                    },
                    setLocked: function(t) { e = t },
                    setClear: function(t) { i !== t && (u.clearDepth(t), i = t) },
                    reset: function() { e = !1, i = r = n = null }
                }
            },
            o = new function() {
                var e = !1,
                    n = null,
                    r = null,
                    i = null,
                    o = null,
                    a = null,
                    s = null,
                    c = null,
                    l = null;
                return { setTest: function(t) { e || (t ? O : I)(2960) }, setMask: function(t) { n === t || e || (u.stencilMask(t), n = t) }, setFunc: function(t, e, n) { r === t && i === e && o === n || (u.stencilFunc(t, e, n), r = t, i = e, o = n) }, setOp: function(t, e, n) { a === t && s === e && c === n || (u.stencilOp(t, e, n), a = t, s = e, c = n) }, setLocked: function(t) { e = t }, setClear: function(t) { l !== t && (u.clearStencil(t), l = t) }, reset: function() { e = !1, l = c = s = a = o = i = r = n = null } }
            },
            a = {},
            s = null,
            c = null,
            l = null,
            h = null,
            p = null,
            d = null,
            f = null,
            m = null,
            g = null,
            v = !1,
            y = null,
            _ = null,
            x = null,
            b = null,
            w = null,
            M = u.getParameter(35661),
            S = !1,
            E = 0,
            e = u.getParameter(7938); - 1 !== e.indexOf("WebGL") ? (E = parseFloat(/^WebGL\ ([0-9])/.exec(e)[1]), S = 1 <= E) : -1 !== e.indexOf("OpenGL ES") && (E = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(e)[1]), S = 2 <= E);
        var T = null,
            A = {},
            L = new Nn,
            R = new Nn;

        function C(t, e, n) {
            var r = new Uint8Array(4),
                i = u.createTexture();
            u.bindTexture(t, i), u.texParameteri(t, 10241, 9728), u.texParameteri(t, 10240, 9728);
            for (var o = 0; o < n; o++) u.texImage2D(e + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return i
        }
        var P = {};

        function O(t) {!0 !== a[t] && (u.enable(t), a[t] = !0) }

        function I(t) {!1 !== a[t] && (u.disable(t), a[t] = !1) }
        P[3553] = C(3553, 3553, 1), P[34067] = C(34067, 34069, 6), r.setClear(0, 0, 0, 1), i.setClear(1), o.setClear(0), O(2929), i.setFunc(yt), F(!1), U(G), O(2884), B(W);
        var D = {};
        D[$] = 32774, D[tt] = 32778, D[et] = 32779, n ? (D[nt] = 32775, D[rt] = 32776) : null !== (t = t.get("EXT_blend_minmax")) && (D[nt] = t.MIN_EXT, D[rt] = t.MAX_EXT);
        var N = {};

        function B(t, e, n, r, i, o, a, s) {
            if (t !== W) {
                if (c || (O(3042), c = !0), t === Q) i = i || e, o = o || n, a = a || r, e === h && i === f || (u.blendEquationSeparate(D[e], D[i]), h = e, f = i), n === p && r === d && o === m && a === g || (u.blendFuncSeparate(N[n], N[r], N[o], N[a]), p = n, d = r, m = o, g = a), l = t, v = null;
                else if (t !== l || s !== v) {
                    if (h === $ && f === $ || (u.blendEquation(32774), f = h = $), s) switch (t) {
                        case q:
                            u.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case Z:
                            u.blendFunc(1, 1);
                            break;
                        case J:
                            u.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case K:
                            u.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    } else switch (t) {
                        case q:
                            u.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case Z:
                            u.blendFunc(770, 1);
                            break;
                        case J:
                            u.blendFunc(0, 769);
                            break;
                        case K:
                            u.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                    g = m = d = p = null, l = t, v = s
                }
            } else c && (I(3042), c = !1)
        }

        function F(t) { y !== t && (t ? u.frontFace(2304) : u.frontFace(2305), y = t) }

        function U(t) { t !== k ? (O(2884), t !== _ && (t === G ? u.cullFace(1029) : t === V ? u.cullFace(1028) : u.cullFace(1032))) : I(2884), _ = t }

        function z(t, e, n) { t ? (O(32823), b === e && w === n || (u.polygonOffset(e, n), b = e, w = n)) : I(32823) }

        function H(t) { void 0 === t && (t = 33984 + M - 1), T !== t && (u.activeTexture(t), T = t) }
        return N[it] = 0, N[ot] = 1, N[at] = 768, N[ct] = 770, N[ft] = 776, N[pt] = 774, N[ut] = 772, N[st] = 769, N[lt] = 771, N[dt] = 775, N[ht] = 773, {
            buffers: { color: r, depth: i, stencil: o },
            enable: O,
            disable: I,
            useProgram: function(t) { return s !== t && (u.useProgram(t), s = t, !0) },
            setBlending: B,
            setMaterial: function(t, e) {
                (t.side === Y ? I : O)(2884);
                var n = t.side === j;
                e && (n = !n), F(n), t.blending === q && !1 === t.transparent ? B(W) : B(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), i.setFunc(t.depthFunc), i.setTest(t.depthTest), i.setMask(t.depthWrite), r.setMask(t.colorWrite), n = t.stencilWrite, o.setTest(n), n && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), z(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            },
            setFlipSided: F,
            setCullFace: U,
            setLineWidth: function(t) { t !== x && (S && u.lineWidth(t), x = t) },
            setPolygonOffset: z,
            setScissorTest: function(t) {
                (t ? O : I)(3089)
            },
            activeTexture: H,
            bindTexture: function(t, e) {
                null === T && H();
                var n = A[T];
                void 0 === n && (n = { type: void 0, texture: void 0 }, A[T] = n), n.type === t && n.texture === e || (u.bindTexture(t, e || P[t]), n.type = t, n.texture = e)
            },
            unbindTexture: function() {
                var t = A[T];
                void 0 !== t && void 0 !== t.type && (u.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
            },
            compressedTexImage2D: function() { try { u.compressedTexImage2D.apply(u, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
            texImage2D: function() { try { u.texImage2D.apply(u, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
            texImage3D: function() { try { u.texImage3D.apply(u, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
            scissor: function(t) {!1 === L.equals(t) && (u.scissor(t.x, t.y, t.z, t.w), L.copy(t)) },
            viewport: function(t) {!1 === R.equals(t) && (u.viewport(t.x, t.y, t.z, t.w), R.copy(t)) },
            reset: function() { a = {}, A = {}, _ = y = l = s = T = null, r.reset(), i.reset(), o.reset() }
        }
    }

    function Ss(b, r, w, M, i, S, l) {
        var o, E = i.isWebGL2,
            e = i.maxTextures,
            T = i.maxCubemapSize,
            g = i.maxTextureSize,
            n = i.maxSamples,
            a = new WeakMap,
            s = !1;
        try { s = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) {}

        function c(t, e) { return s ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") }

        function A(t, e, n, r) {
            var i = 1;
            if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    r = e ? An.floorPowerOfTwo : Math.floor, e = r(i * t.width), i = r(i * t.height);
                    void 0 === o && (o = c(e, i));
                    n = n ? c(e, i) : o;
                    return n.width = e, n.height = i, n.getContext("2d").drawImage(t, 0, 0, e, i), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + e + "x" + i + ")."), n
                }
                return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
            }
            return t
        }

        function L(t) { return An.isPowerOfTwo(t.width) && An.isPowerOfTwo(t.height) }

        function R(t, e) { return t.generateMipmaps && e && t.minFilter !== Nt && t.minFilter !== Ut }

        function C(t, e, n, r) { b.generateMipmap(t), M.get(e).__maxMipLevel = Math.log(Math.max(n, r)) * Math.LOG2E }

        function P(t, e, n) {
            if (!1 === E) return e;
            if (null !== t) {
                if (void 0 !== b[t]) return b[t];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + t + "'")
            }
            t = e;
            return 6403 === e && (5126 === n && (t = 33326), 5131 === n && (t = 33325), 5121 === n && (t = 33321)), 6407 === e && (5126 === n && (t = 34837), 5131 === n && (t = 34843), 5121 === n && (t = 32849)), 6408 === e && (5126 === n && (t = 34836), 5131 === n && (t = 34842), 5121 === n && (t = 32856)), 33325 !== t && 33326 !== t && 34842 !== t && 34836 !== t || r.get("EXT_color_buffer_float"), t
        }

        function u(t) { return t === Nt || t === Bt || t === Ft ? 9728 : 9729 }

        function h(t) {
            t = t.target;
            t.removeEventListener("dispose", h),
                function(t) {
                    var e = M.get(t);
                    if (void 0 === e.__webglInit) return;
                    b.deleteTexture(e.__webglTexture), M.remove(t)
                }(t), t.isVideoTexture && a.delete(t), l.memory.textures--
        }

        function p(t) {
            t = t.target;
            t.removeEventListener("dispose", p),
                function(t) {
                    var e = M.get(t),
                        n = M.get(t.texture);
                    if (!t) return;
                    void 0 !== n.__webglTexture && b.deleteTexture(n.__webglTexture);
                    t.depthTexture && t.depthTexture.dispose();
                    if (t.isWebGLCubeRenderTarget)
                        for (var r = 0; r < 6; r++) b.deleteFramebuffer(e.__webglFramebuffer[r]), e.__webglDepthbuffer && b.deleteRenderbuffer(e.__webglDepthbuffer[r]);
                    else b.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && b.deleteRenderbuffer(e.__webglDepthbuffer), e.__webglMultisampledFramebuffer && b.deleteFramebuffer(e.__webglMultisampledFramebuffer), e.__webglColorRenderbuffer && b.deleteRenderbuffer(e.__webglColorRenderbuffer), e.__webglDepthRenderbuffer && b.deleteRenderbuffer(e.__webglDepthRenderbuffer);
                    M.remove(t.texture), M.remove(t)
                }(t), l.memory.textures--
        }
        var d = 0;

        function f(t, e) {
            var n, r = M.get(t);
            if (t.isVideoTexture && (i = t, n = l.render.frame, a.get(i) !== n && (a.set(i, n), i.update())), 0 < t.version && r.__version !== t.version) {
                var i = t.image;
                if (void 0 === i) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== i.complete) return void x(r, t, e);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            w.activeTexture(33984 + e), w.bindTexture(3553, r.__webglTexture)
        }

        function m(t, e) {
            if (6 === t.image.length) {
                var n = M.get(t);
                if (0 < t.version && n.__version !== t.version) {
                    I(n, t), w.activeTexture(33984 + e), w.bindTexture(34067, n.__webglTexture), b.pixelStorei(37440, t.flipY);
                    for (var r = t && (t.isCompressedTexture || t.image[0].isCompressedTexture), i = t.image[0] && t.image[0].isDataTexture, o = [], a = 0; a < 6; a++) o[a] = r || i ? i ? t.image[a].image : t.image[a] : A(t.image[a], !1, !0, T);
                    var s, c = o[0],
                        l = L(c) || E,
                        u = S.convert(t.format),
                        h = S.convert(t.type),
                        p = P(t.internalFormat, u, h);
                    if (O(34067, t, l), r) {
                        for (var d = 0; d < 6; d++) {
                            s = o[d].mipmaps;
                            for (var f = 0; f < s.length; f++) {
                                var m = s[f];
                                t.format !== ee && t.format !== te ? null !== u ? w.compressedTexImage2D(34069 + d, f, p, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : w.texImage2D(34069 + d, f, p, m.width, m.height, 0, u, h, m.data)
                            }
                        }
                        n.__maxMipLevel = s.length - 1
                    } else {
                        s = t.mipmaps;
                        for (var g = 0; g < 6; g++)
                            if (i) {
                                w.texImage2D(34069 + g, 0, p, o[g].width, o[g].height, 0, u, h, o[g].data);
                                for (var v = 0; v < s.length; v++) {
                                    var y = s[v].image[g].image;
                                    w.texImage2D(34069 + g, v + 1, p, y.width, y.height, 0, u, h, y.data)
                                }
                            } else {
                                w.texImage2D(34069 + g, 0, p, u, h, o[g]);
                                for (var _ = 0; _ < s.length; _++) {
                                    var x = s[_];
                                    w.texImage2D(34069 + g, _ + 1, p, u, h, x.image[g])
                                }
                            }
                        n.__maxMipLevel = s.length
                    }
                    R(t, l) && C(34067, t, c.width, c.height), n.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else w.activeTexture(33984 + e), w.bindTexture(34067, n.__webglTexture)
            }
        }

        function v(t, e) { w.activeTexture(33984 + e), w.bindTexture(34067, M.get(t).__webglTexture) }
        var y = {};
        y[Ot] = 10497, y[It] = 33071, y[Dt] = 33648;
        var _ = {};

        function O(t, e, n) {
            n ? (b.texParameteri(t, 10242, y[e.wrapS]), b.texParameteri(t, 10243, y[e.wrapT]), 32879 !== t && 35866 !== t || b.texParameteri(t, 32882, y[e.wrapR]), b.texParameteri(t, 10240, _[e.magFilter]), b.texParameteri(t, 10241, _[e.minFilter])) : (b.texParameteri(t, 10242, 33071), b.texParameteri(t, 10243, 33071), 32879 !== t && 35866 !== t || b.texParameteri(t, 32882, 33071), e.wrapS === It && e.wrapT === It || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), b.texParameteri(t, 10240, u(e.magFilter)), b.texParameteri(t, 10241, u(e.minFilter)), e.minFilter !== Nt && e.minFilter !== Ut && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            n = r.get("EXT_texture_filter_anisotropic");
            n && (e.type === Xt && null === r.get("OES_texture_float_linear") || e.type === Yt && null === (E || r.get("OES_texture_half_float_linear")) || (1 < e.anisotropy || M.get(e).__currentAnisotropy) && (b.texParameterf(t, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, i.getMaxAnisotropy())), M.get(e).__currentAnisotropy = e.anisotropy))
        }

        function I(t, e) { void 0 === t.__webglInit && (t.__webglInit = !0, e.addEventListener("dispose", h), t.__webglTexture = b.createTexture(), l.memory.textures++) }

        function x(t, e, n) {
            var r = 3553;
            e.isDataTexture2DArray && (r = 35866), e.isDataTexture3D && (r = 32879), I(t, e), w.activeTexture(33984 + n), w.bindTexture(r, t.__webglTexture), b.pixelStorei(37440, e.flipY), b.pixelStorei(37441, e.premultiplyAlpha), b.pixelStorei(3317, e.unpackAlignment);
            var i, n = (o = e, !E && (o.wrapS !== It || o.wrapT !== It || o.minFilter !== Nt && o.minFilter !== Ut) && !1 === L(e.image)),
                o = A(e.image, n, !1, g),
                n = L(o) || E,
                a = S.convert(e.format),
                s = S.convert(e.type),
                c = P(e.internalFormat, a, s);
            O(r, e, n);
            var l = e.mipmaps;
            if (e.isDepthTexture) c = 6402, E ? c = e.type === Xt ? 36012 : e.type === qt ? 33190 : e.type === Qt ? 35056 : 33189 : e.type === Xt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), e.format === oe && 6402 === c && e.type !== jt && e.type !== qt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), e.type = jt, s = S.convert(e.type)), e.format === ae && 6402 === c && (c = 34041, e.type !== Qt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), e.type = Qt, s = S.convert(e.type))), w.texImage2D(3553, 0, c, o.width, o.height, 0, a, s, null);
            else if (e.isDataTexture)
                if (0 < l.length && n) {
                    for (var u = 0, h = l.length; u < h; u++) i = l[u], w.texImage2D(3553, u, c, i.width, i.height, 0, a, s, i.data);
                    e.generateMipmaps = !1, t.__maxMipLevel = l.length - 1
                } else w.texImage2D(3553, 0, c, o.width, o.height, 0, a, s, o.data), t.__maxMipLevel = 0;
            else if (e.isCompressedTexture) {
                for (var p = 0, d = l.length; p < d; p++) i = l[p], e.format !== ee && e.format !== te ? null !== a ? w.compressedTexImage2D(3553, p, c, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w.texImage2D(3553, p, c, i.width, i.height, 0, a, s, i.data);
                t.__maxMipLevel = l.length - 1
            } else if (e.isDataTexture2DArray) w.texImage3D(35866, 0, c, o.width, o.height, o.depth, 0, a, s, o.data), t.__maxMipLevel = 0;
            else if (e.isDataTexture3D) w.texImage3D(32879, 0, c, o.width, o.height, o.depth, 0, a, s, o.data), t.__maxMipLevel = 0;
            else if (0 < l.length && n) {
                for (var f = 0, m = l.length; f < m; f++) i = l[f], w.texImage2D(3553, f, c, a, s, i);
                e.generateMipmaps = !1, t.__maxMipLevel = l.length - 1
            } else w.texImage2D(3553, 0, c, a, s, o), t.__maxMipLevel = 0;
            R(e, n) && C(r, e, o.width, o.height), t.__version = e.version, e.onUpdate && e.onUpdate(e)
        }

        function D(t, e, n, r) {
            var i = S.convert(e.texture.format),
                o = S.convert(e.texture.type),
                a = P(e.texture.internalFormat, i, o);
            w.texImage2D(r, 0, a, e.width, e.height, 0, i, o, null), b.bindFramebuffer(36160, t), b.framebufferTexture2D(36160, n, r, M.get(e.texture).__webglTexture, 0), b.bindFramebuffer(36160, null)
        }

        function N(t, e, n) {
            var r, i, o;
            b.bindRenderbuffer(36161, t), e.depthBuffer && !e.stencilBuffer ? (r = 33189, n ? ((i = e.depthTexture) && i.isDepthTexture && (i.type === Xt ? r = 36012 : i.type === qt && (r = 33190)), i = F(e), b.renderbufferStorageMultisample(36161, i, r, e.width, e.height)) : b.renderbufferStorage(36161, r, e.width, e.height), b.framebufferRenderbuffer(36160, 36096, 36161, t)) : e.depthBuffer && e.stencilBuffer ? (n ? (o = F(e), b.renderbufferStorageMultisample(36161, o, 35056, e.width, e.height)) : b.renderbufferStorage(36161, 34041, e.width, e.height), b.framebufferRenderbuffer(36160, 33306, 36161, t)) : (o = S.convert(e.texture.format), t = S.convert(e.texture.type), t = P(e.texture.internalFormat, o, t), n ? (n = F(e), b.renderbufferStorageMultisample(36161, n, t, e.width, e.height)) : b.renderbufferStorage(36161, t, e.width, e.height)), b.bindRenderbuffer(36161, null)
        }

        function B(t) {
            var e = M.get(t),
                n = !0 === t.isWebGLCubeRenderTarget;
            if (t.depthTexture) {
                if (n) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(t, e) {
                    if (e && e.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (b.bindFramebuffer(36160, t), !e.depthTexture || !e.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (M.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), f(e.depthTexture, 0), t = M.get(e.depthTexture).__webglTexture, e.depthTexture.format === oe) b.framebufferTexture2D(36160, 36096, 3553, t, 0);
                    else {
                        if (e.depthTexture.format !== ae) throw new Error("Unknown depthTexture format");
                        b.framebufferTexture2D(36160, 33306, 3553, t, 0)
                    }
                }(e.__webglFramebuffer, t)
            } else if (n) { e.__webglDepthbuffer = []; for (var r = 0; r < 6; r++) b.bindFramebuffer(36160, e.__webglFramebuffer[r]), e.__webglDepthbuffer[r] = b.createRenderbuffer(), N(e.__webglDepthbuffer[r], t, !1) } else b.bindFramebuffer(36160, e.__webglFramebuffer), e.__webglDepthbuffer = b.createRenderbuffer(), N(e.__webglDepthbuffer, t, !1);
            b.bindFramebuffer(36160, null)
        }

        function F(t) { return E && t.isWebGLMultisampleRenderTarget ? Math.min(n, t.samples) : 0 }
        _[Nt] = 9728, _[Bt] = 9984, _[Ft] = 9986, _[Ut] = 9729, _[zt] = 9985;
        var U = !(_[Ht] = 9987),
            z = !1;
        this.allocateTextureUnit = function() { var t = d; return e <= t && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + e), d += 1, t }, this.resetTextureUnits = function() { d = 0 }, this.setTexture2D = f, this.setTexture2DArray = function(t, e) {
            var n = M.get(t);
            0 < t.version && n.__version !== t.version ? x(n, t, e) : (w.activeTexture(33984 + e), w.bindTexture(35866, n.__webglTexture))
        }, this.setTexture3D = function(t, e) {
            var n = M.get(t);
            0 < t.version && n.__version !== t.version ? x(n, t, e) : (w.activeTexture(33984 + e), w.bindTexture(32879, n.__webglTexture))
        }, this.setTextureCube = m, this.setTextureCubeDynamic = v, this.setupRenderTarget = function(t) {
            var e = M.get(t),
                n = M.get(t.texture);
            t.addEventListener("dispose", p), n.__webglTexture = b.createTexture(), l.memory.textures++;
            var r, i = !0 === t.isWebGLCubeRenderTarget,
                o = !0 === t.isWebGLMultisampleRenderTarget,
                a = L(t) || E;
            if (!E || t.texture.format !== te || t.texture.type !== Xt && t.texture.type !== Yt || (t.texture.format = ee, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), i) { e.__webglFramebuffer = []; for (var s = 0; s < 6; s++) e.__webglFramebuffer[s] = b.createFramebuffer() } else e.__webglFramebuffer = b.createFramebuffer(), o && (E ? (e.__webglMultisampledFramebuffer = b.createFramebuffer(), e.__webglColorRenderbuffer = b.createRenderbuffer(), b.bindRenderbuffer(36161, e.__webglColorRenderbuffer), r = S.convert(t.texture.format), o = S.convert(t.texture.type), r = P(t.texture.internalFormat, r, o), o = F(t), b.renderbufferStorageMultisample(36161, o, r, t.width, t.height), b.bindFramebuffer(36160, e.__webglMultisampledFramebuffer), b.framebufferRenderbuffer(36160, 36064, 36161, e.__webglColorRenderbuffer), b.bindRenderbuffer(36161, null), t.depthBuffer && (e.__webglDepthRenderbuffer = b.createRenderbuffer(), N(e.__webglDepthRenderbuffer, t, !0)), b.bindFramebuffer(36160, null)) : console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."));
            if (i) {
                w.bindTexture(34067, n.__webglTexture), O(34067, t.texture, a);
                for (var c = 0; c < 6; c++) D(e.__webglFramebuffer[c], t, 36064, 34069 + c);
                R(t.texture, a) && C(34067, t.texture, t.width, t.height), w.bindTexture(34067, null)
            } else w.bindTexture(3553, n.__webglTexture), O(3553, t.texture, a), D(e.__webglFramebuffer, t, 36064, 3553), R(t.texture, a) && C(3553, t.texture, t.width, t.height), w.bindTexture(3553, null);
            t.depthBuffer && B(t)
        }, this.updateRenderTargetMipmap = function(t) {
            var e, n, r = t.texture;
            R(r, L(t) || E) && (e = t.isWebGLCubeRenderTarget ? 34067 : 3553, n = M.get(r).__webglTexture, w.bindTexture(e, n), C(e, r, t.width, t.height), w.bindTexture(e, null))
        }, this.updateMultisampleRenderTarget = function(t) {
            var e, n, r, i;
            t.isWebGLMultisampleRenderTarget && (E ? (e = M.get(t), b.bindFramebuffer(36008, e.__webglMultisampledFramebuffer), b.bindFramebuffer(36009, e.__webglFramebuffer), n = t.width, r = t.height, i = 16384, t.depthBuffer && (i |= 256), t.stencilBuffer && (i |= 1024), b.blitFramebuffer(0, 0, n, r, 0, 0, n, r, i, 9728), b.bindFramebuffer(36160, e.__webglMultisampledFramebuffer)) : console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."))
        }, this.safeSetTexture2D = function(t, e) { t && t.isWebGLRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U = !0), t = t.texture), f(t, e) }, this.safeSetTextureCube = function(t, e) { t && t.isWebGLCubeRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), (t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? m : v)(t, e) }
    }

    function Es(t, n, e) { var r = e.isWebGL2; return { convert: function(t) { var e; if (t === kt) return 5121; if (t === Zt) return 32819; if (t === Jt) return 32820; if (t === Kt) return 33635; if (t === Gt) return 5120; if (t === Vt) return 5122; if (t === jt) return 5123; if (t === Wt) return 5124; if (t === qt) return 5125; if (t === Xt) return 5126; if (t === Yt) return r ? 5131 : null !== (e = n.get("OES_texture_half_float")) ? e.HALF_FLOAT_OES : null; if (t === $t) return 6406; if (t === te) return 6407; if (t === ee) return 6408; if (t === ne) return 6409; if (t === re) return 6410; if (t === oe) return 6402; if (t === ae) return 34041; if (t === se) return 6403; if (t === ce) return 36244; if (t === le) return 33319; if (t === ue) return 33320; if (t === he) return 36248; if (t === pe) return 36249; if (t === de || t === fe || t === me || t === ge) { if (null === (e = n.get("WEBGL_compressed_texture_s3tc"))) return null; if (t === de) return e.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === fe) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === me) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === ge) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (t === ve || t === ye || t === _e || t === xe) { if (null === (e = n.get("WEBGL_compressed_texture_pvrtc"))) return null; if (t === ve) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === ye) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === _e) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === xe) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === be) return null !== (e = n.get("WEBGL_compressed_texture_etc1")) ? e.COMPRESSED_RGB_ETC1_WEBGL : null; if ((t === we || t === Me) && null !== (e = n.get("WEBGL_compressed_texture_etc"))) { if (t === we) return e.COMPRESSED_RGB8_ETC2; if (t === Me) return e.COMPRESSED_RGBA8_ETC2_EAC } return t === Se || t === Ee || t === Te || t === Ae || t === Le || t === Re || t === Ce || t === Pe || t === Oe || t === Ie || t === De || t === Ne || t === Be || t === Fe || t === ze || t === He || t === ke || t === Ge || t === Ve || t === je || t === We || t === qe || t === Xe || t === Ye || t === Ze || t === Je || t === Ke || t === Qe ? null !== (e = n.get("WEBGL_compressed_texture_astc")) ? t : null : t === Ue ? null !== (e = n.get("EXT_texture_compression_bptc")) ? t : null : t === Qt ? r ? 34042 : null !== (e = n.get("WEBGL_depth_texture")) ? e.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } }

    function Ts(t) { vo.call(this), this.cameras = t || [] }

    function As() { kr.call(this), this.type = "Group" }

    function Ls() { this._targetRay = null, this._grip = null, this._hand = null }

    function Rs(d, e) {
        var n = this,
            f = null,
            r = 1,
            m = null,
            i = "local-floor",
            g = null,
            v = [],
            l = new Map,
            s = new vo;
        s.layers.enable(1), s.viewport = new Nn;
        var c = new vo;
        c.layers.enable(2), c.viewport = new Nn;
        var y = [s, c],
            _ = new Ts;
        _.layers.enable(1), _.layers.enable(2);
        var u = null,
            h = null;

        function o(t) {
            var e = l.get(t.inputSource);
            e && e.dispatchEvent({ type: t.type })
        }

        function a() { l.forEach(function(t, e) { t.disconnect(e) }), l.clear(), d.setFramebuffer(null), d.setRenderTarget(d.getRenderTarget()), E.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) }

        function p(t) { m = t, E.setContext(f), E.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) }

        function x(t) {
            for (var e = f.inputSources, n = 0; n < v.length; n++) l.set(e[n], v[n]);
            for (var r = 0; r < t.removed.length; r++) {
                var i = t.removed[r],
                    o = l.get(i);
                o && (o.dispatchEvent({ type: "disconnected", data: i }), l.delete(i))
            }
            for (var a = 0; a < t.added.length; a++) {
                var s = t.added[a],
                    c = l.get(s);
                c && c.dispatchEvent({ type: "connected", data: s })
            }
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function(t) { var e = v[t]; return void 0 === e && (e = new Ls, v[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function(t) { var e = v[t]; return void 0 === e && (e = new Ls, v[t] = e), e.getGripSpace() }, this.getHand = function(t) { var e = v[t]; return void 0 === e && (e = new Ls, v[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function(t) { r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function(t) { i = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function() { return m }, this.getSession = function() { return f }, this.setSession = function(t) { null !== (f = t) && (f.addEventListener("select", o), f.addEventListener("selectstart", o), f.addEventListener("selectend", o), f.addEventListener("squeeze", o), f.addEventListener("squeezestart", o), f.addEventListener("squeezeend", o), f.addEventListener("end", a), !0 !== (t = e.getContextAttributes()).xrCompatible && e.makeXRCompatible(), t = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: r }, t = new XRWebGLLayer(f, e, t), f.updateRenderState({ baseLayer: t }), f.requestReferenceSpace(i).then(p), f.addEventListener("inputsourceschange", x)) };
        var b = new kn,
            w = new kn;

        function M(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld) }
        this.getCamera = function(t) {
            _.near = c.near = s.near = t.near, _.far = c.far = s.far = t.far, u === _.near && h === _.far || (f.updateRenderState({ depthNear: _.near, depthFar: _.far }), u = _.near, h = _.far);
            var e = t.parent,
                n = _.cameras;
            M(_, e);
            for (var r = 0; r < n.length; r++) M(n[r], e);
            t.matrixWorld.copy(_.matrixWorld);
            for (var i = t.children, o = 0, a = i.length; o < a; o++) i[o].updateMatrixWorld(!0);
            return 2 === n.length ? function(t, e, n) {
                b.setFromMatrixPosition(e.matrixWorld), w.setFromMatrixPosition(n.matrixWorld);
                var r = b.distanceTo(w),
                    i = e.projectionMatrix.elements,
                    o = n.projectionMatrix.elements,
                    a = i[14] / (i[10] - 1),
                    s = i[14] / (i[10] + 1),
                    c = (i[9] + 1) / i[5],
                    l = (i[9] - 1) / i[5],
                    u = (i[8] - 1) / i[0],
                    n = (o[8] + 1) / o[0],
                    i = a * u,
                    o = a * n,
                    u = (n = r / (n - u)) * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(u), t.translateZ(n), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), a += n, i -= u, o = r - u + o, c = c * s / (n = s + n) * a, s = l * s / n * a, t.projectionMatrix.makePerspective(i, o, c, s, a, n)
            }(_, s, c) : _.projectionMatrix.copy(s.projectionMatrix), _
        };
        var S = null;
        var E = new So;
        E.setAnimationLoop(function(t, e) {
            if (null !== (g = e.getViewerPose(m))) {
                var n = g.views,
                    r = f.renderState.baseLayer;
                d.setFramebuffer(r.framebuffer);
                var i = !1;
                n.length !== _.cameras.length && (i = !(_.cameras.length = 0));
                for (var o = 0; o < n.length; o++) {
                    var a = n[o],
                        s = r.getViewport(a),
                        c = y[o];
                    c.matrix.fromArray(a.transform.matrix), c.projectionMatrix.fromArray(a.projectionMatrix), c.viewport.set(s.x, s.y, s.width, s.height), 0 === o && _.matrix.copy(c.matrix), !0 === i && _.cameras.push(c)
                }
            }
            for (var l = f.inputSources, u = 0; u < v.length; u++) {
                var h = v[u],
                    p = l[u];
                h.update(p, e, m)
            }
            S && S(t, e)
        }), this.setAnimationLoop = function(t) { S = t }, this.dispose = function() {}
    }

    function Cs(o) {
        function c(t, e) {
            t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap);
            var n, r, i = o.get(e).envMap;
            i && (t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, void 0 !== (i = o.get(i).__maxMipLevel) && (t.maxMipLevel.value = i)), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap ? n = e.emissiveMap : e.clearcoatMap ? n = e.clearcoatMap : e.clearcoatNormalMap ? n = e.clearcoatNormalMap : e.clearcoatRoughnessMap && (n = e.clearcoatRoughnessMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)), e.aoMap ? r = e.aoMap : e.lightMap && (r = e.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uv2Transform.value.copy(r.matrix))
        }

        function l(t, e) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === j && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === j && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), o.get(e).envMap && (t.envMapIntensity.value = e.envMapIntensity) }
        return {
            refreshFogUniforms: function(t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) },
            refreshMaterialUniforms: function(t, e, n, r) {
                var i, o, a, s;
                e.isMeshBasicMaterial ? c(t, e) : e.isMeshLambertMaterial ? (c(t, e), a = t, (s = e).emissiveMap && (a.emissiveMap.value = s.emissiveMap)) : e.isMeshToonMaterial ? (c(t, e), function(t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === j && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === j && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, e)) : e.isMeshPhongMaterial ? (c(t, e), function(t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === j && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === j && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, e)) : e.isMeshStandardMaterial ? (c(t, e), (e.isMeshPhysicalMaterial ? function(t, e) {
                    l(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                    e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                    e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === j && t.clearcoatNormalScale.value.negate());
                    t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                } : l)(t, e)) : e.isMeshMatcapMaterial ? (c(t, e), function(t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === j && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === j && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, e)) : e.isMeshDepthMaterial ? (c(t, e), i = t, (o = e).displacementMap && (i.displacementMap.value = o.displacementMap, i.displacementScale.value = o.displacementScale, i.displacementBias.value = o.displacementBias)) : e.isMeshDistanceMaterial ? (c(t, e), function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                    t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                }(t, e)) : e.isMeshNormalMaterial ? (c(t, e), function(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === j && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === j && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, e)) : e.isLineBasicMaterial ? (i = e, (o = t).diffuse.value.copy(i.color), o.opacity.value = i.opacity, e.isLineDashedMaterial && (o = e, (i = t).dashSize.value = o.dashSize, i.totalSize.value = o.dashSize + o.gapSize, i.scale.value = o.scale)) : e.isPointsMaterial ? function(t, e, n, r) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    var i;
                    e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                    void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                }(t, e, n, r) : e.isSpriteMaterial ? function(t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    var n;
                    e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }(t, e) : e.isShadowMaterial ? (t.color.value.copy(e.color), t.opacity.value = e.opacity) : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
            }
        }
    }

    function Ps(t) {
        var i = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            e = void 0 !== t.context ? t.context : null,
            n = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            o = void 0 === t.stencil || t.stencil,
            a = void 0 !== t.antialias && t.antialias,
            s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            l = void 0 !== t.powerPreference ? t.powerPreference : "default",
            u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
            v = null,
            y = null;
        this.domElement = i, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = an, this.physicallyCorrectLights = !1, this.toneMapping = Et, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var d = this,
            h = !1,
            p = null,
            f = 0,
            m = 0,
            g = null,
            _ = null,
            x = -1,
            b = null,
            w = null,
            M = new Nn,
            S = new Nn,
            E = null,
            T = i.width,
            A = i.height,
            L = 1,
            R = null,
            C = null,
            P = new Nn(0, 0, T, A),
            O = new Nn(0, 0, T, A),
            I = !1,
            D = new Mo,
            N = !1,
            B = !1,
            F = new mr,
            U = new kn,
            z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };

        function H() { return null === g ? L : 1 }
        var k, G, V, j, W, q, X, Y, Z, J, K, Q, $, tt, et, nt, rt, it, ot, at, st, ct = e;

        function lt(t, e) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n],
                    r = i.getContext(r, e);
                if (null !== r) return r
            }
            return null
        }
        try {
            var ut = { alpha: n, depth: r, stencil: o, antialias: a, premultipliedAlpha: s, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: u };
            if (i.addEventListener("webglcontextlost", mt, !1), i.addEventListener("webglcontextrestored", gt, !1), null === ct) { var ht = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === d.isWebGL1Renderer && ht.shift(), null === (ct = lt(ht, ut))) throw lt(ht) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") }
            void 0 === ct.getShaderPrecisionFormat && (ct.getShaderPrecisionFormat = function() { return { rangeMin: 1, rangeMax: 1, precision: 1 } })
        } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t }

        function pt() { k = new Fo(ct), !1 === (G = new Do(ct, k, t)).isWebGL2 && (k.get("WEBGL_depth_texture"), k.get("OES_texture_float"), k.get("OES_texture_half_float"), k.get("OES_texture_half_float_linear"), k.get("OES_standard_derivatives"), k.get("OES_element_index_uint"), k.get("OES_vertex_array_object"), k.get("ANGLE_instanced_arrays")), k.get("OES_texture_float_linear"), at = new Es(0, k, G), (V = new Ms(ct, k, G)).scissor(S.copy(O).multiplyScalar(L).floor()), V.viewport(M.copy(P).multiplyScalar(L).floor()), j = new Ho, W = new ss, q = new Ss(ct, k, V, W, G, at, j), X = new Bo(d), Y = new Eo(ct, G), st = new Oo(ct, k, Y, G), Z = new Uo(0, Y, j, st), J = new jo(0, Z, Y, j), rt = new Vo(ct), et = new No(W), K = new as(d, X, k, G, st, et), Q = new Cs(W), $ = new hs(W), tt = new vs, nt = new Po(d, X, V, J, s), it = new Io(ct, k, j, G), ot = new zo(ct, k, j, G), j.programs = K.programs, d.capabilities = G, d.extensions = k, d.properties = W, d.renderLists = $, d.state = V, d.info = j }
        pt();
        var dt = new Rs(d, ct);
        this.xr = dt;
        var ft = new ws(d, J, G.maxTextureSize);

        function mt(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), h = !0 }

        function gt() { console.log("THREE.WebGLRenderer: Context Restored."), h = !1, pt() }

        function vt(t) {
            t = t.target;
            t.removeEventListener("dispose", vt), yt(t = t), W.remove(t)
        }

        function yt(t) {
            t = W.get(t).program;
            void 0 !== t && K.releaseProgram(t)
        }
        this.shadowMap = ft, this.getContext = function() { return ct }, this.getContextAttributes = function() { return ct.getContextAttributes() }, this.forceContextLoss = function() {
            var t = k.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function() {
            var t = k.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function() { return L }, this.setPixelRatio = function(t) { void 0 !== t && (L = t, this.setSize(T, A, !1)) }, this.getSize = function(t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Ln), t.set(T, A) }, this.setSize = function(t, e, n) { dt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, A = e, i.width = Math.floor(t * L), i.height = Math.floor(e * L), !1 !== n && (i.style.width = t + "px", i.style.height = e + "px"), this.setViewport(0, 0, t, e)) }, this.getDrawingBufferSize = function(t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Ln), t.set(T * L, A * L).floor() }, this.setDrawingBufferSize = function(t, e, n) { T = t, A = e, L = n, i.width = Math.floor(t * n), i.height = Math.floor(e * n), this.setViewport(0, 0, t, e) }, this.getCurrentViewport = function(t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Nn), t.copy(M) }, this.getViewport = function(t) { return t.copy(P) }, this.setViewport = function(t, e, n, r) { t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, r), V.viewport(M.copy(P).multiplyScalar(L).floor()) }, this.getScissor = function(t) { return t.copy(O) }, this.setScissor = function(t, e, n, r) { t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, r), V.scissor(S.copy(O).multiplyScalar(L).floor()) }, this.getScissorTest = function() { return I }, this.setScissorTest = function(t) { V.setScissorTest(I = t) }, this.setOpaqueSort = function(t) { R = t }, this.setTransparentSort = function(t) { C = t }, this.getClearColor = function() { return nt.getClearColor() }, this.setClearColor = function() { nt.setClearColor.apply(nt, arguments) }, this.getClearAlpha = function() { return nt.getClearAlpha() }, this.setClearAlpha = function() { nt.setClearAlpha.apply(nt, arguments) }, this.clear = function(t, e, n) {
            var r = 0;
            void 0 !== t && !t || (r |= 16384), void 0 !== e && !e || (r |= 256), void 0 !== n && !n || (r |= 1024), ct.clear(r)
        }, this.clearColor = function() { this.clear(!0, !1, !1) }, this.clearDepth = function() { this.clear(!1, !0, !1) }, this.clearStencil = function() { this.clear(!1, !1, !0) }, this.dispose = function() { i.removeEventListener("webglcontextlost", mt, !1), i.removeEventListener("webglcontextrestored", gt, !1), $.dispose(), tt.dispose(), W.dispose(), X.dispose(), J.dispose(), st.dispose(), dt.dispose(), xt.stop() }, this.renderBufferImmediate = function(t, e) {
            st.initAttributes();
            var n = W.get(t);
            t.hasPositions && !n.position && (n.position = ct.createBuffer()), t.hasNormals && !n.normal && (n.normal = ct.createBuffer()), t.hasUvs && !n.uv && (n.uv = ct.createBuffer()), t.hasColors && !n.color && (n.color = ct.createBuffer());
            e = e.getAttributes();
            t.hasPositions && (ct.bindBuffer(34962, n.position), ct.bufferData(34962, t.positionArray, 35048), st.enableAttribute(e.position), ct.vertexAttribPointer(e.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ct.bindBuffer(34962, n.normal), ct.bufferData(34962, t.normalArray, 35048), st.enableAttribute(e.normal), ct.vertexAttribPointer(e.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ct.bindBuffer(34962, n.uv), ct.bufferData(34962, t.uvArray, 35048), st.enableAttribute(e.uv), ct.vertexAttribPointer(e.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ct.bindBuffer(34962, n.color), ct.bufferData(34962, t.colorArray, 35048), st.enableAttribute(e.color), ct.vertexAttribPointer(e.color, 3, 5126, !1, 0, 0)), st.disableUnusedAttributes(), ct.drawArrays(4, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function(t, e, n, r, i, o) {
            null === e && (e = z);
            var a = i.isMesh && i.matrixWorld.determinant() < 0,
                s = St(t, e, r, i);
            V.setMaterial(r, a);
            var c = n.index,
                t = n.attributes.position;
            if (null === c) { if (void 0 === t || 0 === t.count) return } else if (0 === c.count) return;
            e = 1;
            !0 === r.wireframe && (c = Z.getWireframeAttribute(n), e = 2), (r.morphTargets || r.morphNormals) && rt.update(i, n, r, s), st.setup(i, r, s, n, c);
            a = it;
            null !== c && (l = Y.get(c), (a = ot).setIndex(l));
            var s = (null !== c ? c : t).count,
                l = n.drawRange.start * e,
                c = n.drawRange.count * e,
                t = null !== o ? o.start * e : 0,
                o = null !== o ? o.count * e : 1 / 0,
                e = Math.max(l, t),
                o = Math.min(s, l + c, t + o) - 1,
                o = Math.max(0, o - e + 1);
            0 !== o && (i.isMesh ? !0 === r.wireframe ? (V.setLineWidth(r.wireframeLinewidth * H()), a.setMode(1)) : a.setMode(4) : i.isLine ? (void 0 === (r = r.linewidth) && (r = 1), V.setLineWidth(r * H()), i.isLineSegments ? a.setMode(1) : i.isLineLoop ? a.setMode(2) : a.setMode(3)) : i.isPoints ? a.setMode(0) : i.isSprite && a.setMode(4), i.isInstancedMesh ? a.renderInstances(e, o, i.count) : n.isInstancedBufferGeometry ? (n = Math.min(n.instanceCount, n._maxInstanceCount), a.renderInstances(e, o, n)) : a.render(e, o))
        }, this.compile = function(i, t) {
            (y = tt.get(i, t)).init(), i.traverse(function(t) { t.isLight && (y.pushLight(t), t.castShadow && y.pushShadow(t)) }), y.setupLights(t);
            var o = new WeakMap;
            i.traverse(function(t) {
                var e = t.material;
                if (e)
                    if (Array.isArray(e))
                        for (var n = 0; n < e.length; n++) { var r = e[n];!1 === o.has(r) && (Mt(r, i, t), o.set(r)) } else !1 === o.has(e) && (Mt(e, i, t), o.set(e))
            })
        };
        var _t = null;
        var xt = new So;

        function bt(t, e, n) {
            for (var r = !0 === e.isScene ? e.overrideMaterial : null, i = 0, o = t.length; i < o; i++) {
                var a = t[i],
                    s = a.object,
                    c = a.geometry,
                    l = null === r ? a.material : r,
                    u = a.group;
                if (n.isArrayCamera)
                    for (var h = (w = n).cameras, p = 0, d = h.length; p < d; p++) {
                        var f = h[p];
                        s.layers.test(f.layers) && (V.viewport(M.copy(f.viewport)), y.setupLights(f), wt(s, e, f, c, l, u))
                    } else w = null, wt(s, e, n, c, l, u)
            }
        }

        function wt(t, e, n, r, i, o) {
            var a, s;
            t.onBeforeRender(d, e, n, r, i, o), y = tt.get(e, w || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject ? (a = St(n, e, i, t), V.setMaterial(i), st.reset(), s = a, t.render(function(t) { d.renderBufferImmediate(t, s) })) : d.renderBufferDirect(n, e, r, i, t, o), t.onAfterRender(d, e, n, r, i, o), y = tt.get(e, w || n)
        }

        function Mt(t, e, n) {
            !0 !== e.isScene && (e = z);
            var r = W.get(t),
                i = y.state.lights,
                o = y.state.shadowsArray,
                a = i.state.version,
                s = K.getParameters(t, i.state, o, e, n),
                c = K.getProgramCacheKey(s),
                l = r.program,
                o = !0;
            if (void 0 === l) t.addEventListener("dispose", vt);
            else if (l.cacheKey !== c) yt(t);
            else if (r.lightsStateVersion !== a) o = !1;
            else {
                if (void 0 !== s.shaderID) { n = t.isMeshStandardMaterial ? e.environment : null; return void(r.envMap = X.get(t.envMap || n)) }
                o = !1
            }
            o && (s.uniforms = K.getUniforms(t), t.onBeforeCompile(s, d), l = K.acquireProgram(s, c), r.program = l, r.uniforms = s.uniforms, r.outputEncoding = s.outputEncoding);
            s = r.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = et.numPlanes, r.numIntersection = et.numIntersection, s.clippingPlanes = et.uniform), r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = X.get(t.envMap || r.environment), r.needsLights = (t = t).isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights, r.lightsStateVersion = a, r.needsLights && (s.ambientLightColor.value = i.state.ambient, s.lightProbe.value = i.state.probe, s.directionalLights.value = i.state.directional, s.directionalLightShadows.value = i.state.directionalShadow, s.spotLights.value = i.state.spot, s.spotLightShadows.value = i.state.spotShadow, s.rectAreaLights.value = i.state.rectArea, s.ltc_1.value = i.state.rectAreaLTC1, s.ltc_2.value = i.state.rectAreaLTC2, s.pointLights.value = i.state.point, s.pointLightShadows.value = i.state.pointShadow, s.hemisphereLights.value = i.state.hemi, s.directionalShadowMap.value = i.state.directionalShadowMap, s.directionalShadowMatrix.value = i.state.directionalShadowMatrix, s.spotShadowMap.value = i.state.spotShadowMap, s.spotShadowMatrix.value = i.state.spotShadowMatrix, s.pointShadowMap.value = i.state.pointShadowMap, s.pointShadowMatrix.value = i.state.pointShadowMatrix);
            i = r.program.getUniforms(), s = ka.seqWithValue(i.seq, s);
            r.uniformsList = s
        }

        function St(t, e, n, r) {
            !0 !== e.isScene && (e = z), q.resetTextureUnits();
            var i = e.fog,
                o = n.isMeshStandardMaterial ? e.environment : null,
                a = null === g ? d.outputEncoding : g.texture.encoding,
                s = X.get(n.envMap || o),
                c = W.get(n),
                l = y.state.lights;
            !0 === N && (!0 !== B && t === b || (p = t === b && n.id === x, et.setState(n, t, p))), n.version === c.__version ? (n.fog && c.fog !== i || c.environment !== o || c.needsLights && c.lightsStateVersion !== l.state.version || void 0 !== c.numClippingPlanes && (c.numClippingPlanes !== et.numPlanes || c.numIntersection !== et.numIntersection) || c.outputEncoding !== a || c.envMap !== s) && Mt(n, e, r) : (Mt(n, e, r), c.__version = n.version);
            var u, h = !1,
                p = !1,
                o = !1,
                l = c.program,
                a = l.getUniforms(),
                s = c.uniforms;
            return V.useProgram(l.program) && (o = p = h = !0), n.id !== x && (x = n.id, p = !0), !h && b === t || (a.setValue(ct, "projectionMatrix", t.projectionMatrix), G.logarithmicDepthBuffer && a.setValue(ct, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, o = p = !0), !(n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) || void 0 !== (u = a.map.cameraPosition) && u.setValue(ct, U.setFromMatrixPosition(t.matrixWorld)), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && a.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && a.setValue(ct, "viewMatrix", t.matrixWorldInverse)), n.skinning && (a.setOptional(ct, r, "bindMatrix"), a.setOptional(ct, r, "bindMatrixInverse"), (e = r.skeleton) && (h = e.bones, G.floatVertexTextures ? (void 0 === e.boneTexture && (u = Math.sqrt(4 * h.length), u = An.ceilPowerOfTwo(u), u = Math.max(u, 4), (t = new Float32Array(u * u * 4)).set(e.boneMatrices), h = new xo(t, u, u, ee, Xt), e.boneMatrices = t, e.boneTexture = h, e.boneTextureSize = u), a.setValue(ct, "boneTexture", e.boneTexture, q), a.setValue(ct, "boneTextureSize", e.boneTextureSize)) : a.setOptional(ct, e, "boneMatrices"))), !p && c.receiveShadow === r.receiveShadow || (c.receiveShadow = r.receiveShadow, a.setValue(ct, "receiveShadow", r.receiveShadow)), p && (a.setValue(ct, "toneMappingExposure", d.toneMappingExposure), c.needsLights && (p = o, (o = s).ambientLightColor.needsUpdate = p, o.lightProbe.needsUpdate = p, o.directionalLights.needsUpdate = p, o.directionalLightShadows.needsUpdate = p, o.pointLights.needsUpdate = p, o.pointLightShadows.needsUpdate = p, o.spotLights.needsUpdate = p, o.spotLightShadows.needsUpdate = p, o.rectAreaLights.needsUpdate = p, o.hemisphereLights.needsUpdate = p), i && n.fog && Q.refreshFogUniforms(s, i), Q.refreshMaterialUniforms(s, n, L, A), ka.upload(ct, c.uniformsList, s, q)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ka.upload(ct, c.uniformsList, s, q), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && a.setValue(ct, "center", r.center), a.setValue(ct, "modelViewMatrix", r.modelViewMatrix), a.setValue(ct, "normalMatrix", r.normalMatrix), a.setValue(ct, "modelMatrix", r.matrixWorld), l
        }
        xt.setAnimationLoop(function(t) { dt.isPresenting || _t && _t(t) }), "undefined" != typeof window && xt.setContext(window), this.setAnimationLoop = function(t) { _t = t, dt.setAnimationLoop(t), null === t ? xt.stop() : xt.start() }, this.render = function(t, e) {
            var n, r, i;
            void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), r = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 === e || !0 === e.isCamera ? !0 !== h && (st.resetDefaultState(), x = -1, !(b = null) === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(d, t, e, r || g), (y = tt.get(t, e)).init(), F.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), D.setFromProjectionMatrix(F), B = this.localClippingEnabled, N = et.init(this.clippingPlanes, B, e), (v = $.get(t, e)).init(), function t(e, n, r, i) {
                if (!1 === e.visible) return;
                var o = e.layers.test(n.layers);
                if (o)
                    if (e.isGroup) r = e.renderOrder;
                    else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                else if (e.isLight) y.pushLight(e), e.castShadow && y.pushShadow(e);
                else if (e.isSprite) {
                    var a;
                    e.frustumCulled && !D.intersectsSprite(e) || (i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F), a = J.update(e), (o = e.material).visible && v.push(e, a, o, r, U.z, null))
                } else if (e.isImmediateRenderObject) i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F), v.push(e, null, e.material, r, U.z, null);
                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== j.render.frame && (e.skeleton.update(), e.skeleton.frame = j.render.frame), !e.frustumCulled || D.intersectsObject(e))) {
                    i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
                    var s = J.update(e),
                        c = e.material;
                    if (Array.isArray(c))
                        for (var l = s.groups, u = 0, h = l.length; u < h; u++) {
                            var p = l[u],
                                d = c[p.materialIndex];
                            d && d.visible && v.push(e, s, d, r, U.z, p)
                        } else c.visible && v.push(e, s, c, r, U.z, null)
                }
                var f = e.children;
                for (var m = 0, g = f.length; m < g; m++) t(f[m], n, r, i)
            }(t, e, 0, d.sortObjects), v.finish(), !0 === d.sortObjects && v.sort(R, C), !0 === N && et.beginShadows(), n = y.state.shadowsArray, ft.render(n, t, e), y.setupLights(e), !0 === N && et.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== r && this.setRenderTarget(r), nt.render(v, t, e, i), r = v.opaque, i = v.transparent, 0 < r.length && bt(r, t, e), 0 < i.length && bt(i, t, e), !0 === t.isScene && t.onAfterRender(d, t, e), null !== g && (q.updateRenderTargetMipmap(g), q.updateMultisampleRenderTarget(g)), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), y = v = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFramebuffer = function(t) { p !== t && null === g && ct.bindFramebuffer(36160, t), p = t }, this.getActiveCubeFace = function() { return f }, this.getActiveMipmapLevel = function() { return m }, this.getRenderList = function() { return v }, this.setRenderList = function(t) { v = t }, this.getRenderState = function() { return y }, this.setRenderState = function(t) { y = t }, this.getRenderTarget = function() { return g }, this.setRenderTarget = function(t, e, n) {
            void 0 === e && (e = 0), void 0 === n && (n = 0), f = e, m = n, (g = t) && void 0 === W.get(t).__webglFramebuffer && q.setupRenderTarget(t);
            var r, i = p,
                o = !1;
            E = t ? (r = W.get(t).__webglFramebuffer, t.isWebGLCubeRenderTarget ? (i = r[e], o = !0) : i = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : r, M.copy(t.viewport), S.copy(t.scissor), t.scissorTest) : (M.copy(P).multiplyScalar(L).floor(), S.copy(O).multiplyScalar(L).floor(), I), _ !== i && (ct.bindFramebuffer(36160, i), _ = i), V.viewport(M), V.scissor(S), V.setScissorTest(E), o && (t = W.get(t.texture), ct.framebufferTexture2D(36160, 36064, 34069 + e, t.__webglTexture, n))
        }, this.readRenderTargetPixels = function(t, e, n, r, i, o, a) {
            if (t && t.isWebGLRenderTarget) {
                var s = W.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s) {
                    a = !1;
                    s !== _ && (ct.bindFramebuffer(36160, s), a = !0);
                    try {
                        var c = t.texture,
                            l = c.format,
                            c = c.type;
                        if (l !== ee && at.convert(l) !== ct.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(c === kt || at.convert(c) === ct.getParameter(35738) || c === Xt && (G.isWebGL2 || k.get("OES_texture_float") || k.get("WEBGL_color_buffer_float")) || c === Yt && (G.isWebGL2 ? k.get("EXT_color_buffer_float") : k.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === ct.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - r && 0 <= n && n <= t.height - i && ct.readPixels(e, n, r, i, at.convert(l), at.convert(c), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally { a && ct.bindFramebuffer(36160, _) }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function(t, e, n) {
            void 0 === n && (n = 0);
            var r = Math.pow(2, -n),
                i = Math.floor(e.image.width * r),
                o = Math.floor(e.image.height * r),
                r = at.convert(e.format);
            q.setTexture2D(e, 0), ct.copyTexImage2D(3553, n, r, t.x, t.y, i, o, 0), V.unbindTexture()
        }, this.copyTextureToTexture = function(t, e, n, r) {
            void 0 === r && (r = 0);
            var i = e.image.width,
                o = e.image.height,
                a = at.convert(n.format),
                s = at.convert(n.type);
            q.setTexture2D(n, 0), ct.pixelStorei(37440, n.flipY), ct.pixelStorei(37441, n.premultiplyAlpha), ct.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ct.texSubImage2D(3553, r, t.x, t.y, i, o, a, s, e.image.data) : e.isCompressedTexture ? ct.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : ct.texSubImage2D(3553, r, t.x, t.y, a, s, e.image), 0 === r && n.generateMipmaps && ct.generateMipmap(3553), V.unbindTexture()
        }, this.initTexture = function(t) { q.setTexture2D(t, 0), V.unbindTexture() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }))
    }

    function Os(t) { Ps.call(this, t) }
    Ts.prototype = Object.assign(Object.create(vo.prototype), { constructor: Ts, isArrayCamera: !0 }), As.prototype = Object.assign(Object.create(kr.prototype), { constructor: As, isGroup: !0 }), Object.assign(Ls.prototype, {
        constructor: Ls,
        getHandSpace: function() {
            if (null === this._hand && (this._hand = new As, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand))
                for (var t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
                    var e = new As;
                    e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e)
                }
            return this._hand
        },
        getTargetRaySpace: function() { return null === this._targetRay && (this._targetRay = new As, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay },
        getGripSpace: function() { return null === this._grip && (this._grip = new As, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip },
        dispatchEvent: function(t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this },
        disconnect: function(t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this },
        update: function(t, e, n) {
            var r = null,
                i = null,
                o = null,
                a = this._targetRay,
                s = this._grip,
                c = this._hand;
            if (t)
                if (c && t.hand) { o = !0; for (var l, u, h = 0; h <= window.XRHand.LITTLE_PHALANX_TIP; h++) t.hand[h] && (u = e.getJointPose(t.hand[h], n), l = c.joints[h], null !== u && (l.matrix.fromArray(u.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.jointRadius = u.radius), l.visible = null !== u, l = c.joints[window.XRHand.INDEX_PHALANX_TIP], u = c.joints[window.XRHand.THUMB_PHALANX_TIP], u = l.position.distanceTo(u.position), c.inputState.pinching && .025 < u ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && u <= .015 && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }))) } else null !== a && null !== (r = e.getPose(t.targetRaySpace, n)) && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)), null !== s && t.gripSpace && null !== (i = e.getPose(t.gripSpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale));
            return null !== a && (a.visible = null !== r), null !== s && (s.visible = null !== i), null !== c && (c.visible = null !== o), this
        }
    }), Object.assign(Rs.prototype, Mn.prototype), Os.prototype = Object.assign(Object.create(Ps.prototype), { constructor: Os, isWebGL1Renderer: !0 });

    function Is(t, e) { Object.defineProperty(this, "isFogExp2", { value: !0 }), this.name = "", this.color = new li(t), this.density = void 0 !== e ? e : 25e-5 }
    Is.prototype.clone = function() { return new Is(this.color, this.density) }, Is.prototype.toJSON = function() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } };

    function Ds(t, e, n) { Object.defineProperty(this, "isFog", { value: !0 }), this.name = "", this.color = new li(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3 }
    Ds.prototype.clone = function() { return new Ds(this.color, this.near, this.far) }, Ds.prototype.toJSON = function() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } };
    var Ns = function(n) {
        function t() { n.call(this), Object.defineProperty(this, "isScene", { value: !0 }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) }
        return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.copy = function(t, e) { return n.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, t.prototype.toJSON = function(t) { var e = n.prototype.toJSON.call(this, t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e }, t
    }(kr);

    function Bs(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = xn, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = An.generateUUID() }
    Object.defineProperty(Bs.prototype, "needsUpdate", { set: function(t) {!0 === t && this.version++ } }), Object.assign(Bs.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(t) { return this.usage = t, this },
        copy: function(t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this },
        copyAt: function(t, e, n) { t *= this.stride, n *= e.stride; for (var r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r]; return this },
        set: function(t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this },
        clone: function(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = An.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            t = new Bs(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
            return t.setUsage(this.usage), t
        },
        onUpload: function(t) { return this.onUploadCallback = t, this },
        toJSON: function(t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = An.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } }
    });
    var Fs, Us = new kn;

    function zs(t, e, n, r) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r }

    function Hs(t) { pi.call(this), this.type = "SpriteMaterial", this.color = new li(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) }
    Object.defineProperties(zs.prototype, { count: { get: function() { return this.data.count } }, array: { get: function() { return this.data.array } }, needsUpdate: { set: function(t) { this.data.needsUpdate = t } } }), Object.assign(zs.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function(t) { for (var e = 0, n = this.data.count; e < n; e++) Us.x = this.getX(e), Us.y = this.getY(e), Us.z = this.getZ(e), Us.applyMatrix4(t), this.setXYZ(e, Us.x, Us.y, Us.z); return this },
        setX: function(t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this },
        setY: function(t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this },
        setZ: function(t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this },
        setW: function(t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this },
        getX: function(t) { return this.data.array[t * this.data.stride + this.offset] },
        getY: function(t) { return this.data.array[t * this.data.stride + this.offset + 1] },
        getZ: function(t) { return this.data.array[t * this.data.stride + this.offset + 2] },
        getW: function(t) { return this.data.array[t * this.data.stride + this.offset + 3] },
        setXY: function(t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this },
        setXYZ: function(t, e, n, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this },
        setXYZW: function(t, e, n, r, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this },
        clone: function(t) {
            if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new zs(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            for (var e = [], n = 0; n < this.count; n++)
                for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) e.push(this.data.array[r + i]);
            return new gi(new this.array.constructor(e), this.itemSize, this.normalized)
        },
        toJSON: function(t) {
            if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            for (var e = [], n = 0; n < this.count; n++)
                for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) e.push(this.data.array[r + i]);
            return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized }
        }
    }), ((Hs.prototype = Object.create(pi.prototype)).constructor = Hs).prototype.isSpriteMaterial = !0, Hs.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this };
    var ks = new kn,
        Gs = new kn,
        Vs = new kn,
        js = new Ln,
        Ws = new Ln,
        qs = new mr,
        Xs = new kn,
        Ys = new kn,
        Zs = new kn,
        Js = new Ln,
        Ks = new Ln,
        Qs = new Ln;

    function $s(t) {
        var e;
        kr.call(this), this.type = "Sprite", void 0 === Fs && (Fs = new Ni, e = new Bs(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5), Fs.setIndex([0, 1, 2, 0, 2, 3]), Fs.setAttribute("position", new zs(e, 3, 0, !1)), Fs.setAttribute("uv", new zs(e, 2, 3, !1))), this.geometry = Fs, this.material = void 0 !== t ? t : new Hs, this.center = new Ln(.5, .5)
    }

    function tc(t, e, n, r, i, o) { js.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (Ws.x = o * js.x - i * js.y, Ws.y = i * js.x + o * js.y) : Ws.copy(js), t.copy(e), t.x += Ws.x, t.y += Ws.y, t.applyMatrix4(qs) }
    $s.prototype = Object.assign(Object.create(kr.prototype), {
        constructor: $s,
        isSprite: !0,
        raycast: function(t, e) {
            null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Gs.setFromMatrixScale(this.matrixWorld), qs.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Vs.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Gs.multiplyScalar(-Vs.z);
            var n, r, i = this.material.rotation;
            0 !== i && (r = Math.cos(i), n = Math.sin(i));
            var o = this.center;
            tc(Xs.set(-.5, -.5, 0), Vs, o, Gs, n, r), tc(Ys.set(.5, -.5, 0), Vs, o, Gs, n, r), tc(Zs.set(.5, .5, 0), Vs, o, Gs, n, r), Js.set(0, 0), Ks.set(1, 0), Qs.set(1, 1);
            i = t.ray.intersectTriangle(Xs, Ys, Zs, !1, ks);
            null === i && (tc(Ys.set(-.5, .5, 0), Vs, o, Gs, n, r), Ks.set(0, 1), null === (i = t.ray.intersectTriangle(Xs, Zs, Ys, !1, ks))) || ((i = t.ray.origin.distanceTo(ks)) < t.near || i > t.far || e.push({ distance: i, point: ks.clone(), uv: ni.getUV(ks, Xs, Ys, Zs, Js, Ks, Qs, new Ln), face: null, object: this }))
        },
        copy: function(t) { return kr.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this }
    });
    var ec, nc, rc, ic, oc, ac = new kn,
        sc = new kn;

    function cc() { kr.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 }

    function lc(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), $i.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new mr, this.bindMatrixInverse = new mr }
    cc.prototype = Object.assign(Object.create(kr.prototype), {
        constructor: cc,
        isLOD: !0,
        copy: function(t) {
            kr.prototype.copy.call(this, t, !1);
            for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this.autoUpdate = t.autoUpdate, this
        },
        addLevel: function(t, e) { void 0 === e && (e = 0), e = Math.abs(e); for (var n = this.levels, r = 0; r < n.length && !(e < n[r].distance); r++); return n.splice(r, 0, { distance: e, object: t }), this.add(t), this },
        getCurrentLevel: function() { return this._currentLevel },
        getObjectForDistance: function(t) { var e = this.levels; if (0 < e.length) { for (var n = 1, r = e.length; n < r && !(t < e[n].distance); n++); return e[n - 1].object } return null },
        raycast: function(t, e) {
            var n;
            0 < this.levels.length && (ac.setFromMatrixPosition(this.matrixWorld), n = t.ray.origin.distanceTo(ac), this.getObjectForDistance(n).raycast(t, e))
        },
        update: function(t) { var e = this.levels; if (1 < e.length) { ac.setFromMatrixPosition(t.matrixWorld), sc.setFromMatrixPosition(this.matrixWorld); var n, r, i = ac.distanceTo(sc) / t.zoom; for (e[0].object.visible = !0, n = 1, r = e.length; n < r && i >= e[n].distance; n++) e[n - 1].object.visible = !1, e[n].object.visible = !0; for (this._currentLevel = n - 1; n < r; n++) e[n].object.visible = !1 } },
        toJSON: function(t) {
            var e = kr.prototype.toJSON.call(this, t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
            for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                e.object.levels.push({ object: o.object.uuid, distance: o.distance })
            }
            return e
        }
    }), lc.prototype = Object.assign(Object.create($i.prototype), {
        constructor: lc,
        isSkinnedMesh: !0,
        copy: function(t) { return $i.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this },
        bind: function(t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) },
        pose: function() { this.skeleton.pose() },
        normalizeSkinWeights: function() {
            for (var t = new Nn, e = this.geometry.attributes.skinWeight, n = 0, r = e.count; n < r; n++) {
                t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                var i = 1 / t.manhattanLength();
                i != 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
            }
        },
        updateMatrixWorld: function(t) { $i.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) },
        boneTransform: (ec = new kn, nc = new Nn, rc = new Nn, ic = new kn, oc = new mr, function(t, e) {
            var n = this.skeleton,
                r = this.geometry;
            nc.fromBufferAttribute(r.attributes.skinIndex, t), rc.fromBufferAttribute(r.attributes.skinWeight, t), ec.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
            for (var i = 0; i < 4; i++) {
                var o, a = rc.getComponent(i);
                0 !== a && (o = nc.getComponent(i), oc.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), e.addScaledVector(ic.copy(ec).applyMatrix4(oc), a))
            }
            return e.applyMatrix4(this.bindMatrixInverse)
        })
    });
    var uc = new mr,
        hc = new mr;

    function pc(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new mr) }
    }

    function dc() { kr.call(this), this.type = "Bone" }
    Object.assign(pc.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var n = new mr;
                this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
            }
        },
        pose: function() {
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var n = this.bones[t];
                n && n.matrixWorld.getInverse(this.boneInverses[t])
            }
            for (var r = 0, i = this.bones.length; r < i; r++) {
                var o = this.bones[r];
                o && (o.parent && o.parent.isBone ? (o.matrix.getInverse(o.parent.matrixWorld), o.matrix.multiply(o.matrixWorld)) : o.matrix.copy(o.matrixWorld), o.matrix.decompose(o.position, o.quaternion, o.scale))
            }
        },
        update: function() {
            for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, o = t.length; i < o; i++) {
                var a = t[i] ? t[i].matrixWorld : hc;
                uc.multiplyMatrices(a, e[i]), uc.toArray(n, 16 * i)
            }
            void 0 !== r && (r.needsUpdate = !0)
        },
        clone: function() { return new pc(this.bones, this.boneInverses) },
        getBoneByName: function(t) { for (var e = 0, n = this.bones.length; e < n; e++) { var r = this.bones[e]; if (r.name === t) return r } },
        dispose: function() { this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0) }
    }), dc.prototype = Object.assign(Object.create(kr.prototype), { constructor: dc, isBone: !0 });
    var fc = new mr,
        mc = new mr,
        gc = [],
        vc = new $i;

    function yc(t, e, n) { $i.call(this, t, e), this.instanceMatrix = new gi(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 }

    function _c(t) { pi.call(this), this.type = "LineBasicMaterial", this.color = new li(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) }
    yc.prototype = Object.assign(Object.create($i.prototype), {
        constructor: yc,
        isInstancedMesh: !0,
        copy: function(t) { return $i.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this },
        setColorAt: function(t, e) { null === this.instanceColor && (this.instanceColor = new gi(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t) },
        getMatrixAt: function(t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) },
        raycast: function(t, e) {
            var n = this.matrixWorld,
                r = this.count;
            if (vc.geometry = this.geometry, vc.material = this.material, void 0 !== vc.material)
                for (var i = 0; i < r; i++) {
                    this.getMatrixAt(i, fc), mc.multiplyMatrices(n, fc), vc.matrixWorld = mc, vc.raycast(t, gc);
                    for (var o = 0, a = gc.length; o < a; o++) {
                        var s = gc[o];
                        s.instanceId = i, s.object = this, e.push(s)
                    }
                    gc.length = 0
                }
        },
        setMatrixAt: function(t, e) { e.toArray(this.instanceMatrix.array, 16 * t) },
        updateMorphTargets: function() {}
    }), ((_c.prototype = Object.create(pi.prototype)).constructor = _c).prototype.isLineBasicMaterial = !0, _c.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this };
    var xc = new kn,
        bc = new kn,
        wc = new mr,
        Mc = new fr,
        Sc = new ar;

    function Ec(t, e, n) { 1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), kr.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Ni, this.material = void 0 !== e ? e : new _c, this.updateMorphTargets() }
    Ec.prototype = Object.assign(Object.create(kr.prototype), {
        constructor: Ec,
        isLine: !0,
        copy: function(t) { return kr.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this },
        computeLineDistances: function() {
            var t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [0], r = 1, i = e.count; r < i; r++) xc.fromBufferAttribute(e, r - 1), bc.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += xc.distanceTo(bc);
                    t.setAttribute("lineDistance", new Si(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                var o = t.vertices,
                    a = t.lineDistances;
                a[0] = 0;
                for (var s = 1, c = o.length; s < c; s++) a[s] = a[s - 1], a[s] += o[s - 1].distanceTo(o[s])
            }
            return this
        },
        raycast: function(t, e) {
            var n = this.geometry,
                r = this.matrixWorld,
                i = t.params.Line.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), Sc.copy(n.boundingSphere), Sc.applyMatrix4(r), Sc.radius += i, !1 !== t.ray.intersectsSphere(Sc)) {
                wc.getInverse(r), Mc.copy(t.ray).applyMatrix4(wc);
                var i = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = i * i,
                    a = new kn,
                    s = new kn,
                    c = new kn,
                    l = new kn,
                    u = this && this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    var i = n.index,
                        h = n.attributes.position.array;
                    if (null !== i)
                        for (var p = i.array, d = 0, f = p.length - 1; d < f; d += u) {
                            var m = p[d],
                                g = p[d + 1];
                            a.fromArray(h, 3 * m), s.fromArray(h, 3 * g), o < Mc.distanceSqToSegment(a, s, l, c) || (l.applyMatrix4(this.matrixWorld), (g = t.ray.origin.distanceTo(l)) < t.near || g > t.far || e.push({ distance: g, point: c.clone().applyMatrix4(this.matrixWorld), index: d, face: null, faceIndex: null, object: this }))
                        } else
                            for (var v, y = 0, _ = h.length / 3 - 1; y < _; y += u) a.fromArray(h, 3 * y), s.fromArray(h, 3 * y + 3), o < Mc.distanceSqToSegment(a, s, l, c) || (l.applyMatrix4(this.matrixWorld), (v = t.ray.origin.distanceTo(l)) < t.near || v > t.far || e.push({ distance: v, point: c.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this }))
                } else if (n.isGeometry)
                    for (var x, b = n.vertices, w = b.length, M = 0; M < w - 1; M += u) o < Mc.distanceSqToSegment(b[M], b[M + 1], l, c) || (l.applyMatrix4(this.matrixWorld), (x = t.ray.origin.distanceTo(l)) < t.near || x > t.far || e.push({ distance: x, point: c.clone().applyMatrix4(this.matrixWorld), index: M, face: null, faceIndex: null, object: this }))
            }
        },
        updateMorphTargets: function() {
            var t = this.geometry;
            if (t.isBufferGeometry) {
                var e = t.morphAttributes,
                    n = Object.keys(e);
                if (0 < n.length) {
                    var r = e[n[0]];
                    if (void 0 !== r) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (var i = 0, o = r.length; i < o; i++) {
                            var a = r[i].name || String(i);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = i
                        }
                    }
                }
            } else {
                t = t.morphTargets;
                void 0 !== t && 0 < t.length && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    });
    var Tc = new kn,
        Ac = new kn;

    function Lc(t, e) { Ec.call(this, t, e), this.type = "LineSegments" }

    function Rc(t, e) { Ec.call(this, t, e), this.type = "LineLoop" }

    function Cc(t) { pi.call(this), this.type = "PointsMaterial", this.color = new li(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) }
    Lc.prototype = Object.assign(Object.create(Ec.prototype), {
        constructor: Lc,
        isLineSegments: !0,
        computeLineDistances: function() {
            var t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [], r = 0, i = e.count; r < i; r += 2) Tc.fromBufferAttribute(e, r), Ac.fromBufferAttribute(e, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Tc.distanceTo(Ac);
                    t.setAttribute("lineDistance", new Si(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry)
                for (var o = t.vertices, a = t.lineDistances, s = 0, c = o.length; s < c; s += 2) Tc.copy(o[s]), Ac.copy(o[s + 1]), a[s] = 0 === s ? 0 : a[s - 1], a[s + 1] = a[s] + Tc.distanceTo(Ac);
            return this
        }
    }), Rc.prototype = Object.assign(Object.create(Ec.prototype), { constructor: Rc, isLineLoop: !0 }), ((Cc.prototype = Object.create(pi.prototype)).constructor = Cc).prototype.isPointsMaterial = !0, Cc.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this };
    var Pc = new mr,
        Oc = new fr,
        Ic = new ar,
        Dc = new kn;

    function Nc(t, e) { kr.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Ni, this.material = void 0 !== e ? e : new Cc, this.updateMorphTargets() }

    function Bc(t, e, n, r, i, o, a) {
        var s = Oc.distanceSqToPoint(t);
        s < n && (n = new kn, Oc.closestPointToPoint(t, n), n.applyMatrix4(r), (r = i.ray.origin.distanceTo(n)) < i.near || r > i.far || o.push({ distance: r, distanceToRay: Math.sqrt(s), point: n, index: e, face: null, object: a }))
    }

    function Fc(e, t, n, r, i, o, a, s, c) { Dn.call(this, e, t, n, r, i, o, a, s, c), this.format = void 0 !== a ? a : te, this.minFilter = void 0 !== o ? o : Ut, this.magFilter = void 0 !== i ? i : Ut, this.generateMipmaps = !1; var l = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() { l.needsUpdate = !0, e.requestVideoFrameCallback(t) }) }

    function Uc(t, e, n, r, i, o, a, s, c, l, u, h) { Dn.call(this, null, o, a, s, c, l, r, i, u, h), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 }

    function zc(t, e, n, r, i, o, a, s, c) { Dn.call(this, t, e, n, r, i, o, a, s, c), this.needsUpdate = !0 }

    function Hc(t, e, n, r, i, o, a, s, c, l) {
        if ((l = void 0 !== l ? l : oe) !== oe && l !== ae) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && l === oe && (n = jt), void 0 === n && l === ae && (n = Qt), Dn.call(this, null, r, i, o, a, s, l, n, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== a ? a : Nt, this.minFilter = void 0 !== s ? s : Nt, this.flipY = !1, this.generateMipmaps = !1
    }
    Nc.prototype = Object.assign(Object.create(kr.prototype), {
        constructor: Nc,
        isPoints: !0,
        copy: function(t) { return kr.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this },
        raycast: function(t, e) {
            var n = this.geometry,
                r = this.matrixWorld,
                i = t.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), Ic.copy(n.boundingSphere), Ic.applyMatrix4(r), Ic.radius += i, !1 !== t.ray.intersectsSphere(Ic)) {
                Pc.getInverse(r), Oc.copy(t.ray).applyMatrix4(Pc);
                var i = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = i * i;
                if (n.isBufferGeometry) {
                    var i = n.index,
                        a = n.attributes.position.array;
                    if (null !== i)
                        for (var s = i.array, c = 0, l = s.length; c < l; c++) {
                            var u = s[c];
                            Dc.fromArray(a, 3 * u), Bc(Dc, u, o, r, t, e, this)
                        } else
                            for (var h = 0, p = a.length / 3; h < p; h++) Dc.fromArray(a, 3 * h), Bc(Dc, h, o, r, t, e, this)
                } else
                    for (var d = n.vertices, f = 0, m = d.length; f < m; f++) Bc(d[f], f, o, r, t, e, this)
            }
        },
        updateMorphTargets: function() {
            var t = this.geometry;
            if (t.isBufferGeometry) {
                var e = t.morphAttributes,
                    n = Object.keys(e);
                if (0 < n.length) {
                    var r = e[n[0]];
                    if (void 0 !== r) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (var i = 0, o = r.length; i < o; i++) {
                            var a = r[i].name || String(i);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = i
                        }
                    }
                }
            } else {
                t = t.morphTargets;
                void 0 !== t && 0 < t.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }), Fc.prototype = Object.assign(Object.create(Dn.prototype), { constructor: Fc, isVideoTexture: !0, update: function() { var t = this.image;!1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), ((Uc.prototype = Object.create(Dn.prototype)).constructor = Uc).prototype.isCompressedTexture = !0, ((zc.prototype = Object.create(Dn.prototype)).constructor = zc).prototype.isCanvasTexture = !0, ((Hc.prototype = Object.create(Dn.prototype)).constructor = Hc).prototype.isDepthTexture = !0;
    var kc = function(N) {
        function t(t) {
            N.call(this), this.type = "WireframeGeometry";
            var e = [],
                n = [0, 0],
                r = {},
                i = ["a", "b", "c"];
            if (t && t.isGeometry) {
                for (var o, a = t.faces, s = 0, c = a.length; s < c; s++)
                    for (var l = a[s], u = 0; u < 3; u++) {
                        var h = l[i[u]],
                            p = l[i[(u + 1) % 3]];
                        n[0] = Math.min(h, p), n[1] = Math.max(h, p);
                        p = n[0] + "," + n[1];
                        void 0 === r[p] && (r[p] = { index1: n[0], index2: n[1] })
                    }
                for (o in r) {
                    var d = r[o],
                        f = t.vertices[d.index1];
                    e.push(f.x, f.y, f.z), f = t.vertices[d.index2], e.push(f.x, f.y, f.z)
                }
            } else if (t && t.isBufferGeometry) {
                var m = new kn;
                if (null !== t.index) {
                    var g = t.attributes.position,
                        v = t.index,
                        y = t.groups;
                    0 === y.length && (y = [{ start: 0, count: v.count, materialIndex: 0 }]);
                    for (var _, x = 0, b = y.length; x < b; ++x)
                        for (var w = y[x], M = w.start, S = M, E = M + w.count; S < E; S += 3)
                            for (var T = 0; T < 3; T++) {
                                var A = v.getX(S + T),
                                    L = v.getX(S + (T + 1) % 3);
                                n[0] = Math.min(A, L), n[1] = Math.max(A, L);
                                L = n[0] + "," + n[1];
                                void 0 === r[L] && (r[L] = { index1: n[0], index2: n[1] })
                            }
                    for (_ in r) {
                        var R = r[_];
                        m.fromBufferAttribute(g, R.index1), e.push(m.x, m.y, m.z), m.fromBufferAttribute(g, R.index2), e.push(m.x, m.y, m.z)
                    }
                } else
                    for (var C = t.attributes.position, P = 0, O = C.count / 3; P < O; P++)
                        for (var I = 0; I < 3; I++) {
                            var D = 3 * P + I;
                            m.fromBufferAttribute(C, D), e.push(m.x, m.y, m.z);
                            D = 3 * P + (I + 1) % 3;
                            m.fromBufferAttribute(C, D), e.push(m.x, m.y, m.z)
                        }
            }
            this.setAttribute("position", new Si(e, 3))
        }
        return N && (t.__proto__ = N), (t.prototype = Object.create(N && N.prototype)).constructor = t
    }(Ni);

    function Gc(t, e, n) { ao.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: n }, this.fromBufferGeometry(new Vc(t, e, n)), this.mergeVertices() }

    function Vc(t, e, n) {
        Ni.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: n };
        var r = [],
            i = [],
            o = [],
            a = [],
            s = new kn,
            c = new kn,
            l = new kn,
            u = new kn,
            h = new kn;
        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        for (var p = e + 1, d = 0; d <= n; d++)
            for (var f = d / n, m = 0; m <= e; m++) {
                var g = m / e;
                t(g, f, c), i.push(c.x, c.y, c.z), 0 <= g - 1e-5 ? (t(g - 1e-5, f, l), u.subVectors(c, l)) : (t(1e-5 + g, f, l), u.subVectors(l, c)), 0 <= f - 1e-5 ? (t(g, f - 1e-5, l), h.subVectors(c, l)) : (t(g, 1e-5 + f, l), h.subVectors(l, c)), s.crossVectors(u, h).normalize(), o.push(s.x, s.y, s.z), a.push(g, f)
            }
        for (var v = 0; v < n; v++)
            for (var y = 0; y < e; y++) {
                var _ = v * p + y,
                    x = v * p + y + 1,
                    b = (v + 1) * p + y + 1,
                    w = (v + 1) * p + y;
                r.push(_, x, w), r.push(x, b, w)
            }
        this.setIndex(r), this.setAttribute("position", new Si(i, 3)), this.setAttribute("normal", new Si(o, 3)), this.setAttribute("uv", new Si(a, 2))
    }(Gc.prototype = Object.create(ao.prototype)).constructor = Gc, (Vc.prototype = Object.create(Ni.prototype)).constructor = Vc;
    var jc = function(i) {
            function t(t, e, n, r) { i.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: r }, this.fromBufferGeometry(new Wc(t, e, n, r)), this.mergeVertices() }
            return i && (t.__proto__ = i), (t.prototype = Object.create(i && i.prototype)).constructor = t
        }(ao),
        Wc = function(r) {
            function t(n, o, t, e) {
                r.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: n, indices: o, radius: t, detail: e }, t = t || 1;
                var u = [],
                    h = [];

                function f(t) { u.push(t.x, t.y, t.z) }

                function a(t, e) {
                    t *= 3;
                    e.x = n[0 + t], e.y = n[1 + t], e.z = n[2 + t]
                }

                function p(t, e, n, r) { r < 0 && 1 === t.x && (h[e] = t.x - 1), 0 === n.x && 0 === n.z && (h[e] = r / 2 / Math.PI + .5) }

                function d(t) { return Math.atan2(t.z, -t.x) }! function(t) {
                    for (var e = new kn, n = new kn, r = new kn, i = 0; i < o.length; i += 3) a(o[i + 0], e), a(o[i + 1], n), a(o[i + 2], r),
                        function(t, e, n, r) {
                            for (var i = Math.pow(2, r), o = [], a = 0; a <= i; a++) { o[a] = []; for (var s = t.clone().lerp(n, a / i), c = e.clone().lerp(n, a / i), l = i - a, u = 0; u <= l; u++) o[a][u] = 0 === u && a === i ? s : s.clone().lerp(c, u / l) }
                            for (var h = 0; h < i; h++)
                                for (var p = 0; p < 2 * (i - h) - 1; p++) {
                                    var d = Math.floor(p / 2);
                                    p % 2 == 0 ? (f(o[h][d + 1]), f(o[h + 1][d]), f(o[h][d])) : (f(o[h][d + 1]), f(o[h + 1][d + 1]), f(o[h + 1][d]))
                                }
                        }(e, n, r, t)
                }(e = e || 0),
                function(t) { for (var e = new kn, n = 0; n < u.length; n += 3) e.x = u[n + 0], e.y = u[n + 1], e.z = u[n + 2], e.normalize().multiplyScalar(t), u[n + 0] = e.x, u[n + 1] = e.y, u[n + 2] = e.z }(t),
                function() {
                    for (var t = new kn, e = 0; e < u.length; e += 3) {
                        t.x = u[e + 0], t.y = u[e + 1], t.z = u[e + 2];
                        var n = d(t) / 2 / Math.PI + .5,
                            r = function(t) { return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) }(t) / Math.PI + .5;
                        h.push(n, 1 - r)
                    }(function() {
                        for (var t = new kn, e = new kn, n = new kn, r = new kn, i = new Ln, o = new Ln, a = new Ln, s = 0, c = 0; s < u.length; s += 9, c += 6) {
                            t.set(u[s + 0], u[s + 1], u[s + 2]), e.set(u[s + 3], u[s + 4], u[s + 5]), n.set(u[s + 6], u[s + 7], u[s + 8]), i.set(h[c + 0], h[c + 1]), o.set(h[c + 2], h[c + 3]), a.set(h[c + 4], h[c + 5]), r.copy(t).add(e).add(n).divideScalar(3);
                            var l = d(r);
                            p(i, c + 0, t, l), p(o, c + 2, e, l), p(a, c + 4, n, l)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < h.length; t += 6) {
                            var e = h[t + 0],
                                n = h[t + 2],
                                r = h[t + 4],
                                i = Math.max(e, n, r),
                                o = Math.min(e, n, r);
                            .9 < i && o < .1 && (e < .2 && (h[t + 0] += 1), n < .2 && (h[t + 2] += 1), r < .2 && (h[t + 4] += 1))
                        }
                    }()
                }(), this.setAttribute("position", new Si(u, 3)), this.setAttribute("normal", new Si(u.slice(), 3)), this.setAttribute("uv", new Si(h, 2)), 0 === e ? this.computeVertexNormals() : this.normalizeNormals()
            }
            return r && (t.__proto__ = r), (t.prototype = Object.create(r && r.prototype)).constructor = t
        }(Ni),
        qc = function(n) {
            function t(t, e) { n.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Xc(t, e)), this.mergeVertices() }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(ao),
        Xc = function(n) {
            function t(t, e) { n.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e } }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(Wc),
        Yc = function(n) {
            function t(t, e) { n.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Zc(t, e)), this.mergeVertices() }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(ao),
        Zc = function(n) {
            function t(t, e) { n.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e } }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(Wc),
        Jc = function(n) {
            function t(t, e) { n.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Kc(t, e)), this.mergeVertices() }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(ao),
        Kc = function(r) {
            function t(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    n = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                r.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e }
            }
            return r && (t.__proto__ = r), (t.prototype = Object.create(r && r.prototype)).constructor = t
        }(Wc),
        Qc = function(n) {
            function t(t, e) { n.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new $c(t, e)), this.mergeVertices() }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(ao),
        $c = function(i) {
            function t(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
                i.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e }
            }
            return i && (t.__proto__ = i), (t.prototype = Object.create(i && i.prototype)).constructor = t
        }(Wc),
        tl = function(a) {
            function t(t, e, n, r, i, o) {
                a.call(this), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: r, closed: i }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                i = new el(t, e, n, r, i);
                this.tangents = i.tangents, this.normals = i.normals, this.binormals = i.binormals, this.fromBufferGeometry(i), this.mergeVertices()
            }
            return a && (t.__proto__ = a), (t.prototype = Object.create(a && a.prototype)).constructor = t
        }(ao),
        el = function(o) {
            function t(a, s, c, l, e) {
                o.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: a, tubularSegments: s, radius: c, radialSegments: l, closed: e }, s = s || 64, c = c || 1, l = l || 8, e = e || !1;
                var u = a.computeFrenetFrames(s, e);
                this.tangents = u.tangents, this.normals = u.normals, this.binormals = u.binormals;
                var h = new kn,
                    p = new kn,
                    n = new Ln,
                    d = new kn,
                    f = [],
                    m = [],
                    r = [],
                    g = [];

                function i(t) {
                    d = a.getPointAt(t / s, d);
                    for (var e = u.normals[t], n = u.binormals[t], r = 0; r <= l; r++) {
                        var i = r / l * Math.PI * 2,
                            o = Math.sin(i),
                            i = -Math.cos(i);
                        p.x = i * e.x + o * n.x, p.y = i * e.y + o * n.y, p.z = i * e.z + o * n.z, p.normalize(), m.push(p.x, p.y, p.z), h.x = d.x + c * p.x, h.y = d.y + c * p.y, h.z = d.z + c * p.z, f.push(h.x, h.y, h.z)
                    }
                }! function() {
                    for (var t = 0; t < s; t++) i(t);
                    i(!1 === e ? s : 0),
                        function() {
                            for (var t = 0; t <= s; t++)
                                for (var e = 0; e <= l; e++) n.x = t / s, n.y = e / l, r.push(n.x, n.y)
                        }(),
                        function() {
                            for (var t = 1; t <= s; t++)
                                for (var e = 1; e <= l; e++) {
                                    var n = (l + 1) * (t - 1) + (e - 1),
                                        r = (l + 1) * t + (e - 1),
                                        i = (l + 1) * t + e,
                                        o = (l + 1) * (t - 1) + e;
                                    g.push(n, r, o), g.push(r, i, o)
                                }
                        }()
                }(), this.setIndex(g), this.setAttribute("position", new Si(f, 3)), this.setAttribute("normal", new Si(m, 3)), this.setAttribute("uv", new Si(r, 2))
            }
            return o && (t.__proto__ = o), ((t.prototype = Object.create(o && o.prototype)).constructor = t).prototype.toJSON = function() { var t = o.prototype.toJSON.call(this); return t.path = this.parameters.path.toJSON(), t }, t
        }(Ni),
        nl = function(s) {
            function t(t, e, n, r, i, o, a) { s.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: r, p: i, q: o }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new rl(t, e, n, r, i, o)), this.mergeVertices() }
            return s && (t.__proto__ = s), (t.prototype = Object.create(s && s.prototype)).constructor = t
        }(ao),
        rl = function(R) {
            function t(t, e, n, r, i, o) {
                R.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: r, p: i, q: o }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
                for (var a = [], s = [], c = [], l = [], u = new kn, h = new kn, p = new kn, d = new kn, f = new kn, m = new kn, g = new kn, v = 0; v <= n; ++v) {
                    var y = v / n * i * Math.PI * 2;
                    L(y, i, o, t, p), L(.01 + y, i, o, t, d), m.subVectors(d, p), g.addVectors(d, p), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
                    for (var _ = 0; _ <= r; ++_) {
                        var x = _ / r * Math.PI * 2,
                            b = -e * Math.cos(x),
                            x = e * Math.sin(x);
                        u.x = p.x + (b * g.x + x * f.x), u.y = p.y + (b * g.y + x * f.y), u.z = p.z + (b * g.z + x * f.z), s.push(u.x, u.y, u.z), h.subVectors(u, p).normalize(), c.push(h.x, h.y, h.z), l.push(v / n), l.push(_ / r)
                    }
                }
                for (var w = 1; w <= n; w++)
                    for (var M = 1; M <= r; M++) {
                        var S = (r + 1) * (w - 1) + (M - 1),
                            E = (r + 1) * w + (M - 1),
                            T = (r + 1) * w + M,
                            A = (r + 1) * (w - 1) + M;
                        a.push(S, E, A), a.push(E, T, A)
                    }

                function L(t, e, n, r, i) {
                    var o = Math.cos(t),
                        a = Math.sin(t),
                        e = n / e * t,
                        t = Math.cos(e);
                    i.x = r * (2 + t) * .5 * o, i.y = r * (2 + t) * a * .5, i.z = r * Math.sin(e) * .5
                }
                this.setIndex(a), this.setAttribute("position", new Si(s, 3)), this.setAttribute("normal", new Si(c, 3)), this.setAttribute("uv", new Si(l, 2))
            }
            return R && (t.__proto__ = R), (t.prototype = Object.create(R && R.prototype)).constructor = t
        }(Ni),
        il = function(o) {
            function t(t, e, n, r, i) { o.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: r, arc: i }, this.fromBufferGeometry(new ol(t, e, n, r, i)), this.mergeVertices() }
            return o && (t.__proto__ = o), (t.prototype = Object.create(o && o.prototype)).constructor = t
        }(ao),
        ol = function(w) {
            function t(t, e, n, r, i) {
                w.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: r, arc: i }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
                for (var o = [], a = [], s = [], c = [], l = new kn, u = new kn, h = new kn, p = 0; p <= n; p++)
                    for (var d = 0; d <= r; d++) {
                        var f = d / r * i,
                            m = p / n * Math.PI * 2;
                        u.x = (t + e * Math.cos(m)) * Math.cos(f), u.y = (t + e * Math.cos(m)) * Math.sin(f), u.z = e * Math.sin(m), a.push(u.x, u.y, u.z), l.x = t * Math.cos(f), l.y = t * Math.sin(f), h.subVectors(u, l).normalize(), s.push(h.x, h.y, h.z), c.push(d / r), c.push(p / n)
                    }
                for (var g = 1; g <= n; g++)
                    for (var v = 1; v <= r; v++) {
                        var y = (r + 1) * g + v - 1,
                            _ = (r + 1) * (g - 1) + v - 1,
                            x = (r + 1) * (g - 1) + v,
                            b = (r + 1) * g + v;
                        o.push(y, _, b), o.push(_, x, b)
                    }
                this.setIndex(o), this.setAttribute("position", new Si(a, 3)), this.setAttribute("normal", new Si(s, 3)), this.setAttribute("uv", new Si(c, 2))
            }
            return w && (t.__proto__ = w), (t.prototype = Object.create(w && w.prototype)).constructor = t
        }(Ni),
        al = function(t, e, n) {
            n = n || 2;
            var r, i, o, a, s, c, l, u = e && e.length,
                h = u ? e[0] * n : t.length,
                p = sl(t, 0, h, n, !0),
                d = [];
            if (!p || p.next === p.prev) return d;
            if (u && (p = function(t, e, n, r) {
                    var i, o, a, s, c = [];
                    for (i = 0, o = e.length; i < o; i++) a = e[i] * r, s = i < o - 1 ? e[i + 1] * r : t.length, (s = sl(t, a, s, r, !1)) === s.next && (s.steiner = !0), c.push(function(t) {
                        var e = t,
                            n = t;
                        for (;
                            (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next, e !== t;);
                        return n
                    }(s));
                    for (c.sort(ul), i = 0; i < c.length; i++) ! function(t, e) {
                        (e = function(t, e) {
                            var n, r = e,
                                i = t.x,
                                o = t.y,
                                a = -1 / 0;
                            do {
                                if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                                    var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                    if (s <= i && a < s) {
                                        if ((a = s) === i) { if (o === r.y) return r; if (o === r.next.y) return r.next }
                                        n = r.x < r.next.x ? r : r.next
                                    }
                                }
                            } while (r = r.next, r !== e);
                            if (!n) return null;
                            if (i === a) return n;
                            var c, l = n,
                                u = n.x,
                                h = n.y,
                                p = 1 / 0;
                            r = n;
                            for (; i >= r.x && r.x >= u && i !== r.x && pl(o < h ? i : a, o, u, h, o < h ? a : i, o, r.x, r.y) && (c = Math.abs(o - r.y) / (i - r.x), yl(r, t) && (c < p || c === p && (r.x > n.x || r.x === n.x && function(t, e) { return dl(t.prev, t, e.prev) < 0 && dl(e.next, t, t.next) < 0 }(n, r))) && (n = r, p = c)), r = r.next, r !== l;);
                            return n
                        }(t, e)) && (t = _l(e, t), cl(e, e.next), cl(t, t.next))
                    }(c[i], n), n = cl(n, n.next);
                    return n
                }(t, e, p, n)), t.length > 80 * n) {
                r = o = t[0], i = a = t[1];
                for (var f = n; f < h; f += n)(s = t[f]) < r && (r = s), (c = t[f + 1]) < i && (i = c), o < s && (o = s), a < c && (a = c);
                l = 0 !== (l = Math.max(o - r, a - i)) ? 1 / l : 0
            }
            return ll(p, d, n, r, i, l), d
        };

    function sl(t, e, n, r, i) {
        var o, a;
        if (i === 0 < function(t, e, n, r) { for (var i = 0, o = e, a = n - r; o < n; o += r) i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o; return i }(t, e, n, r))
            for (o = e; o < n; o += r) a = xl(o, t[o], t[o + 1], a);
        else
            for (o = n - r; e <= o; o -= r) a = xl(o, t[o], t[o + 1], a);
        return a && fl(a, a.next) && (bl(a), a = a.next), a
    }

    function cl(t, e) {
        if (!t) return t;
        e = e || t;
        var n, r = t;
        do {
            if (n = !1, r.steiner || !fl(r, r.next) && 0 !== dl(r.prev, r, r.next)) r = r.next;
            else {
                if (bl(r), (r = e = r.prev) === r.next) break;
                n = !0
            }
        } while (n || r !== e);
        return e
    }

    function ll(t, e, n, r, i, o, a) {
        if (t) {
            !a && o && function(t, e, n, r) {
                var i = t;
                for (; null === i.z && (i.z = hl(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next, i !== t;);
                i.prevZ.nextZ = null, i.prevZ = null,
                    function(t) {
                        var e, n, r, i, o, a, s, c, l = 1;
                        do {
                            for (n = t, o = t = null, a = 0; n;) {
                                for (a++, r = n, e = s = 0; e < l && (s++, r = r.nextZ); e++);
                                for (c = l; 0 < s || 0 < c && r;) 0 !== s && (0 === c || !r || n.z <= r.z) ? (n = (i = n).nextZ, s--) : (r = (i = r).nextZ, c--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                                n = r
                            }
                        } while (o.nextZ = null, l *= 2, 1 < a)
                    }(i)
            }(t, r, i, o);
            for (var s, c, l = t; t.prev !== t.next;)
                if (s = t.prev, c = t.next, o ? function(t, e, n, r) {
                        var i = t.prev,
                            o = t,
                            a = t.next;
                        if (0 <= dl(i, o, a)) return !1;
                        var s = (i.x < o.x ? i.x < a.x ? i : a : o.x < a.x ? o : a).x,
                            c = (i.y < o.y ? i.y < a.y ? i : a : o.y < a.y ? o : a).y,
                            l = (i.x > o.x ? i.x > a.x ? i : a : o.x > a.x ? o : a).x,
                            u = (i.y > o.y ? i.y > a.y ? i : a : o.y > a.y ? o : a).y,
                            h = hl(s, c, e, n, r),
                            p = hl(l, u, e, n, r),
                            d = t.prevZ,
                            f = t.nextZ;
                        for (; d && d.z >= h && f && f.z <= p;) {
                            if (d !== t.prev && d !== t.next && pl(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && 0 <= dl(d.prev, d, d.next)) return !1;
                            if (d = d.prevZ, f !== t.prev && f !== t.next && pl(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && 0 <= dl(f.prev, f, f.next)) return !1;
                            f = f.nextZ
                        }
                        for (; d && d.z >= h;) {
                            if (d !== t.prev && d !== t.next && pl(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && 0 <= dl(d.prev, d, d.next)) return !1;
                            d = d.prevZ
                        }
                        for (; f && f.z <= p;) {
                            if (f !== t.prev && f !== t.next && pl(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && 0 <= dl(f.prev, f, f.next)) return !1;
                            f = f.nextZ
                        }
                        return !0
                    }(t, r, i, o) : function(t) {
                        var e = t.prev,
                            n = t,
                            r = t.next;
                        if (0 <= dl(e, n, r)) return !1;
                        var i = t.next.next;
                        for (; i !== t.prev;) {
                            if (pl(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= dl(i.prev, i, i.next)) return !1;
                            i = i.next
                        }
                        return !0
                    }(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), bl(t), t = c.next, l = c.next;
                else if ((t = c) === l) {
                a ? 1 === a ? ll(t = function(t, e, n) {
                    var r = t;
                    do {
                        var i = r.prev,
                            o = r.next.next
                    } while (!fl(i, o) && ml(i, r, r.next, o) && yl(i, o) && yl(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), bl(r), bl(r.next), r = t = o), r = r.next, r !== t);
                    return cl(r)
                }(cl(t), e, n), e, n, r, i, o, 2) : 2 === a && function(t, e, n, r, i, o) {
                    var a = t;
                    do {
                        for (var s = a.next.next; s !== a.prev;) {
                            if (a.i !== s.i && function(t, e) {
                                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                                        var n = t;
                                        do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && ml(n, n.next, t, e)) return !0 } while (n = n.next, n !== t);
                                        return !1
                                    }(t, e) && (yl(t, e) && yl(e, t) && function(t, e) {
                                        var n = t,
                                            r = !1,
                                            i = (t.x + e.x) / 2,
                                            o = (t.y + e.y) / 2;
                                        for (; n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next, n !== t;);
                                        return r
                                    }(t, e) && (dl(t.prev, t, e.prev) || dl(t, e.prev, e)) || fl(t, e) && 0 < dl(t.prev, t, t.next) && 0 < dl(e.prev, e, e.next))
                                }(a, s)) { var c = _l(a, s); return a = cl(a, a.next), c = cl(c, c.next), ll(a, e, n, r, i, o), ll(c, e, n, r, i, o) }
                            s = s.next
                        }
                    } while (a = a.next, a !== t)
                }(t, e, n, r, i, o) : ll(cl(t), e, n, r, i, o, 1);
                break
            }
        }
    }

    function ul(t, e) { return t.x - e.x }

    function hl(t, e, n, r, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 }

    function pl(t, e, n, r, i, o, a, s) { return 0 <= (i - a) * (e - s) - (t - a) * (o - s) && 0 <= (t - a) * (r - s) - (n - a) * (e - s) && 0 <= (n - a) * (o - s) - (i - a) * (r - s) }

    function dl(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) }

    function fl(t, e) { return t.x === e.x && t.y === e.y }

    function ml(t, e, n, r) {
        var i = vl(dl(t, e, n)),
            o = vl(dl(t, e, r)),
            a = vl(dl(n, r, t)),
            s = vl(dl(n, r, e));
        return i !== o && a !== s || (0 === i && gl(t, n, e) || (0 === o && gl(t, r, e) || (0 === a && gl(n, t, r) || !(0 !== s || !gl(n, e, r)))))
    }

    function gl(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) }

    function vl(t) { return 0 < t ? 1 : t < 0 ? -1 : 0 }

    function yl(t, e) { return dl(t.prev, t, t.next) < 0 ? 0 <= dl(t, e, t.next) && 0 <= dl(t, t.prev, e) : dl(t, e, t.prev) < 0 || dl(t, t.next, e) < 0 }

    function _l(t, e) {
        var n = new wl(t.i, t.x, t.y),
            r = new wl(e.i, e.x, e.y),
            i = t.next,
            o = e.prev;
        return (t.next = e).prev = t, (n.next = i).prev = n, (r.next = n).prev = r, (o.next = r).prev = o, r
    }

    function xl(t, e, n, r) { n = new wl(t, e, n); return r ? (n.next = r.next, (n.prev = r).next.prev = n, r.next = n) : (n.prev = n).next = n, n }

    function bl(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) }

    function wl(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }
    var Ml = {
        area: function(t) { for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y; return .5 * n },
        isClockWise: function(t) { return Ml.area(t) < 0 },
        triangulateShape: function(t, e) {
            var n = [],
                r = [],
                i = [];
            Sl(t), El(n, t);
            var o = t.length;
            e.forEach(Sl);
            for (var a = 0; a < e.length; a++) r.push(o), o += e[a].length, El(n, e[a]);
            for (var s = al(n, r), c = 0; c < s.length; c += 3) i.push(s.slice(c, c + 3));
            return i
        }
    };

    function Sl(t) {
        var e = t.length;
        2 < e && t[e - 1].equals(t[0]) && t.pop()
    }

    function El(t, e) { for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y) }
    var Tl = function(n) {
            function t(t, e) { n.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new Al(t, e)), this.mergeVertices() }
            return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.toJSON = function() { var t = n.prototype.toJSON.call(this); return Rl(this.parameters.shapes, this.parameters.options, t) }, t
        }(ao),
        Al = function(r) {
            function t(t, Ct) {
                r.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: Ct }, t = Array.isArray(t) ? t : [t];
                for (var Pt = this, Ot = [], It = [], e = 0, n = t.length; e < n; e++) ! function(t) {
                    var r = [],
                        e = void 0 !== Ct.curveSegments ? Ct.curveSegments : 12,
                        u = void 0 !== Ct.steps ? Ct.steps : 1,
                        n = void 0 !== Ct.depth ? Ct.depth : 100,
                        h = void 0 === Ct.bevelEnabled || Ct.bevelEnabled,
                        i = void 0 !== Ct.bevelThickness ? Ct.bevelThickness : 6,
                        o = void 0 !== Ct.bevelSize ? Ct.bevelSize : i - 2,
                        a = void 0 !== Ct.bevelOffset ? Ct.bevelOffset : 0,
                        p = void 0 !== Ct.bevelSegments ? Ct.bevelSegments : 3,
                        s = Ct.extrudePath,
                        l = void 0 !== Ct.UVGenerator ? Ct.UVGenerator : Ll;
                    void 0 !== Ct.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), n = Ct.amount);
                    var c, d, f, m, g, v = !1;
                    s && (c = s.getSpacedPoints(u), h = !(v = !0), d = s.computeFrenetFrames(u, !1), f = new kn, m = new kn, g = new kn);
                    h || (a = o = i = p = 0);
                    var e = t.extractPoints(e),
                        y = e.shape,
                        _ = e.holes;
                    if (!Ml.isClockWise(y)) {
                        y = y.reverse();
                        for (var x = 0, b = _.length; x < b; x++) {
                            var w = _[x];
                            Ml.isClockWise(w) && (_[x] = w.reverse())
                        }
                    }
                    for (var M = Ml.triangulateShape(y, _), S = y, E = 0, T = _.length; E < T; E++) {
                        var A = _[E];
                        y = y.concat(A)
                    }

                    function L(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) }
                    var R = y.length,
                        C = M.length;

                    function P(t, e, n) {
                        var r = t.x - e.x,
                            i = t.y - e.y,
                            o = n.x - t.x,
                            a = n.y - t.y,
                            s = r * r + i * i,
                            c = r * a - i * o;
                        if (Math.abs(c) > Number.EPSILON) {
                            var l = Math.sqrt(s),
                                u = Math.sqrt(o * o + a * a),
                                h = e.x - i / l,
                                p = e.y + r / l,
                                l = ((n.x - a / u - h) * a - (n.y + o / u - p) * o) / (r * a - i * o),
                                p = (u = h + r * l - t.x) * u + (h = p + i * l - t.y) * h;
                            if (p <= 2) return new Ln(u, h);
                            l = Math.sqrt(p / 2)
                        } else {
                            p = !1;
                            r > Number.EPSILON ? o > Number.EPSILON && (p = !0) : r < -Number.EPSILON ? o < -Number.EPSILON && (p = !0) : Math.sign(i) === Math.sign(a) && (p = !0), l = p ? (u = -i, h = r, Math.sqrt(s)) : (u = r, h = i, Math.sqrt(s / 2))
                        }
                        return new Ln(u / l, h / l)
                    }
                    for (var O = [], I = 0, D = S.length, N = D - 1, B = I + 1; I < D; I++, N++, B++) N === D && (N = 0), B === D && (B = 0), O[I] = P(S[I], S[N], S[B]);
                    for (var F, U = [], z = O.concat(), H = 0, k = _.length; H < k; H++) {
                        var G = _[H];
                        F = [];
                        for (var V = 0, j = G.length, W = j - 1, q = V + 1; V < j; V++, W++, q++) W === j && (W = 0), q === j && (q = 0), F[V] = P(G[V], G[W], G[q]);
                        U.push(F), z = z.concat(F)
                    }
                    for (var X = 0; X < p; X++) {
                        for (var Y = X / p, Z = i * Math.cos(Y * Math.PI / 2), J = o * Math.sin(Y * Math.PI / 2) + a, K = 0, Q = S.length; K < Q; K++) {
                            var $ = L(S[K], O[K], J);
                            Tt($.x, $.y, -Z)
                        }
                        for (var tt = 0, et = _.length; tt < et; tt++) {
                            var nt = _[tt];
                            F = U[tt];
                            for (var rt = 0, it = nt.length; rt < it; rt++) {
                                var ot = L(nt[rt], F[rt], J);
                                Tt(ot.x, ot.y, -Z)
                            }
                        }
                    }
                    for (var at = o + a, st = 0; st < R; st++) {
                        var ct = h ? L(y[st], z[st], at) : y[st];
                        v ? (m.copy(d.normals[0]).multiplyScalar(ct.x), f.copy(d.binormals[0]).multiplyScalar(ct.y), g.copy(c[0]).add(m).add(f), Tt(g.x, g.y, g.z)) : Tt(ct.x, ct.y, 0)
                    }
                    for (var lt = 1; lt <= u; lt++)
                        for (var ut = 0; ut < R; ut++) {
                            var ht = h ? L(y[ut], z[ut], at) : y[ut];
                            v ? (m.copy(d.normals[lt]).multiplyScalar(ht.x), f.copy(d.binormals[lt]).multiplyScalar(ht.y), g.copy(c[lt]).add(m).add(f), Tt(g.x, g.y, g.z)) : Tt(ht.x, ht.y, n / u * lt)
                        }
                    for (var pt = p - 1; 0 <= pt; pt--) {
                        for (var dt = pt / p, ft = i * Math.cos(dt * Math.PI / 2), mt = o * Math.sin(dt * Math.PI / 2) + a, gt = 0, vt = S.length; gt < vt; gt++) {
                            var yt = L(S[gt], O[gt], mt);
                            Tt(yt.x, yt.y, n + ft)
                        }
                        for (var _t = 0, xt = _.length; _t < xt; _t++) {
                            var bt = _[_t];
                            F = U[_t];
                            for (var wt = 0, Mt = bt.length; wt < Mt; wt++) {
                                var St = L(bt[wt], F[wt], mt);
                                v ? Tt(St.x, St.y + c[u - 1].y, c[u - 1].x + ft) : Tt(St.x, St.y, n + ft)
                            }
                        }
                    }

                    function Et(t, e) {
                        for (var n = t.length; 0 <= --n;) {
                            var r = n,
                                i = n - 1;
                            i < 0 && (i = t.length - 1);
                            for (var o = 0, a = u + 2 * p; o < a; o++) {
                                var s = R * o,
                                    c = R * (o + 1);
                                ! function(t, e, n, r) {
                                    Lt(t), Lt(e), Lt(r), Lt(e), Lt(n), Lt(r);
                                    r = Ot.length / 3, r = l.generateSideWallUV(Pt, Ot, r - 6, r - 3, r - 2, r - 1);
                                    Rt(r[0]), Rt(r[1]), Rt(r[3]), Rt(r[1]), Rt(r[2]), Rt(r[3])
                                }(e + r + s, e + i + s, e + i + c, e + r + c)
                            }
                        }
                    }

                    function Tt(t, e, n) { r.push(t), r.push(e), r.push(n) }

                    function At(t, e, n) {
                        Lt(t), Lt(e), Lt(n);
                        n = Ot.length / 3, n = l.generateTopUV(Pt, Ot, n - 3, n - 2, n - 1);
                        Rt(n[0]), Rt(n[1]), Rt(n[2])
                    }

                    function Lt(t) { Ot.push(r[3 * t + 0]), Ot.push(r[3 * t + 1]), Ot.push(r[3 * t + 2]) }

                    function Rt(t) { It.push(t.x), It.push(t.y) }(function() {
                        var t = Ot.length / 3;
                        if (h) {
                            for (var e = 0 * R, n = 0; n < C; n++) {
                                var r = M[n];
                                At(r[2] + e, r[1] + e, r[0] + e)
                            }
                            e = R * (u + 2 * p);
                            for (var i = 0; i < C; i++) {
                                var o = M[i];
                                At(o[0] + e, o[1] + e, o[2] + e)
                            }
                        } else {
                            for (var a = 0; a < C; a++) {
                                var s = M[a];
                                At(s[2], s[1], s[0])
                            }
                            for (var c = 0; c < C; c++) {
                                var l = M[c];
                                At(l[0] + R * u, l[1] + R * u, l[2] + R * u)
                            }
                        }
                        Pt.addGroup(t, Ot.length / 3 - t, 0)
                    })(),
                    function() {
                        var t = Ot.length / 3,
                            e = 0;
                        Et(S, e), e += S.length;
                        for (var n = 0, r = _.length; n < r; n++) {
                            var i = _[n];
                            Et(i, e), e += i.length
                        }
                        Pt.addGroup(t, Ot.length / 3 - t, 1)
                    }()
                }(t[e]);
                this.setAttribute("position", new Si(Ot, 3)), this.setAttribute("uv", new Si(It, 2)), this.computeVertexNormals()
            }
            return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.toJSON = function() { var t = r.prototype.toJSON.call(this); return Rl(this.parameters.shapes, this.parameters.options, t) }, t
        }(Ni),
        Ll = {
            generateTopUV: function(t, e, n, r, i) {
                var o = e[3 * n],
                    a = e[3 * n + 1],
                    s = e[3 * r],
                    n = e[3 * r + 1],
                    r = e[3 * i],
                    i = e[3 * i + 1];
                return [new Ln(o, a), new Ln(s, n), new Ln(r, i)]
            },
            generateSideWallUV: function(t, e, n, r, i, o) {
                var a = e[3 * n],
                    s = e[3 * n + 1],
                    c = e[3 * n + 2],
                    l = e[3 * r],
                    u = e[3 * r + 1],
                    h = e[3 * r + 2],
                    p = e[3 * i],
                    d = e[3 * i + 1],
                    n = e[3 * i + 2],
                    r = e[3 * o],
                    i = e[3 * o + 1],
                    o = e[3 * o + 2];
                return Math.abs(s - u) < .01 ? [new Ln(a, 1 - c), new Ln(l, 1 - h), new Ln(p, 1 - n), new Ln(r, 1 - o)] : [new Ln(s, 1 - c), new Ln(u, 1 - h), new Ln(d, 1 - n), new Ln(i, 1 - o)]
            }
        };

    function Rl(t, e, n) {
        if (n.shapes = [], Array.isArray(t))
            for (var r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                n.shapes.push(o.uuid)
            } else n.shapes.push(t.uuid);
        return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
    }
    var Cl = function(n) {
            function t(t, e) { n.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new Pl(t, e)), this.mergeVertices() }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(ao),
        Pl = function(r) {
            function t(t, e) {
                var n = (e = e || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ao;
                t = n.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), r.call(this, t, e), this.type = "TextBufferGeometry"
            }
            return r && (t.__proto__ = r), (t.prototype = Object.create(r && r.prototype)).constructor = t
        }(Al),
        Ol = function(s) {
            function t(t, e, n, r, i, o, a) { s.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: r, phiLength: i, thetaStart: o, thetaLength: a }, this.fromBufferGeometry(new Il(t, e, n, r, i, o, a)), this.mergeVertices() }
            return s && (t.__proto__ = s), (t.prototype = Object.create(s && s.prototype)).constructor = t
        }(ao),
        Il = function(L) {
            function t(t, e, n, r, i, o, a) {
                L.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: r, phiLength: i, thetaStart: o, thetaLength: a }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
                for (var s = Math.min(o + a, Math.PI), c = 0, l = [], u = new kn, h = new kn, p = [], d = [], f = [], m = [], g = 0; g <= n; g++) {
                    var v = [],
                        y = g / n,
                        _ = 0;
                    0 == g && 0 == o ? _ = .5 / e : g == n && s == Math.PI && (_ = -.5 / e);
                    for (var x = 0; x <= e; x++) {
                        var b = x / e;
                        u.x = -t * Math.cos(r + b * i) * Math.sin(o + y * a), u.y = t * Math.cos(o + y * a), u.z = t * Math.sin(r + b * i) * Math.sin(o + y * a), d.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(b + _, 1 - y), v.push(c++)
                    }
                    l.push(v)
                }
                for (var w = 0; w < n; w++)
                    for (var M = 0; M < e; M++) {
                        var S = l[w][M + 1],
                            E = l[w][M],
                            T = l[w + 1][M],
                            A = l[w + 1][M + 1];
                        (0 !== w || 0 < o) && p.push(S, E, A), (w !== n - 1 || s < Math.PI) && p.push(E, T, A)
                    }
                this.setIndex(p), this.setAttribute("position", new Si(d, 3)), this.setAttribute("normal", new Si(f, 3)), this.setAttribute("uv", new Si(m, 2))
            }
            return L && (t.__proto__ = L), (t.prototype = Object.create(L && L.prototype)).constructor = t
        }(Ni),
        Dl = function(a) {
            function t(t, e, n, r, i, o) { a.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: o }, this.fromBufferGeometry(new Nl(t, e, n, r, i, o)), this.mergeVertices() }
            return a && (t.__proto__ = a), (t.prototype = Object.create(a && a.prototype)).constructor = t
        }(ao),
        Nl = function(S) {
            function t(t, e, n, r, i, o) {
                S.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: o }, t = t || .5, e = e || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
                for (var a = [], s = [], c = [], l = [], u = t, h = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1), p = new kn, d = new Ln, f = 0; f <= r; f++) {
                    for (var m = 0; m <= n; m++) {
                        var g = i + m / n * o;
                        p.x = u * Math.cos(g), p.y = u * Math.sin(g), s.push(p.x, p.y, p.z), c.push(0, 0, 1), d.x = (p.x / e + 1) / 2, d.y = (p.y / e + 1) / 2, l.push(d.x, d.y)
                    }
                    u += h
                }
                for (var v = 0; v < r; v++)
                    for (var y = v * (n + 1), _ = 0; _ < n; _++) {
                        var x = _ + y,
                            b = x + n + 1,
                            w = x + n + 2,
                            M = x + 1;
                        a.push(x, b, M), a.push(b, w, M)
                    }
                this.setIndex(a), this.setAttribute("position", new Si(s, 3)), this.setAttribute("normal", new Si(c, 3)), this.setAttribute("uv", new Si(l, 2))
            }
            return S && (t.__proto__ = S), (t.prototype = Object.create(S && S.prototype)).constructor = t
        }(Ni),
        Bl = function(i) {
            function t(t, e, n, r) { i.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: r }, this.fromBufferGeometry(new Fl(t, e, n, r)), this.mergeVertices() }
            return i && (t.__proto__ = i), (t.prototype = Object.create(i && i.prototype)).constructor = t
        }(ao),
        Fl = function(L) {
            function t(t, e, n, r) {
                L.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: r }, e = Math.floor(e) || 12, n = n || 0, r = r || 2 * Math.PI, r = An.clamp(r, 0, 2 * Math.PI);
                for (var i = [], o = [], a = [], s = 1 / e, c = new kn, l = new Ln, u = 0; u <= e; u++)
                    for (var h = n + u * s * r, p = Math.sin(h), d = Math.cos(h), f = 0; f <= t.length - 1; f++) c.x = t[f].x * p, c.y = t[f].y, c.z = t[f].x * d, o.push(c.x, c.y, c.z), l.x = u / e, l.y = f / (t.length - 1), a.push(l.x, l.y);
                for (var m = 0; m < e; m++)
                    for (var g = 0; g < t.length - 1; g++) {
                        var v = g + m * t.length,
                            y = v + t.length,
                            _ = v + t.length + 1,
                            x = v + 1;
                        i.push(v, y, x), i.push(y, _, x)
                    }
                if (this.setIndex(i), this.setAttribute("position", new Si(o, 3)), this.setAttribute("uv", new Si(a, 2)), this.computeVertexNormals(), r === 2 * Math.PI)
                    for (var b = this.attributes.normal.array, w = new kn, M = new kn, S = new kn, E = e * t.length * 3, T = 0, A = 0; T < t.length; T++, A += 3) w.x = b[A + 0], w.y = b[A + 1], w.z = b[A + 2], M.x = b[E + A + 0], M.y = b[E + A + 1], M.z = b[E + A + 2], S.addVectors(w, M).normalize(), b[A + 0] = b[E + A + 0] = S.x, b[A + 1] = b[E + A + 1] = S.y, b[A + 2] = b[E + A + 2] = S.z
            }
            return L && (t.__proto__ = L), (t.prototype = Object.create(L && L.prototype)).constructor = t
        }(Ni),
        Ul = function(n) {
            function t(t, e) { n.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new zl(t, e)), this.mergeVertices() }
            return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.toJSON = function() { var t = n.prototype.toJSON.call(this); return Hl(this.parameters.shapes, t) }, t
        }(ao),
        zl = function(i) {
            function t(t, _) {
                i.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: _ }, _ = _ || 12;
                var x = [],
                    b = [],
                    w = [],
                    M = [],
                    e = 0,
                    S = 0;
                if (!1 === Array.isArray(t)) r(t);
                else
                    for (var n = 0; n < t.length; n++) r(t[n]), this.addGroup(e, S, n), e += S, S = 0;

                function r(t) {
                    var e = b.length / 3,
                        t = t.extractPoints(_),
                        n = t.shape,
                        r = t.holes;
                    !1 === Ml.isClockWise(n) && (n = n.reverse());
                    for (var i = 0, o = r.length; i < o; i++) { var a = r[i];!0 === Ml.isClockWise(a) && (r[i] = a.reverse()) }
                    for (var s = Ml.triangulateShape(n, r), c = 0, l = r.length; c < l; c++) var u = r[c],
                        n = n.concat(u);
                    for (var h = 0, p = n.length; h < p; h++) {
                        var d = n[h];
                        b.push(d.x, d.y, 0), w.push(0, 0, 1), M.push(d.x, d.y)
                    }
                    for (var f = 0, m = s.length; f < m; f++) {
                        var g = s[f],
                            v = g[0] + e,
                            y = g[1] + e,
                            g = g[2] + e;
                        x.push(v, y, g), S += 3
                    }
                }
                this.setIndex(x), this.setAttribute("position", new Si(b, 3)), this.setAttribute("normal", new Si(w, 3)), this.setAttribute("uv", new Si(M, 2))
            }
            return i && (t.__proto__ = i), ((t.prototype = Object.create(i && i.prototype)).constructor = t).prototype.toJSON = function() { var t = i.prototype.toJSON.call(this); return Hl(this.parameters.shapes, t) }, t
        }(Ni);

    function Hl(t, e) {
        if (e.shapes = [], Array.isArray(t))
            for (var n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.shapes.push(i.uuid)
            } else e.shapes.push(t.uuid);
        return e
    }
    var kl = function(_) {
            function t(t, e) {
                _.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e }, e = void 0 !== e ? e : 1;
                var n, r, i, o, a = [],
                    s = Math.cos(An.DEG2RAD * e),
                    c = [0, 0],
                    l = {},
                    u = ["a", "b", "c"];
                t.isBufferGeometry ? (o = new ao).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var h = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
                    for (var m = p[d], g = 0; g < 3; g++) n = m[u[g]], r = m[u[(g + 1) % 3]], c[0] = Math.min(n, r), c[1] = Math.max(n, r), void 0 === l[i = c[0] + "," + c[1]] ? l[i] = { index1: c[0], index2: c[1], face1: d, face2: void 0 } : l[i].face2 = d;
                for (i in l) {
                    var v, y = l[i];
                    (void 0 === y.face2 || p[y.face1].normal.dot(p[y.face2].normal) <= s) && (v = h[y.index1], a.push(v.x, v.y, v.z), v = h[y.index2], a.push(v.x, v.y, v.z))
                }
                this.setAttribute("position", new Si(a, 3))
            }
            return _ && (t.__proto__ = _), (t.prototype = Object.create(_ && _.prototype)).constructor = t
        }(Ni),
        Gl = function(c) {
            function t(t, e, n, r, i, o, a, s) { c.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: r, heightSegments: i, openEnded: o, thetaStart: a, thetaLength: s }, this.fromBufferGeometry(new Vl(t, e, n, r, i, o, a, s)), this.mergeVertices() }
            return c && (t.__proto__ = c), (t.prototype = Object.create(c && c.prototype)).constructor = t
        }(ao),
        Vl = function(n) {
            function t(y, _, x, b, w, t, M, S) {
                n.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: y, radiusBottom: _, height: x, radialSegments: b, heightSegments: w, openEnded: t, thetaStart: M, thetaLength: S };
                var E = this;
                y = void 0 !== y ? y : 1, _ = void 0 !== _ ? _ : 1, x = x || 1, b = Math.floor(b) || 8, w = Math.floor(w) || 1, t = void 0 !== t && t, M = void 0 !== M ? M : 0, S = void 0 !== S ? S : 2 * Math.PI;
                var T = [],
                    A = [],
                    L = [],
                    R = [],
                    C = 0,
                    P = [],
                    O = x / 2,
                    I = 0;

                function e(t) {
                    for (var e = C, n = new Ln, r = new kn, i = 0, o = !0 === t ? y : _, a = !0 === t ? 1 : -1, s = 1; s <= b; s++) A.push(0, O * a, 0), L.push(0, a, 0), R.push(.5, .5), C++;
                    for (var c = C, l = 0; l <= b; l++) {
                        var u = l / b * S + M,
                            h = Math.cos(u),
                            u = Math.sin(u);
                        r.x = o * u, r.y = O * a, r.z = o * h, A.push(r.x, r.y, r.z), L.push(0, a, 0), n.x = .5 * h + .5, n.y = .5 * u * a + .5, R.push(n.x, n.y), C++
                    }
                    for (var p = 0; p < b; p++) {
                        var d = e + p,
                            f = c + p;
                        !0 === t ? T.push(f, f + 1, d) : T.push(f + 1, f, d), i += 3
                    }
                    E.addGroup(I, i, !0 === t ? 1 : 2), I += i
                }! function() {
                    for (var t = new kn, e = new kn, n = 0, r = (_ - y) / x, i = 0; i <= w; i++) {
                        for (var o = [], a = i / w, s = a * (_ - y) + y, c = 0; c <= b; c++) {
                            var l = c / b,
                                u = l * S + M,
                                h = Math.sin(u),
                                u = Math.cos(u);
                            e.x = s * h, e.y = -a * x + O, e.z = s * u, A.push(e.x, e.y, e.z), t.set(h, r, u).normalize(), L.push(t.x, t.y, t.z), R.push(l, 1 - a), o.push(C++)
                        }
                        P.push(o)
                    }
                    for (var p = 0; p < b; p++)
                        for (var d = 0; d < w; d++) {
                            var f = P[d][p],
                                m = P[d + 1][p],
                                g = P[d + 1][p + 1],
                                v = P[d][p + 1];
                            T.push(f, m, v), T.push(m, g, v), n += 6
                        }
                    E.addGroup(I, n, 0), I += n
                }(), !1 === t && (0 < y && e(!0), 0 < _ && e(!1)), this.setIndex(T), this.setAttribute("position", new Si(A, 3)), this.setAttribute("normal", new Si(L, 3)), this.setAttribute("uv", new Si(R, 2))
            }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(Ni),
        jl = function(s) {
            function t(t, e, n, r, i, o, a) { s.call(this, 0, t, e, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: o, thetaLength: a } }
            return s && (t.__proto__ = s), (t.prototype = Object.create(s && s.prototype)).constructor = t
        }(Gl),
        Wl = function(s) {
            function t(t, e, n, r, i, o, a) { s.call(this, 0, t, e, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: o, thetaLength: a } }
            return s && (t.__proto__ = s), (t.prototype = Object.create(s && s.prototype)).constructor = t
        }(Vl),
        ql = function(i) {
            function t(t, e, n, r) { i.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: r }, this.fromBufferGeometry(new Xl(t, e, n, r)), this.mergeVertices() }
            return i && (t.__proto__ = i), (t.prototype = Object.create(i && i.prototype)).constructor = t
        }(ao),
        Xl = function(f) {
            function t(t, e, n, r) {
                f.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: r }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var i = [],
                    o = [],
                    a = [],
                    s = [],
                    c = new kn,
                    l = new Ln;
                o.push(0, 0, 0), a.push(0, 0, 1), s.push(.5, .5);
                for (var u = 0, h = 3; u <= e; u++, h += 3) {
                    var p = n + u / e * r;
                    c.x = t * Math.cos(p), c.y = t * Math.sin(p), o.push(c.x, c.y, c.z), a.push(0, 0, 1), l.x = (o[h] / t + 1) / 2, l.y = (o[h + 1] / t + 1) / 2, s.push(l.x, l.y)
                }
                for (var d = 1; d <= e; d++) i.push(d, d + 1, 0);
                this.setIndex(i), this.setAttribute("position", new Si(o, 3)), this.setAttribute("normal", new Si(a, 3)), this.setAttribute("uv", new Si(s, 2))
            }
            return f && (t.__proto__ = f), (t.prototype = Object.create(f && f.prototype)).constructor = t
        }(Ni),
        Yl = Object.freeze({ __proto__: null, WireframeGeometry: kc, ParametricGeometry: Gc, ParametricBufferGeometry: Vc, TetrahedronGeometry: qc, TetrahedronBufferGeometry: Xc, OctahedronGeometry: Yc, OctahedronBufferGeometry: Zc, IcosahedronGeometry: Jc, IcosahedronBufferGeometry: Kc, DodecahedronGeometry: Qc, DodecahedronBufferGeometry: $c, PolyhedronGeometry: jc, PolyhedronBufferGeometry: Wc, TubeGeometry: tl, TubeBufferGeometry: el, TorusKnotGeometry: nl, TorusKnotBufferGeometry: rl, TorusGeometry: il, TorusBufferGeometry: ol, TextGeometry: Cl, TextBufferGeometry: Pl, SphereGeometry: Ol, SphereBufferGeometry: Il, RingGeometry: Dl, RingBufferGeometry: Nl, PlaneGeometry: To, PlaneBufferGeometry: Ao, LatheGeometry: Bl, LatheBufferGeometry: Fl, ShapeGeometry: Ul, ShapeBufferGeometry: zl, ExtrudeGeometry: Tl, ExtrudeBufferGeometry: Al, EdgesGeometry: kl, ConeGeometry: jl, ConeBufferGeometry: Wl, CylinderGeometry: Gl, CylinderBufferGeometry: Vl, CircleGeometry: ql, CircleBufferGeometry: Xl, BoxGeometry: so, BoxBufferGeometry: co });

    function Zl(t) { pi.call(this), this.type = "ShadowMaterial", this.color = new li(0), this.transparent = !0, this.setValues(t) }

    function Jl(t) { mo.call(this, t), this.type = "RawShaderMaterial" }

    function Kl(t) { pi.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new li(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new li(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = gn, this.normalScale = new Ln(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t) }

    function Ql(t) { Kl.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ln(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t) }

    function $l(t) { pi.call(this), this.type = "MeshPhongMaterial", this.color = new li(16777215), this.specular = new li(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new li(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = gn, this.normalScale = new Ln(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = N, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }

    function tu(t) { pi.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new li(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new li(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = gn, this.normalScale = new Ln(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }

    function eu(t) { pi.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = gn, this.normalScale = new Ln(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }

    function nu(t) { pi.call(this), this.type = "MeshLambertMaterial", this.color = new li(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new li(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = N, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }

    function ru(t) { pi.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new li(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = gn, this.normalScale = new Ln(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }

    function iu(t) { _c.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) }((Zl.prototype = Object.create(pi.prototype)).constructor = Zl).prototype.isShadowMaterial = !0, Zl.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this }, ((Jl.prototype = Object.create(mo.prototype)).constructor = Jl).prototype.isRawShaderMaterial = !0, ((Kl.prototype = Object.create(pi.prototype)).constructor = Kl).prototype.isMeshStandardMaterial = !0, Kl.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this }, ((Ql.prototype = Object.create(Kl.prototype)).constructor = Ql).prototype.isMeshPhysicalMaterial = !0, Ql.prototype.copy = function(t) { return Kl.prototype.copy.call(this, t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new li).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this }, (($l.prototype = Object.create(pi.prototype)).constructor = $l).prototype.isMeshPhongMaterial = !0, $l.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((tu.prototype = Object.create(pi.prototype)).constructor = tu).prototype.isMeshToonMaterial = !0, tu.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((eu.prototype = Object.create(pi.prototype)).constructor = eu).prototype.isMeshNormalMaterial = !0, eu.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((nu.prototype = Object.create(pi.prototype)).constructor = nu).prototype.isMeshLambertMaterial = !0, nu.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((ru.prototype = Object.create(pi.prototype)).constructor = ru).prototype.isMeshMatcapMaterial = !0, ru.prototype.copy = function(t) { return pi.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((iu.prototype = Object.create(_c.prototype)).constructor = iu).prototype.isLineDashedMaterial = !0, iu.prototype.copy = function(t) { return _c.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this };
    var ou = Object.freeze({ __proto__: null, ShadowMaterial: Zl, SpriteMaterial: Hs, RawShaderMaterial: Jl, ShaderMaterial: mo, PointsMaterial: Cc, MeshPhysicalMaterial: Ql, MeshStandardMaterial: Kl, MeshPhongMaterial: $l, MeshToonMaterial: tu, MeshNormalMaterial: eu, MeshLambertMaterial: nu, MeshDepthMaterial: ys, MeshDistanceMaterial: _s, MeshBasicMaterial: di, MeshMatcapMaterial: ru, LineDashedMaterial: iu, LineBasicMaterial: _c, Material: pi }),
        au = {
            arraySlice: function(t, e, n) { return au.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) },
            convertArray: function(t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) },
            isTypedArray: function(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) },
            getKeyframeOrder: function(n) { for (var t = n.length, e = new Array(t), r = 0; r !== t; ++r) e[r] = r; return e.sort(function(t, e) { return n[t] - n[e] }), e },
            sortedArray: function(t, e, n) {
                for (var r = t.length, i = new t.constructor(r), o = 0, a = 0; a !== r; ++o)
                    for (var s = n[o] * e, c = 0; c !== e; ++c) i[a++] = t[s + c];
                return i
            },
            flattenJSON: function(t, e, n, r) {
                for (var i = 1, o = t[0]; void 0 !== o && void 0 === o[r];) o = t[i++];
                if (void 0 !== o) {
                    var a = o[r];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            for (; void 0 !== (a = o[r]) && (e.push(o.time), n.push.apply(n, a)), o = t[i++], void 0 !== o;);
                        else if (void 0 !== a.toArray)
                        for (; void 0 !== (a = o[r]) && (e.push(o.time), a.toArray(n, n.length)), o = t[i++], void 0 !== o;);
                    else
                        for (; void 0 !== (a = o[r]) && (e.push(o.time), n.push(a)), o = t[i++], void 0 !== o;);
                }
            },
            subclip: function(t, e, n, r, i) {
                i = i || 30;
                var o = t.clone();
                o.name = e;
                for (var a = [], s = 0; s < o.tracks.length; ++s) {
                    for (var c = o.tracks[s], l = c.getValueSize(), u = [], h = [], p = 0; p < c.times.length; ++p) { var d = c.times[p] * i; if (!(d < n || r <= d)) { u.push(c.times[p]); for (var f = 0; f < l; ++f) h.push(c.values[p * l + f]) } }
                    0 !== u.length && (c.times = au.convertArray(u, c.times.constructor), c.values = au.convertArray(h, c.values.constructor), a.push(c))
                }
                o.tracks = a;
                for (var m = 1 / 0, g = 0; g < o.tracks.length; ++g) m > o.tracks[g].times[0] && (m = o.tracks[g].times[0]);
                for (var v = 0; v < o.tracks.length; ++v) o.tracks[v].shift(-1 * m);
                return o.resetDuration(), o
            },
            makeClipAdditive: function(g, t, v, e) {
                void 0 === t && (t = 0), void 0 === v && (v = g), (void 0 === e || e <= 0) && (e = 30);
                for (var n = g.tracks.length, y = t / e, r = 0; r < n; ++r) ! function(t) {
                    var e = v.tracks[t],
                        n = e.ValueTypeName;
                    if ("bool" !== n && "string" !== n) {
                        var r = g.tracks.find(function(t) { return t.name === e.name && t.ValueTypeName === n });
                        if (void 0 !== r) {
                            var i = 0,
                                o = e.getValueSize();
                            e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (i = o / 3);
                            var a = 0,
                                s = r.getValueSize();
                            r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = s / 3);
                            var c, l = e.times.length - 1,
                                u = void 0;
                            u = y <= e.times[0] ? (t = o - i, au.arraySlice(e.values, i, t)) : y >= e.times[l] ? (c = (l = l * o + i) + o - i, au.arraySlice(e.values, l, c)) : (o = o - (c = i), (i = e.createInterpolant()).evaluate(y), au.arraySlice(i.resultBuffer, c, o)), "quaternion" === n && (new zn).fromArray(u).normalize().conjugate().toArray(u);
                            for (var h = r.times.length, p = 0; p < h; ++p) {
                                var d = p * s + a;
                                if ("quaternion" === n) zn.multiplyQuaternionsFlat(r.values, d, u, 0, r.values, d);
                                else
                                    for (var f = s - 2 * a, m = 0; m < f; ++m) r.values[d + m] -= u[m]
                            }
                        }
                    }
                }(r);
                return g.blendMode = 2501, g
            }
        };

    function su(t, e, n, r) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n }

    function cu(t, e, n, r) { su.call(this, t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 }

    function lu(t, e, n, r) { su.call(this, t, e, n, r) }

    function uu(t, e, n, r) { su.call(this, t, e, n, r) }

    function hu(t, e, n, r) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = au.convertArray(e, this.TimeBufferType), this.values = au.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }

    function pu(t, e, n) { hu.call(this, t, e, n) }

    function du(t, e, n, r) { hu.call(this, t, e, n, r) }

    function fu(t, e, n, r) { hu.call(this, t, e, n, r) }

    function mu(t, e, n, r) { su.call(this, t, e, n, r) }

    function gu(t, e, n, r) { hu.call(this, t, e, n, r) }

    function vu(t, e, n, r) { hu.call(this, t, e, n, r) }

    function yu(t, e, n, r) { hu.call(this, t, e, n, r) }

    function _u(t, e, n, r) { this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== r ? r : 2500, this.uuid = An.generateUUID(), this.duration < 0 && this.resetDuration() }

    function xu(t) {
        if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var e, n, r = function(t) {
            switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return fu;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return yu;
                case "color":
                    return du;
                case "quaternion":
                    return gu;
                case "bool":
                case "boolean":
                    return pu;
                case "string":
                    return vu
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        return void 0 === t.times && (e = [], n = [], au.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n), void 0 !== r.parse ? r.parse(t) : new r(t.name, t.times, t.values, t.interpolation)
    }
    Object.assign(su.prototype, {
        evaluate: function(t) {
            var e, n = this.parameterPositions,
                r = this._cachedIndex,
                i = n[r],
                o = n[r - 1];
            t: {
                e: {
                    n: {
                        r: if (!(t < i)) {
                            for (var a = r + 2;;) { if (void 0 === i) { if (t < o) break r; return r = n.length, this._cachedIndex = r, this.afterEnd_(r - 1, t, o) } if (r === a) break; if (o = i, t < (i = n[++r])) break e }
                            e = n.length;
                            break n
                        }if (o <= t) break t;
                        var s = n[1];t < s && (r = 2, o = s);
                        for (var c = r - 2;;) { if (void 0 === o) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (r === c) break; if (i = o, (o = n[--r - 1]) <= t) break e }
                        e = r,
                        r = 0
                    }
                    for (; r < e;) {
                        var l = r + e >>> 1;
                        t < n[l] ? e = l : r = 1 + l
                    }
                    if (i = n[r], void 0 === (o = n[r - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                    if (void 0 === i) return r = n.length, this._cachedIndex = r, this.afterEnd_(r - 1, o, t)
                }
                this._cachedIndex = r,
                this.intervalChanged_(r, o, i)
            }
            return this.interpolate_(r, o, t, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() { return this.settings || this.DefaultSettings_ },
        copySampleValue_: function(t) { for (var e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r, o = 0; o !== r; ++o) e[o] = n[i + o]; return e },
        interpolate_: function() { throw new Error("call to abstract method") },
        intervalChanged_: function() {}
    }), Object.assign(su.prototype, { beforeStart_: su.prototype.copySampleValue_, afterEnd_: su.prototype.copySampleValue_ }), cu.prototype = Object.assign(Object.create(su.prototype), {
        constructor: cu,
        DefaultSettings_: { endingStart: en, endingEnd: en },
        intervalChanged_: function(t, e, n) {
            var r = this.parameterPositions,
                i = t - 2,
                o = t + 1,
                a = r[i],
                s = r[o];
            if (void 0 === a) switch (this.getSettings_().endingStart) {
                case nn:
                    i = t, a = 2 * e - n;
                    break;
                case rn:
                    a = e + r[i = r.length - 2] - r[i + 1];
                    break;
                default:
                    i = t, a = n
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case nn:
                    o = t, s = 2 * n - e;
                    break;
                case rn:
                    s = n + r[o = 1] - r[0];
                    break;
                default:
                    o = t - 1, s = e
            }
            var c = .5 * (n - e),
                l = this.valueSize;
            this._weightPrev = c / (e - a), this._weightNext = c / (s - n), this._offsetPrev = i * l, this._offsetNext = o * l
        },
        interpolate_: function(t, e, n, r) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, t = this._weightNext, n = (n - e) / (r - e), r = n * n, e = r * n, p = -h * e + 2 * h * r - h * n, d = (1 + h) * e + (-1.5 - 2 * h) * r + (-.5 + h) * n + 1, f = (-1 - t) * e + (1.5 + t) * r + .5 * n, m = t * e - t * r, g = 0; g !== a; ++g) i[g] = p * o[l + g] + d * o[c + g] + f * o[s + g] + m * o[u + g]; return i }
    }), lu.prototype = Object.assign(Object.create(su.prototype), { constructor: lu, interpolate_: function(t, e, n, r) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = (n - e) / (r - e), u = 1 - l, h = 0; h !== a; ++h) i[h] = o[c + h] * u + o[s + h] * l; return i } }), uu.prototype = Object.assign(Object.create(su.prototype), { constructor: uu, interpolate_: function(t) { return this.copySampleValue_(t - 1) } }), Object.assign(hu, { toJSON: function(t) { var e, n = t.constructor; return void 0 !== n.toJSON ? e = n.toJSON(t) : (e = { name: t.name, times: au.convertArray(t.times, Array), values: au.convertArray(t.values, Array) }, (n = t.getInterpolation()) !== t.DefaultInterpolation && (e.interpolation = n)), e.type = t.ValueTypeName, e } }), Object.assign(hu.prototype, {
        constructor: hu,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: tn,
        InterpolantFactoryMethodDiscrete: function(t) { return new uu(this.times, this.values, this.getValueSize(), t) },
        InterpolantFactoryMethodLinear: function(t) { return new lu(this.times, this.values, this.getValueSize(), t) },
        InterpolantFactoryMethodSmooth: function(t) { return new cu(this.times, this.values, this.getValueSize(), t) },
        setInterpolation: function(t) {
            var e;
            switch (t) {
                case $e:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case tn:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 !== e) return this.createInterpolant = e, this;
            var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(n);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn("THREE.KeyframeTrack:", n), this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return $e;
                case this.InterpolantFactoryMethodLinear:
                    return tn;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function() { return this.values.length / this.times.length },
        shift: function(t) {
            if (0 !== t)
                for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] *= t;
            return this
        },
        trim: function(t, e) { for (var n, r = this.times, i = r.length, o = 0, a = i - 1; o !== i && r[o] < t;) ++o; for (; - 1 !== a && r[a] > e;) --a; return ++a, 0 === o && a === i || (a <= o && (o = (a = Math.max(a, 1)) - 1), n = this.getValueSize(), this.times = au.arraySlice(r, o, a), this.values = au.arraySlice(this.values, o * n, a * n)), this },
        validate: function() {
            var t = !0,
                e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
            var n = this.times,
                r = this.values,
                i = n.length;
            0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
            for (var o = null, a = 0; a !== i; a++) {
                var s = n[a];
                if ("number" == typeof s && isNaN(s)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1; break }
                if (null !== o && s < o) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1; break }
                o = s
            }
            if (void 0 !== r && au.isTypedArray(r))
                for (var c = 0, l = r.length; c !== l; ++c) { var u = r[c]; if (isNaN(u)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, c, u), t = !1; break } }
            return t
        },
        optimize: function() {
            for (var t = au.arraySlice(this.times), e = au.arraySlice(this.values), n = this.getValueSize(), r = 2302 === this.getInterpolation(), i = t.length - 1, o = 1, a = 1; a < i; ++a) {
                var s = !1,
                    c = t[a];
                if (c !== t[a + 1] && (1 !== a || c !== c[0]))
                    if (r) s = !0;
                    else
                        for (var l = a * n, u = l - n, h = l + n, p = 0; p !== n; ++p) { var d = e[l + p]; if (d !== e[u + p] || d !== e[h + p]) { s = !0; break } }
                if (s) { if (a !== o) { t[o] = t[a]; for (var f = a * n, m = o * n, g = 0; g !== n; ++g) e[m + g] = e[f + g] }++o }
            }
            if (0 < i) { t[o] = t[i]; for (var v = i * n, y = o * n, _ = 0; _ !== n; ++_) e[y + _] = e[v + _];++o }
            return o !== t.length ? (this.times = au.arraySlice(t, 0, o), this.values = au.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this
        },
        clone: function() {
            var t = au.arraySlice(this.times, 0),
                e = au.arraySlice(this.values, 0),
                e = new this.constructor(this.name, t, e);
            return e.createInterpolant = this.createInterpolant, e
        }
    }), pu.prototype = Object.assign(Object.create(hu.prototype), { constructor: pu, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: $e, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), du.prototype = Object.assign(Object.create(hu.prototype), { constructor: du, ValueTypeName: "color" }), fu.prototype = Object.assign(Object.create(hu.prototype), { constructor: fu, ValueTypeName: "number" }), mu.prototype = Object.assign(Object.create(su.prototype), { constructor: mu, interpolate_: function(t, e, n, r) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = (n - e) / (r - e), c = t * a, l = c + a; c !== l; c += 4) zn.slerpFlat(i, 0, o, c - a, o, c, s); return i } }), gu.prototype = Object.assign(Object.create(hu.prototype), { constructor: gu, ValueTypeName: "quaternion", DefaultInterpolation: tn, InterpolantFactoryMethodLinear: function(t) { return new mu(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), vu.prototype = Object.assign(Object.create(hu.prototype), { constructor: vu, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: $e, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), yu.prototype = Object.assign(Object.create(hu.prototype), { constructor: yu, ValueTypeName: "vector" }), Object.assign(_u, {
        parse: function(t) { for (var e = [], n = t.tracks, r = 1 / (t.fps || 1), i = 0, o = n.length; i !== o; ++i) e.push(xu(n[i]).scale(r)); return new _u(t.name, t.duration, e, t.blendMode) },
        toJSON: function(t) { for (var e = [], n = t.tracks, t = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }, r = 0, i = n.length; r !== i; ++r) e.push(hu.toJSON(n[r])); return t },
        CreateFromMorphTargetSequence: function(t, e, n, r) {
            for (var i = e.length, o = [], a = 0; a < i; a++) {
                var s = [];
                (l = []).push((a + i - 1) % i, a, (a + 1) % i), s.push(0, 1, 0);
                var c = au.getKeyframeOrder(l),
                    l = au.sortedArray(l, 1, c),
                    s = au.sortedArray(s, 1, c);
                r || 0 !== l[0] || (l.push(i), s.push(s[0])), o.push(new fu(".morphTargetInfluences[" + e[a].name + "]", l, s).scale(1 / n))
            }
            return new _u(t, -1, o)
        },
        findByName: function(t, e) {
            var n = t;
            Array.isArray(t) || (n = t.geometry && t.geometry.animations || t.animations);
            for (var r = 0; r < n.length; r++)
                if (n[r].name === e) return n[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, n) {
            for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                var s, c = t[o],
                    l = c.name.match(i);
                l && 1 < l.length && ((l = r[s = l[1]]) || (r[s] = l = []), l.push(c))
            }
            var u, h = [];
            for (u in r) h.push(_u.CreateFromMorphTargetSequence(u, r[u], e, n));
            return h
        },
        parseAnimation: function(t, e) {
            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            for (var n = function(t, e, n, r, i) {
                    var o, a;
                    0 !== n.length && (o = [], a = [], au.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new t(e, o, a)))
                }, r = [], i = t.name || "default", o = t.fps || 30, a = t.blendMode, s = t.length || -1, c = t.hierarchy || [], l = 0; l < c.length; l++) {
                var u = c[l].keys;
                if (u && 0 !== u.length)
                    if (u[0].morphTargets) {
                        for (var h, p = {}, d = void 0, d = 0; d < u.length; d++)
                            if (u[d].morphTargets)
                                for (var f = 0; f < u[d].morphTargets.length; f++) p[u[d].morphTargets[f]] = -1;
                        for (h in p) {
                            for (var m = [], g = [], v = 0; v !== u[d].morphTargets.length; ++v) {
                                var y = u[d];
                                m.push(y.time), g.push(y.morphTarget === h ? 1 : 0)
                            }
                            r.push(new fu(".morphTargetInfluence[" + h + "]", m, g))
                        }
                        s = p.length * (o || 1)
                    } else {
                        var _ = ".bones[" + e[l].name + "]";
                        n(yu, _ + ".position", u, "pos", r), n(gu, _ + ".quaternion", u, "rot", r), n(yu, _ + ".scale", u, "scl", r)
                    }
            }
            return 0 === r.length ? null : new _u(i, s, r, a)
        }
    }), Object.assign(_u.prototype, {
        resetDuration: function() {
            for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) var r = this.tracks[e],
                t = Math.max(t, r.times[r.times.length - 1]);
            return this.duration = t, this
        },
        trim: function() { for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration); return this },
        validate: function() { for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate(); return t },
        optimize: function() { for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize(); return this },
        clone: function() { for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone()); return new _u(this.name, this.duration, t, this.blendMode) }
    });
    var bu = { enabled: !1, files: {}, add: function(t, e) {!1 !== this.enabled && (this.files[t] = e) }, get: function(t) { if (!1 !== this.enabled) return this.files[t] }, remove: function(t) { delete this.files[t] }, clear: function() { this.files = {} } };

    function wu(t, e, n) {
        var r = this,
            i = !1,
            o = 0,
            a = 0,
            s = void 0,
            c = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) { a++, !1 === i && void 0 !== r.onStart && r.onStart(t, o, a), i = !0 }, this.itemEnd = function(t) { o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function(t) { void 0 !== r.onError && r.onError(t) }, this.resolveURL = function(t) { return s ? s(t) : t }, this.setURLModifier = function(t) { return s = t, this }, this.addHandler = function(t, e) { return c.push(t, e), this }, this.removeHandler = function(t) { t = c.indexOf(t); return -1 !== t && c.splice(t, 2), this }, this.getHandler = function(t) {
            for (var e = 0, n = c.length; e < n; e += 2) {
                var r = c[e],
                    i = c[e + 1];
                if (r.global && (r.lastIndex = 0), r.test(t)) return i
            }
            return null
        }
    }
    var Mu = new wu;

    function Su(t) { this.manager = void 0 !== t ? t : Mu, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {} }
    Object.assign(Su.prototype, { load: function() {}, loadAsync: function(n, r) { var i = this; return new Promise(function(t, e) { i.load(n, t, r, e) }) }, parse: function() {}, setCrossOrigin: function(t) { return this.crossOrigin = t, this }, setPath: function(t) { return this.path = t, this }, setResourcePath: function(t) { return this.resourcePath = t, this }, setRequestHeader: function(t) { return this.requestHeader = t, this } });
    var Eu = {};

    function Tu(t) { Su.call(this, t) }

    function Au(t) { Su.call(this, t) }

    function Lu(t) { Su.call(this, t) }

    function Ru(t) { Su.call(this, t) }

    function Cu(t) { Su.call(this, t) }

    function Pu(t) { Su.call(this, t) }

    function Ou(t) { Su.call(this, t) }

    function Iu() { this.type = "Curve", this.arcLengthDivisions = 200 }

    function Du(t, e, n, r, i, o, a, s) { Iu.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0 }

    function Nu(t, e, n, r, i, o) { Du.call(this, t, e, n, n, r, i, o), this.type = "ArcCurve" }

    function Bu() {
        var i = 0,
            o = 0,
            a = 0,
            s = 0;

        function c(t, e, n, r) { a = -3 * (i = t) + 3 * e - 2 * (o = n) - r, s = 2 * t - 2 * e + n + r }
        return {
            initCatmullRom: function(t, e, n, r, i) { c(e, n, i * (n - t), i * (r - e)) },
            initNonuniformCatmullRom: function(t, e, n, r, i, o, a) {
                i = (e - t) / i - (n - t) / (i + o) + (n - e) / o, a = (n - e) / o - (r - e) / (o + a) + (r - n) / a;
                c(e, n, i *= o, a *= o)
            },
            calc: function(t) { var e = t * t; return i + o * t + a * e + s * (e * t) }
        }
    }
    Tu.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Tu,
        load: function(l, t, e, n) {
            void 0 === l && (l = ""), void 0 !== this.path && (l = this.path + l), l = this.manager.resolveURL(l);
            var u = this,
                r = bu.get(l);
            if (void 0 !== r) return u.manager.itemStart(l), setTimeout(function() { t && t(r), u.manager.itemEnd(l) }, 0), r;
            if (void 0 === Eu[l]) {
                var i, o = l.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (o) {
                    var a = o[1],
                        s = !!o[2],
                        c = o[3],
                        c = decodeURIComponent(c);
                    s && (c = atob(c));
                    try {
                        var h = (this.responseType || "").toLowerCase();
                        switch (h) {
                            case "arraybuffer":
                            case "blob":
                                for (var p = new Uint8Array(c.length), d = 0; d < c.length; d++) p[d] = c.charCodeAt(d);
                                f = "blob" === h ? new Blob([p.buffer], { type: a }) : p.buffer;
                                break;
                            case "document":
                                var f = (new DOMParser).parseFromString(c, a);
                                break;
                            case "json":
                                f = JSON.parse(c);
                                break;
                            default:
                                f = c
                        }
                        setTimeout(function() { t && t(f), u.manager.itemEnd(l) }, 0)
                    } catch (t) { setTimeout(function() { n && n(t), u.manager.itemError(l), u.manager.itemEnd(l) }, 0) }
                } else {
                    for (var m in Eu[l] = [], Eu[l].push({ onLoad: t, onProgress: e, onError: n }), (i = new XMLHttpRequest).open("GET", l, !0), i.addEventListener("load", function(t) {
                            var e = this.response,
                                n = Eu[l];
                            if (delete Eu[l], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), bu.add(l, e);
                                for (var r = 0, i = n.length; r < i; r++) {
                                    var o = n[r];
                                    o.onLoad && o.onLoad(e)
                                }
                                u.manager.itemEnd(l)
                            } else {
                                for (var a = 0, s = n.length; a < s; a++) {
                                    var c = n[a];
                                    c.onError && c.onError(t)
                                }
                                u.manager.itemError(l), u.manager.itemEnd(l)
                            }
                        }, !1), i.addEventListener("progress", function(t) {
                            for (var e = Eu[l], n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                i.onProgress && i.onProgress(t)
                            }
                        }, !1), i.addEventListener("error", function(t) {
                            var e = Eu[l];
                            delete Eu[l];
                            for (var n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                i.onError && i.onError(t)
                            }
                            u.manager.itemError(l), u.manager.itemEnd(l)
                        }, !1), i.addEventListener("abort", function(t) {
                            var e = Eu[l];
                            delete Eu[l];
                            for (var n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                i.onError && i.onError(t)
                            }
                            u.manager.itemError(l), u.manager.itemEnd(l)
                        }, !1), void 0 !== this.responseType && (i.responseType = this.responseType), void 0 !== this.withCredentials && (i.withCredentials = this.withCredentials), i.overrideMimeType && i.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) i.setRequestHeader(m, this.requestHeader[m]);
                    i.send(null)
                }
                return u.manager.itemStart(l), i
            }
            Eu[l].push({ onLoad: t, onProgress: e, onError: n })
        },
        setResponseType: function(t) { return this.responseType = t, this },
        setWithCredentials: function(t) { return this.withCredentials = t, this },
        setMimeType: function(t) { return this.mimeType = t, this }
    }), Au.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Au,
        load: function(e, n, t, r) {
            var i = this,
                o = new Tu(i.manager);
            o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.load(e, function(t) { try { n(i.parse(JSON.parse(t))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, t, r)
        },
        parse: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var r = _u.parse(t[n]);
                e.push(r)
            }
            return e
        }
    }), Lu.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Lu,
        load: function(t, o, n, r) {
            var a = this,
                s = [],
                c = new Uc;
            c.image = s;
            var i = new Tu(this.manager);
            i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader);
            var l = 0;
            if (Array.isArray(t))
                for (var e = 0, u = t.length; e < u; ++e) ! function(e) {
                    i.load(t[e], function(t) {
                        t = a.parse(t, !0);
                        s[e] = { width: t.width, height: t.height, format: t.format, mipmaps: t.mipmaps }, 6 === (l += 1) && (1 === t.mipmapCount && (c.minFilter = Ut), c.format = t.format, c.needsUpdate = !0, o && o(c))
                    }, n, r)
                }(e);
            else i.load(t, function(t) {
                var e = a.parse(t, !0);
                if (e.isCubemap)
                    for (var n = e.mipmaps.length / e.mipmapCount, r = 0; r < n; r++) { s[r] = { mipmaps: [] }; for (var i = 0; i < e.mipmapCount; i++) s[r].mipmaps.push(e.mipmaps[r * e.mipmapCount + i]), s[r].format = e.format, s[r].width = e.width, s[r].height = e.height } else c.image.width = e.width, c.image.height = e.height, c.mipmaps = e.mipmaps;
                1 === e.mipmapCount && (c.minFilter = Ut), c.format = e.format, c.needsUpdate = !0, o && o(c)
            }, n, r);
            return c
        }
    }), Ru.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Ru,
        load: function(e, t, n, r) {
            void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var i = this,
                o = bu.get(e);
            if (void 0 !== o) return i.manager.itemStart(e), setTimeout(function() { t && t(o), i.manager.itemEnd(e) }, 0), o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function s() { a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), bu.add(e, this), t && t(this), i.manager.itemEnd(e) }

            function c(t) { a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) }
            return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a
        }
    }), Cu.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Cu,
        load: function(t, n, e, r) {
            var i = new Wo,
                o = new Ru(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            var a = 0;
            for (var s = 0; s < t.length; ++s) ! function(e) { o.load(t[e], function(t) { i.images[e] = t, 6 === ++a && (i.needsUpdate = !0, n && n(i)) }, void 0, r) }(s);
            return i
        }
    }), Pu.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Pu,
        load: function(t, e, n, r) {
            var i = this,
                o = new xo,
                a = new Tu(this.manager);
            return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.load(t, function(t) {
                t = i.parse(t);
                t && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width, o.image.height = t.height, o.image.data = t.data), o.wrapS = void 0 !== t.wrapS ? t.wrapS : It, o.wrapT = void 0 !== t.wrapT ? t.wrapT : It, o.magFilter = void 0 !== t.magFilter ? t.magFilter : Ut, o.minFilter = void 0 !== t.minFilter ? t.minFilter : Ut, o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (o.format = t.format), void 0 !== t.type && (o.type = t.type), void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps, o.minFilter = Ht), 1 === t.mipmapCount && (o.minFilter = Ut), o.needsUpdate = !0, e && e(o, t))
            }, n, r), o
        }
    }), Ou.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Ou,
        load: function(e, n, t, r) {
            var i = new Dn,
                o = new Ru(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(t) {
                i.image = t;
                t = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data\:image\/jpeg/);
                i.format = t ? te : ee, i.needsUpdate = !0, void 0 !== n && n(i)
            }, t, r), i
        }
    }), Object.assign(Iu.prototype, {
        getPoint: function() { return console.warn("THREE.Curve: .getPoint() not implemented."), null },
        getPointAt: function(t, e) { t = this.getUtoTmapping(t); return this.getPoint(t, e) },
        getPoints: function(t) { void 0 === t && (t = 5); for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return e },
        getSpacedPoints: function(t) { void 0 === t && (t = 5); for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t)); return e },
        getLength: function() { var t = this.getLengths(); return t[t.length - 1] },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, n = [],
                r = this.getPoint(0),
                i = 0;
            n.push(0);
            for (var o = 1; o <= t; o++) i += (e = this.getPoint(o / t)).distanceTo(r), n.push(i), r = e;
            return this.cacheArcLengths = n
        },
        updateArcLengths: function() { this.needsUpdate = !0, this.getLengths() },
        getUtoTmapping: function(t, e) {
            for (var n, r = this.getLengths(), i = 0, o = r.length, a = e || t * r[o - 1], s = 0, c = o - 1; s <= c;)
                if ((n = r[i = Math.floor(s + (c - s) / 2)] - a) < 0) s = i + 1;
                else {
                    if (!(0 < n)) { c = i; break }
                    c = i - 1
                }
            if (r[i = c] === a) return i / (o - 1);
            t = r[i];
            return (i + (a - t) / (r[i + 1] - t)) / (o - 1)
        },
        getTangent: function(t, e) {
            var n = t - 1e-4,
                t = t + 1e-4;
            n < 0 && (n = 0), 1 < t && (t = 1);
            n = this.getPoint(n), t = this.getPoint(t), e = e || new(n.isVector2 ? Ln : kn);
            return e.copy(t).sub(n).normalize(), e
        },
        getTangentAt: function(t, e) { t = this.getUtoTmapping(t); return this.getTangent(t, e) },
        computeFrenetFrames: function(t, e) {
            for (var n = new kn, r = [], i = [], o = [], a = new kn, s = new mr, c = 0; c <= t; c++) {
                var l = c / t;
                r[c] = this.getTangentAt(l, new kn), r[c].normalize()
            }
            i[0] = new kn, o[0] = new kn;
            var u = Number.MAX_VALUE,
                h = Math.abs(r[0].x),
                p = Math.abs(r[0].y),
                d = Math.abs(r[0].z);
            h <= u && (u = h, n.set(1, 0, 0)), p <= u && (u = p, n.set(0, 1, 0)), d <= u && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], a), o[0].crossVectors(r[0], i[0]);
            for (var f, m = 1; m <= t; m++) i[m] = i[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(r[m - 1], r[m]), a.length() > Number.EPSILON && (a.normalize(), f = Math.acos(An.clamp(r[m - 1].dot(r[m]), -1, 1)), i[m].applyMatrix4(s.makeRotationAxis(a, f))), o[m].crossVectors(r[m], i[m]);
            if (!0 === e) {
                var g = Math.acos(An.clamp(i[0].dot(i[t]), -1, 1));
                g /= t, 0 < r[0].dot(a.crossVectors(i[0], i[t])) && (g = -g);
                for (var v = 1; v <= t; v++) i[v].applyMatrix4(s.makeRotationAxis(r[v], g * v)), o[v].crossVectors(r[v], i[v])
            }
            return { tangents: r, normals: i, binormals: o }
        },
        clone: function() { return (new this.constructor).copy(this) },
        copy: function(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this },
        toJSON: function() { var t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t },
        fromJSON: function(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }
    }), ((Du.prototype = Object.create(Iu.prototype)).constructor = Du).prototype.isEllipseCurve = !0, Du.prototype.getPoint = function(t, e) {
        for (var n = e || new Ln, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
        for (; r < i;) i -= r;
        i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
        var a = this.aStartAngle + t * i,
            s = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
        return 0 !== this.aRotation && (e = Math.cos(this.aRotation), o = Math.sin(this.aRotation), s = (t = s - this.aX) * e - (a = c - this.aY) * o + this.aX, c = t * o + a * e + this.aY), n.set(s, c)
    }, Du.prototype.copy = function(t) { return Iu.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Du.prototype.toJSON = function() { var t = Iu.prototype.toJSON.call(this); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }, Du.prototype.fromJSON = function(t) { return Iu.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, ((Nu.prototype = Object.create(Du.prototype)).constructor = Nu).prototype.isArcCurve = !0;
    var Fu = new kn,
        Uu = new Bu,
        zu = new Bu,
        Hu = new Bu;

    function ku(t, e, n, r) { Iu.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = void 0 !== r ? r : .5 }

    function Gu(t, e, n, r, i) {
        var o = .5 * (r - e),
            e = .5 * (i - n),
            i = t * t;
        return (2 * n - 2 * r + o + e) * (t * i) + (-3 * n + 3 * r - 2 * o - e) * i + o * t + n
    }

    function Vu(t, e, n, r) { return (i = 1 - (i = t)) * i * e + 2 * (1 - (e = t)) * e * n + (t = t) * t * r; var i }

    function ju(t, e, n, r, i) { return (o = 1 - (o = t)) * o * o * e + 3 * (e = 1 - (o = t)) * e * o * n + 3 * (1 - (n = t)) * n * n * r + (t = t) * t * t * i; var o }

    function Wu(t, e, n, r) { Iu.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Ln, this.v1 = e || new Ln, this.v2 = n || new Ln, this.v3 = r || new Ln }

    function qu(t, e, n, r) { Iu.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new kn, this.v1 = e || new kn, this.v2 = n || new kn, this.v3 = r || new kn }

    function Xu(t, e) { Iu.call(this), this.type = "LineCurve", this.v1 = t || new Ln, this.v2 = e || new Ln }

    function Yu(t, e) { Iu.call(this), this.type = "LineCurve3", this.v1 = t || new kn, this.v2 = e || new kn }

    function Zu(t, e, n) { Iu.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Ln, this.v1 = e || new Ln, this.v2 = n || new Ln }

    function Ju(t, e, n) { Iu.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new kn, this.v1 = e || new kn, this.v2 = n || new kn }

    function Ku(t) { Iu.call(this), this.type = "SplineCurve", this.points = t || [] }((ku.prototype = Object.create(Iu.prototype)).constructor = ku).prototype.isCatmullRomCurve3 = !0, ku.prototype.getPoint = function(t, e) {
        var n, r = e || new kn,
            i = this.points,
            o = i.length,
            a = (o - (this.closed ? 0 : 1)) * t,
            s = Math.floor(a),
            c = a - s;
        this.closed ? s += 0 < s ? 0 : (Math.floor(Math.abs(s) / o) + 1) * o : 0 === c && s === o - 1 && (s = o - 2, c = 1), n = this.closed || 0 < s ? i[(s - 1) % o] : (Fu.subVectors(i[0], i[1]).add(i[0]), Fu);
        e = i[s % o], t = i[(s + 1) % o], a = this.closed || s + 2 < o ? i[(s + 2) % o] : (Fu.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), Fu);
        return "centripetal" === this.curveType || "chordal" === this.curveType ? (s = "chordal" === this.curveType ? .5 : .25, i = Math.pow(n.distanceToSquared(e), s), (o = Math.pow(e.distanceToSquared(t), s)) < 1e-4 && (o = 1), i < 1e-4 && (i = o), (s = Math.pow(t.distanceToSquared(a), s)) < 1e-4 && (s = o), Uu.initNonuniformCatmullRom(n.x, e.x, t.x, a.x, i, o, s), zu.initNonuniformCatmullRom(n.y, e.y, t.y, a.y, i, o, s), Hu.initNonuniformCatmullRom(n.z, e.z, t.z, a.z, i, o, s)) : "catmullrom" === this.curveType && (Uu.initCatmullRom(n.x, e.x, t.x, a.x, this.tension), zu.initCatmullRom(n.y, e.y, t.y, a.y, this.tension), Hu.initCatmullRom(n.z, e.z, t.z, a.z, this.tension)), r.set(Uu.calc(c), zu.calc(c), Hu.calc(c)), r
    }, ku.prototype.copy = function(t) {
        Iu.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push(r.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, ku.prototype.toJSON = function() {
        var t = Iu.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var r = this.points[e];
            t.points.push(r.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }, ku.prototype.fromJSON = function(t) {
        Iu.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new kn).fromArray(r))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, ((Wu.prototype = Object.create(Iu.prototype)).constructor = Wu).prototype.isCubicBezierCurve = !0, Wu.prototype.getPoint = function(t, e) {
        var n = e || new Ln,
            r = this.v0,
            i = this.v1,
            o = this.v2,
            e = this.v3;
        return n.set(ju(t, r.x, i.x, o.x, e.x), ju(t, r.y, i.y, o.y, e.y)), n
    }, Wu.prototype.copy = function(t) { return Iu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Wu.prototype.toJSON = function() { var t = Iu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Wu.prototype.fromJSON = function(t) { return Iu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, ((qu.prototype = Object.create(Iu.prototype)).constructor = qu).prototype.isCubicBezierCurve3 = !0, qu.prototype.getPoint = function(t, e) {
        var n = e || new kn,
            r = this.v0,
            i = this.v1,
            o = this.v2,
            e = this.v3;
        return n.set(ju(t, r.x, i.x, o.x, e.x), ju(t, r.y, i.y, o.y, e.y), ju(t, r.z, i.z, o.z, e.z)), n
    }, qu.prototype.copy = function(t) { return Iu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, qu.prototype.toJSON = function() { var t = Iu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, qu.prototype.fromJSON = function(t) { return Iu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, ((Xu.prototype = Object.create(Iu.prototype)).constructor = Xu).prototype.isLineCurve = !0, Xu.prototype.getPoint = function(t, e) { e = e || new Ln; return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e }, Xu.prototype.getPointAt = function(t, e) { return this.getPoint(t, e) }, Xu.prototype.getTangent = function(t, e) { e = e || new Ln; return e.copy(this.v2).sub(this.v1).normalize(), e }, Xu.prototype.copy = function(t) { return Iu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Xu.prototype.toJSON = function() { var t = Iu.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Xu.prototype.fromJSON = function(t) { return Iu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((Yu.prototype = Object.create(Iu.prototype)).constructor = Yu).prototype.isLineCurve3 = !0, Yu.prototype.getPoint = function(t, e) { e = e || new kn; return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e }, Yu.prototype.getPointAt = function(t, e) { return this.getPoint(t, e) }, Yu.prototype.copy = function(t) { return Iu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Yu.prototype.toJSON = function() { var t = Iu.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Yu.prototype.fromJSON = function(t) { return Iu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((Zu.prototype = Object.create(Iu.prototype)).constructor = Zu).prototype.isQuadraticBezierCurve = !0, Zu.prototype.getPoint = function(t, e) {
        var n = e || new Ln,
            r = this.v0,
            i = this.v1,
            e = this.v2;
        return n.set(Vu(t, r.x, i.x, e.x), Vu(t, r.y, i.y, e.y)), n
    }, Zu.prototype.copy = function(t) { return Iu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Zu.prototype.toJSON = function() { var t = Iu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Zu.prototype.fromJSON = function(t) { return Iu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((Ju.prototype = Object.create(Iu.prototype)).constructor = Ju).prototype.isQuadraticBezierCurve3 = !0, Ju.prototype.getPoint = function(t, e) {
        var n = e || new kn,
            r = this.v0,
            i = this.v1,
            e = this.v2;
        return n.set(Vu(t, r.x, i.x, e.x), Vu(t, r.y, i.y, e.y), Vu(t, r.z, i.z, e.z)), n
    }, Ju.prototype.copy = function(t) { return Iu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Ju.prototype.toJSON = function() { var t = Iu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Ju.prototype.fromJSON = function(t) { return Iu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((Ku.prototype = Object.create(Iu.prototype)).constructor = Ku).prototype.isSplineCurve = !0, Ku.prototype.getPoint = function(t, e) {
        var n = e || new Ln,
            r = this.points,
            i = (r.length - 1) * t,
            o = Math.floor(i),
            a = i - o,
            e = r[0 === o ? o : o - 1],
            t = r[o],
            i = r[o > r.length - 2 ? r.length - 1 : o + 1],
            o = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return n.set(Gu(a, e.x, t.x, i.x, o.x), Gu(a, e.y, t.y, i.y, o.y)), n
    }, Ku.prototype.copy = function(t) {
        Iu.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push(r.clone())
        }
        return this
    }, Ku.prototype.toJSON = function() {
        var t = Iu.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var r = this.points[e];
            t.points.push(r.toArray())
        }
        return t
    }, Ku.prototype.fromJSON = function(t) {
        Iu.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new Ln).fromArray(r))
        }
        return this
    };
    var Qu = Object.freeze({ __proto__: null, ArcCurve: Nu, CatmullRomCurve3: ku, CubicBezierCurve: Wu, CubicBezierCurve3: qu, EllipseCurve: Du, LineCurve: Xu, LineCurve3: Yu, QuadraticBezierCurve: Zu, QuadraticBezierCurve3: Ju, SplineCurve: Ku });

    function $u() { Iu.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 }

    function th(t) { $u.call(this), this.type = "Path", this.currentPoint = new Ln, t && this.setFromPoints(t) }

    function eh(t) { th.call(this, t), this.uuid = An.generateUUID(), this.type = "Shape", this.holes = [] }

    function nh(t, e) { kr.call(this), this.type = "Light", this.color = new li(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 }

    function rh(t, e, n) { nh.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(kr.DefaultUp), this.updateMatrix(), this.groundColor = new li(e) }

    function ih(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Ln(512, 512), this.map = null, this.mapPass = null, this.matrix = new mr, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Mo, this._frameExtents = new Ln(1, 1), this._viewportCount = 1, this._viewports = [new Nn(0, 0, 1, 1)] }

    function oh() { ih.call(this, new vo(50, 1, .5, 500)) }

    function ah(t, e, n, r, i, o) { nh.call(this, t, e), this.type = "SpotLight", this.position.copy(kr.DefaultUp), this.updateMatrix(), this.target = new kr, Object.defineProperty(this, "power", { get: function() { return this.intensity * Math.PI }, set: function(t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new oh }

    function sh() { ih.call(this, new vo(90, 1, .5, 500)), this._frameExtents = new Ln(4, 2), this._viewportCount = 6, this._viewports = [new Nn(2, 1, 1, 1), new Nn(0, 1, 1, 1), new Nn(3, 1, 1, 1), new Nn(1, 1, 1, 1), new Nn(3, 0, 1, 1), new Nn(1, 0, 1, 1)], this._cubeDirections = [new kn(1, 0, 0), new kn(-1, 0, 0), new kn(0, 0, 1), new kn(0, 0, -1), new kn(0, 1, 0), new kn(0, -1, 0)], this._cubeUps = [new kn(0, 1, 0), new kn(0, 1, 0), new kn(0, 1, 0), new kn(0, 1, 0), new kn(0, 0, 1), new kn(0, 0, -1)] }

    function ch(t, e, n, r) { nh.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function() { return 4 * this.intensity * Math.PI }, set: function(t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new sh }

    function lh(t, e, n, r, i, o) { go.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix() }

    function uh() { ih.call(this, new lh(-5, 5, 5, -5, .5, 500)) }

    function hh(t, e) { nh.call(this, t, e), this.type = "DirectionalLight", this.position.copy(kr.DefaultUp), this.updateMatrix(), this.target = new kr, this.shadow = new uh }

    function ph(t, e) { nh.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0 }

    function dh(t, e, n, r) { nh.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10 }
    $u.prototype = Object.assign(Object.create(Iu.prototype), {
        constructor: $u,
        add: function(t) { this.curves.push(t) },
        closePath: function() {
            var t = this.curves[0].getPoint(0),
                e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Xu(e, t))
        },
        getPoint: function(t) {
            for (var e = t * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                if (n[r] >= e) {
                    var i = n[r] - e,
                        o = this.curves[r],
                        a = o.getLength(),
                        a = 0 === a ? 0 : 1 - i / a;
                    return o.getPointAt(a)
                }
                r++
            }
            return null
        },
        getLength: function() { var t = this.getCurveLengths(); return t[t.length - 1] },
        updateArcLengths: function() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() },
        getCurveLengths: function() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t },
        getSpacedPoints: function(t) { void 0 === t && (t = 40); for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e },
        getPoints: function(t) {
            t = t || 12;
            for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
                for (var o = i[r], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                    var l = s[c];
                    e && e.equals(l) || (n.push(l), e = l)
                }
            return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
        },
        copy: function(t) {
            Iu.prototype.copy.call(this, t), this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var r = t.curves[e];
                this.curves.push(r.clone())
            }
            return this.autoClose = t.autoClose, this
        },
        toJSON: function() {
            var t = Iu.prototype.toJSON.call(this);
            t.autoClose = this.autoClose, t.curves = [];
            for (var e = 0, n = this.curves.length; e < n; e++) {
                var r = this.curves[e];
                t.curves.push(r.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Iu.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var r = t.curves[e];
                this.curves.push((new Qu[r.type]).fromJSON(r))
            }
            return this
        }
    }), th.prototype = Object.assign(Object.create($u.prototype), {
        constructor: th,
        setFromPoints: function(t) { this.moveTo(t[0].x, t[0].y); for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y); return this },
        moveTo: function(t, e) { return this.currentPoint.set(t, e), this },
        lineTo: function(t, e) { var n = new Xu(this.currentPoint.clone(), new Ln(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this },
        quadraticCurveTo: function(t, e, n, r) { e = new Zu(this.currentPoint.clone(), new Ln(t, e), new Ln(n, r)); return this.curves.push(e), this.currentPoint.set(n, r), this },
        bezierCurveTo: function(t, e, n, r, i, o) { r = new Wu(this.currentPoint.clone(), new Ln(t, e), new Ln(n, r), new Ln(i, o)); return this.curves.push(r), this.currentPoint.set(i, o), this },
        splineThru: function(t) { var e = new Ku([this.currentPoint.clone()].concat(t)); return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this },
        arc: function(t, e, n, r, i, o) {
            var a = this.currentPoint.x,
                s = this.currentPoint.y;
            return this.absarc(t + a, e + s, n, r, i, o), this
        },
        absarc: function(t, e, n, r, i, o) { return this.absellipse(t, e, n, n, r, i, o), this },
        ellipse: function(t, e, n, r, i, o, a, s) {
            var c = this.currentPoint.x,
                l = this.currentPoint.y;
            return this.absellipse(t + c, e + l, n, r, i, o, a, s), this
        },
        absellipse: function(t, e, n, r, i, o, a, s) {
            a = new Du(t, e, n, r, i, o, a, s);
            0 < this.curves.length && ((s = a.getPoint(0)).equals(this.currentPoint) || this.lineTo(s.x, s.y)), this.curves.push(a);
            a = a.getPoint(1);
            return this.currentPoint.copy(a), this
        },
        copy: function(t) { return $u.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this },
        toJSON: function() { var t = $u.prototype.toJSON.call(this); return t.currentPoint = this.currentPoint.toArray(), t },
        fromJSON: function(t) { return $u.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this }
    }), eh.prototype = Object.assign(Object.create(th.prototype), {
        constructor: eh,
        getPointsHoles: function(t) { for (var e = [], n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t); return e },
        extractPoints: function(t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } },
        copy: function(t) {
            th.prototype.copy.call(this, t), this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var r = t.holes[e];
                this.holes.push(r.clone())
            }
            return this
        },
        toJSON: function() {
            var t = th.prototype.toJSON.call(this);
            t.uuid = this.uuid, t.holes = [];
            for (var e = 0, n = this.holes.length; e < n; e++) {
                var r = this.holes[e];
                t.holes.push(r.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            th.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var r = t.holes[e];
                this.holes.push((new th).fromJSON(r))
            }
            return this
        }
    }), nh.prototype = Object.assign(Object.create(kr.prototype), { constructor: nh, isLight: !0, copy: function(t) { return kr.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function(t) { t = kr.prototype.toJSON.call(this, t); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), rh.prototype = Object.assign(Object.create(nh.prototype), { constructor: rh, isHemisphereLight: !0, copy: function(t) { return nh.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(ih.prototype, {
        _projScreenMatrix: new mr,
        _lightPositionWorld: new kn,
        _lookTarget: new kn,
        getViewportCount: function() { return this._viewportCount },
        getFrustum: function() { return this._frustum },
        updateMatrices: function(t) {
            var e = this.camera,
                n = this.matrix,
                r = this._projScreenMatrix,
                i = this._lookTarget,
                o = this._lightPositionWorld;
            o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), i.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(i), e.updateMatrixWorld(), r.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
        },
        getViewport: function(t) { return this._viewports[t] },
        getFrameExtents: function() { return this._frameExtents },
        copy: function(t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this },
        clone: function() { return (new this.constructor).copy(this) },
        toJSON: function() { var t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t }
    }), oh.prototype = Object.assign(Object.create(ih.prototype), {
        constructor: oh,
        isSpotLightShadow: !0,
        updateMatrices: function(t) {
            var e = this.camera,
                n = 2 * An.RAD2DEG * t.angle,
                r = this.mapSize.width / this.mapSize.height,
                i = t.distance || e.far;
            n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), ih.prototype.updateMatrices.call(this, t)
        }
    }), ah.prototype = Object.assign(Object.create(nh.prototype), { constructor: ah, isSpotLight: !0, copy: function(t) { return nh.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), sh.prototype = Object.assign(Object.create(ih.prototype), {
        constructor: sh,
        isPointLightShadow: !0,
        updateMatrices: function(t, e) {
            void 0 === e && (e = 0);
            var n = this.camera,
                r = this.matrix,
                i = this._lightPositionWorld,
                o = this._lookTarget,
                a = this._projScreenMatrix;
            i.setFromMatrixPosition(t.matrixWorld), n.position.copy(i), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a)
        }
    }), ch.prototype = Object.assign(Object.create(nh.prototype), { constructor: ch, isPointLight: !0, copy: function(t) { return nh.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), lh.prototype = Object.assign(Object.create(go.prototype), {
        constructor: lh,
        isOrthographicCamera: !0,
        copy: function(t, e) { return go.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this },
        setViewOffset: function(t, e, n, r, i, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() },
        clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() },
        updateProjectionMatrix: function() {
            var t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                r = (this.top + this.bottom) / 2,
                i = n - t,
                o = n + t,
                n = r + e,
                t = r - e;
            null !== this.view && this.view.enabled && (r = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom, o = (i += r * this.view.offsetX) + r * this.view.width, t = (n -= e * this.view.offsetY) - e * this.view.height), this.projectionMatrix.makeOrthographic(i, o, n, t, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) { t = kr.prototype.toJSON.call(this, t); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t }
    }), uh.prototype = Object.assign(Object.create(ih.prototype), { constructor: uh, isDirectionalLightShadow: !0, updateMatrices: function(t) { ih.prototype.updateMatrices.call(this, t) } }), hh.prototype = Object.assign(Object.create(nh.prototype), { constructor: hh, isDirectionalLight: !0, copy: function(t) { return nh.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), ph.prototype = Object.assign(Object.create(nh.prototype), { constructor: ph, isAmbientLight: !0 }), dh.prototype = Object.assign(Object.create(nh.prototype), { constructor: dh, isRectAreaLight: !0, copy: function(t) { return nh.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this }, toJSON: function(t) { t = nh.prototype.toJSON.call(this, t); return t.object.width = this.width, t.object.height = this.height, t } });
    var fh = function() { Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }), this.coefficients = []; for (var t = 0; t < 9; t++) this.coefficients.push(new kn) };

    function mh(t, e) { nh.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new fh }

    function gh(t) { Su.call(this, t), this.textures = {} }
    fh.prototype.set = function(t) { for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]); return this }, fh.prototype.zero = function() { for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0); return this }, fh.prototype.getAt = function(t, e) {
        var n = t.x,
            r = t.y,
            i = t.z,
            t = this.coefficients;
        return e.copy(t[0]).multiplyScalar(.282095), e.addScaledVector(t[1], .488603 * r), e.addScaledVector(t[2], .488603 * i), e.addScaledVector(t[3], .488603 * n), e.addScaledVector(t[4], n * r * 1.092548), e.addScaledVector(t[5], r * i * 1.092548), e.addScaledVector(t[6], .315392 * (3 * i * i - 1)), e.addScaledVector(t[7], n * i * 1.092548), e.addScaledVector(t[8], .546274 * (n * n - r * r)), e
    }, fh.prototype.getIrradianceAt = function(t, e) {
        var n = t.x,
            r = t.y,
            i = t.z,
            t = this.coefficients;
        return e.copy(t[0]).multiplyScalar(.886227), e.addScaledVector(t[1], 1.023328 * r), e.addScaledVector(t[2], 1.023328 * i), e.addScaledVector(t[3], 1.023328 * n), e.addScaledVector(t[4], .858086 * n * r), e.addScaledVector(t[5], .858086 * r * i), e.addScaledVector(t[6], .743125 * i * i - .247708), e.addScaledVector(t[7], .858086 * n * i), e.addScaledVector(t[8], .429043 * (n * n - r * r)), e
    }, fh.prototype.add = function(t) { for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]); return this }, fh.prototype.addScaledSH = function(t, e) { for (var n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e); return this }, fh.prototype.scale = function(t) { for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t); return this }, fh.prototype.lerp = function(t, e) { for (var n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e); return this }, fh.prototype.equals = function(t) {
        for (var e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
        return !0
    }, fh.prototype.copy = function(t) { return this.set(t.coefficients) }, fh.prototype.clone = function() { return (new this.constructor).copy(this) }, fh.prototype.fromArray = function(t, e) { void 0 === e && (e = 0); for (var n = this.coefficients, r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r); return this }, fh.prototype.toArray = function(t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); for (var n = this.coefficients, r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r); return t }, fh.getBasisAt = function(t, e) {
        var n = t.x,
            r = t.y,
            t = t.z;
        e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * t, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * t, e[6] = .315392 * (3 * t * t - 1), e[7] = 1.092548 * n * t, e[8] = .546274 * (n * n - r * r)
    }, mh.prototype = Object.assign(Object.create(nh.prototype), { constructor: mh, isLightProbe: !0, copy: function(t) { return nh.prototype.copy.call(this, t), this.sh.copy(t.sh), this }, fromJSON: function(t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this }, toJSON: function(t) { t = nh.prototype.toJSON.call(this, t); return t.object.sh = this.sh.toArray(), t } }), gh.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: gh,
        load: function(e, n, t, r) {
            var i = this,
                o = new Tu(i.manager);
            o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.load(e, function(t) { try { n(i.parse(JSON.parse(t))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, t, r)
        },
        parse: function(t) {
            var e = this.textures;

            function n(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] }
            var r, i = new ou[t.type];
            if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new li).setHex(t.sheen)), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = 0 < t.vertexColors : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                for (var o in t.uniforms) {
                    var a = t.uniforms[o];
                    switch (i.uniforms[o] = {}, a.type) {
                        case "t":
                            i.uniforms[o].value = n(a.value);
                            break;
                        case "c":
                            i.uniforms[o].value = (new li).setHex(a.value);
                            break;
                        case "v2":
                            i.uniforms[o].value = (new Ln).fromArray(a.value);
                            break;
                        case "v3":
                            i.uniforms[o].value = (new kn).fromArray(a.value);
                            break;
                        case "v4":
                            i.uniforms[o].value = (new Nn).fromArray(a.value);
                            break;
                        case "m3":
                            i.uniforms[o].value = (new Pn).fromArray(a.value);
                            break;
                        case "m4":
                            i.uniforms[o].value = (new mr).fromArray(a.value);
                            break;
                        default:
                            i.uniforms[o].value = a.value
                    }
                }
            if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                for (var s in t.extensions) i.extensions[s] = t.extensions[s];
            return void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale && (r = t.normalScale, !1 === Array.isArray(r) && (r = [r, r]), i.normalScale = (new Ln).fromArray(r)), void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Ln).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), i
        },
        setTextures: function(t) { return this.textures = t, this }
    });
    var vh = { decodeText: function(t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); for (var e = "", n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }, extractUrlBase: function(t) { var e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } };

    function yh() { Ni.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 }

    function _h(t, e, n, r) { "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), gi.call(this, t, e, n), this.meshPerAttribute = r || 1 }

    function xh(t) { Su.call(this, t) }
    yh.prototype = Object.assign(Object.create(Ni.prototype), { constructor: yh, isInstancedBufferGeometry: !0, copy: function(t) { return Ni.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this }, clone: function() { return (new this.constructor).copy(this) }, toJSON: function() { var t = Ni.prototype.toJSON.call(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t } }), _h.prototype = Object.assign(Object.create(gi.prototype), { constructor: _h, isInstancedBufferAttribute: !0, copy: function(t) { return gi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, toJSON: function() { var t = gi.prototype.toJSON.call(this); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }), xh.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: xh,
        load: function(e, n, t, r) {
            var i = this,
                o = new Tu(i.manager);
            o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.load(e, function(t) { try { n(i.parse(JSON.parse(t))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, t, r)
        },
        parse: function(t) {
            var r = {},
                i = {};

            function e(t, e) {
                if (void 0 !== r[e]) return r[e];
                var n = t.interleavedBuffers[e],
                    t = function(t, e) {
                        if (void 0 !== i[e]) return i[e];
                        t = t.arrayBuffers[e], t = new Uint32Array(t).buffer;
                        return i[e] = t
                    }(t, n.buffer),
                    t = new Bs(new bh[n.type](t), n.stride);
                return t.uuid = n.uuid, r[e] = t
            }
            var n = new(t.isInstancedBufferGeometry ? yh : Ni),
                o = t.data.index;
            void 0 !== o && (M = new bh[o.type](o.array), n.setIndex(new gi(M, 1)));
            var a, s = t.data.attributes;
            for (a in s) {
                var c, l = s[a],
                    u = void 0;
                u = l.isInterleavedBufferAttribute ? new zs(e(t.data, l.data), l.itemSize, l.offset, l.normalized) : (c = new bh[l.type](l.array), new(l.isInstancedBufferAttribute ? _h : gi)(c, l.itemSize, l.normalized)), void 0 !== l.name && (u.name = l.name), n.setAttribute(a, u)
            }
            var h = t.data.morphAttributes;
            if (h)
                for (var p in h) {
                    for (var d = h[p], f = [], m = 0, g = d.length; m < g; m++) {
                        var v = d[m],
                            y = void 0;
                        y = v.isInterleavedBufferAttribute ? new zs(e(t.data, v.data), v.itemSize, v.offset, v.normalized) : new gi(new bh[v.type](v.array), v.itemSize, v.normalized), void 0 !== v.name && (y.name = v.name), f.push(y)
                    }
                    n.morphAttributes[p] = f
                }
            t.data.morphTargetsRelative && (n.morphTargetsRelative = !0);
            var _ = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== _)
                for (var x = 0, b = _.length; x !== b; ++x) {
                    var w = _[x];
                    n.addGroup(w.start, w.count, w.materialIndex)
                }
            var M, o = t.data.boundingSphere;
            return void 0 !== o && (M = new kn, void 0 !== o.center && M.fromArray(o.center), n.boundingSphere = new ar(M, o.radius)), t.name && (n.name = t.name), t.userData && (n.userData = t.userData), n
        }
    });
    var bh = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array };

    function wh(t) { Su.call(this, t) }
    wh.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: wh,
        load: function(r, i, t, o) {
            var a = this,
                e = "" === this.path ? vh.extractUrlBase(r) : this.path;
            this.resourcePath = this.resourcePath || e;
            e = new Tu(a.manager);
            e.setPath(this.path), e.setRequestHeader(this.requestHeader), e.load(r, function(t) {
                var e = null;
                try { e = JSON.parse(t) } catch (t) { return void 0 !== o && o(t), void console.error("THREE:ObjectLoader: Can't parse " + r + ".", t.message) }
                var n = e.metadata;
                void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? a.parse(e, i) : console.error("THREE.ObjectLoader: Can't load " + r)
            }, t, o)
        },
        parse: function(t, e) {
            var n = this.parseShape(t.shapes),
                r = this.parseGeometries(t.geometries, n),
                n = this.parseImages(t.images, function() { void 0 !== e && e(i) }),
                n = this.parseTextures(t.textures, n),
                n = this.parseMaterials(t.materials, n),
                i = this.parseObject(t.object, r, n);
            return t.animations && (i.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(i), i
        },
        parseShape: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var n = 0, r = t.length; n < r; n++) {
                    var i = (new eh).fromJSON(t[n]);
                    e[i.uuid] = i
                }
            return e
        },
        parseGeometries: function(t, e) {
            var n, r = {};
            if (void 0 !== t)
                for (var i = new xh, o = 0, a = t.length; o < a; o++) {
                    var s = void 0,
                        c = t[o];
                    switch (c.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            s = new Yl[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            s = new Yl[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            s = new Yl[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            s = new Yl[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            s = new Yl[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            s = new Yl[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            s = new Yl[c.type](c.radius, c.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            s = new Yl[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            s = new Yl[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            s = new Yl[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            s = new Yl[c.type]((new Qu[c.path.type]).fromJSON(c.path), c.tubularSegments, c.radius, c.radialSegments, c.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            s = new Yl[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            s = new Yl[c.type](c.vertices, c.indices, c.radius, c.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            n = [];
                            for (var l = 0, u = c.shapes.length; l < u; l++) {
                                var h = e[c.shapes[l]];
                                n.push(h)
                            }
                            s = new Yl[c.type](n, c.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            n = [];
                            for (var p = 0, d = c.shapes.length; p < d; p++) {
                                var f = e[c.shapes[p]];
                                n.push(f)
                            }
                            var m = c.options.extrudePath;
                            void 0 !== m && (c.options.extrudePath = (new Qu[m.type]).fromJSON(m)), s = new Yl[c.type](n, c.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            s = i.parse(c);
                            break;
                        case "Geometry":
                            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                            continue
                    }
                    s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), !0 === s.isBufferGeometry && void 0 !== c.userData && (s.userData = c.userData), r[c.uuid] = s
                }
            return r
        },
        parseMaterials: function(t, e) {
            var n = {},
                r = {};
            if (void 0 !== t) {
                var i = new gh;
                i.setTextures(e);
                for (var o = 0, a = t.length; o < a; o++) {
                    var s = t[o];
                    if ("MultiMaterial" === s.type) {
                        for (var c = [], l = 0; l < s.materials.length; l++) {
                            var u = s.materials[l];
                            void 0 === n[u.uuid] && (n[u.uuid] = i.parse(u)), c.push(n[u.uuid])
                        }
                        r[s.uuid] = c
                    } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                }
            }
            return r
        },
        parseAnimations: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var r = t[n],
                    i = _u.parse(r);
                void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i)
            }
            return e
        },
        parseImages: function(t, e) {
            var n = this,
                r = {};

            function i(t) { return n.manager.itemStart(t), o.load(t, function() { n.manager.itemEnd(t) }, void 0, function() { n.manager.itemError(t), n.manager.itemEnd(t) }) }
            if (void 0 !== t && 0 < t.length) {
                var o, e = new wu(e);
                (o = new Ru(e)).setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = t.length; a < s; a++) {
                    var c = t[a],
                        l = c.url;
                    if (Array.isArray(l)) {
                        r[c.uuid] = [];
                        for (var u = 0, h = l.length; u < h; u++) {
                            var p = l[u],
                                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.resourcePath + p;
                            r[c.uuid].push(i(p))
                        }
                    } else {
                        var d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.resourcePath + c.url;
                        r[c.uuid] = i(d)
                    }
                }
            }
            return r
        },
        parseTextures: function(t, e) {
            function n(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) }
            var r = {};
            if (void 0 !== t)
                for (var i = 0, o = t.length; i < o; i++) {
                    var a = t[i];
                    void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                    var s = void 0;
                    (s = new(Array.isArray(e[a.image]) ? Wo : Dn)(e[a.image])).needsUpdate = !0, s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.mapping && (s.mapping = n(a.mapping, Sh)), void 0 !== a.offset && s.offset.fromArray(a.offset), void 0 !== a.repeat && s.repeat.fromArray(a.repeat), void 0 !== a.center && s.center.fromArray(a.center), void 0 !== a.rotation && (s.rotation = a.rotation), void 0 !== a.wrap && (s.wrapS = n(a.wrap[0], Eh), s.wrapT = n(a.wrap[1], Eh)), void 0 !== a.format && (s.format = a.format), void 0 !== a.type && (s.type = a.type), void 0 !== a.encoding && (s.encoding = a.encoding), void 0 !== a.minFilter && (s.minFilter = n(a.minFilter, Th)), void 0 !== a.magFilter && (s.magFilter = n(a.magFilter, Th)), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), void 0 !== a.flipY && (s.flipY = a.flipY), void 0 !== a.premultiplyAlpha && (s.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (s.unpackAlignment = a.unpackAlignment), r[a.uuid] = s
                }
            return r
        },
        parseObject: function(t, e, o) {
            var n, r;

            function i(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] }

            function a(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                            var i = t[n];
                            void 0 === o[i] && console.warn("THREE.ObjectLoader: Undefined material", i), e.push(o[i])
                        }
                        return e
                    }
                    return void 0 === o[t] && console.warn("THREE.ObjectLoader: Undefined material", t), o[t]
                }
            }
            switch (t.type) {
                case "Scene":
                    s = new Ns, void 0 !== t.background && Number.isInteger(t.background) && (s.background = new li(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new Ds(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new Is(t.fog.color, t.fog.density)));
                    break;
                case "PerspectiveCamera":
                    s = new vo(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                    break;
                case "OrthographicCamera":
                    s = new lh(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                    break;
                case "AmbientLight":
                    s = new ph(t.color, t.intensity);
                    break;
                case "DirectionalLight":
                    s = new hh(t.color, t.intensity);
                    break;
                case "PointLight":
                    s = new ch(t.color, t.intensity, t.distance, t.decay);
                    break;
                case "RectAreaLight":
                    s = new dh(t.color, t.intensity, t.width, t.height);
                    break;
                case "SpotLight":
                    s = new ah(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                    break;
                case "HemisphereLight":
                    s = new rh(t.color, t.groundColor, t.intensity);
                    break;
                case "LightProbe":
                    s = (new mh).fromJSON(t);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    s = new $i(n = i(t.geometry), r = a(t.material));
                    break;
                case "InstancedMesh":
                    n = i(t.geometry), r = a(t.material);
                    var s, c = t.count,
                        l = t.instanceMatrix;
                    (s = new yc(n, r, c)).instanceMatrix = new gi(new Float32Array(l.array), 16);
                    break;
                case "LOD":
                    s = new cc;
                    break;
                case "Line":
                    s = new Ec(i(t.geometry), a(t.material), t.mode);
                    break;
                case "LineLoop":
                    s = new Rc(i(t.geometry), a(t.material));
                    break;
                case "LineSegments":
                    s = new Lc(i(t.geometry), a(t.material));
                    break;
                case "PointCloud":
                case "Points":
                    s = new Nc(i(t.geometry), a(t.material));
                    break;
                case "Sprite":
                    s = new $s(a(t.material));
                    break;
                case "Group":
                    s = new As;
                    break;
                default:
                    s = new kr
            }
            if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children)
                for (var u = t.children, h = 0; h < u.length; h++) s.add(this.parseObject(u[h], e, o));
            if ("LOD" === t.type) {
                void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
                for (var p = t.levels, d = 0; d < p.length; d++) {
                    var f = p[d],
                        m = s.getObjectByProperty("uuid", f.object);
                    void 0 !== m && s.addLevel(m, f.distance)
                }
            }
            return s
        }
    });
    var Mh, Sh = { UVMapping: 300, CubeReflectionMapping: Tt, CubeRefractionMapping: At, EquirectangularReflectionMapping: Lt, EquirectangularRefractionMapping: Rt, CubeUVReflectionMapping: Ct, CubeUVRefractionMapping: Pt },
        Eh = { RepeatWrapping: Ot, ClampToEdgeWrapping: It, MirroredRepeatWrapping: Dt },
        Th = { NearestFilter: Nt, NearestMipmapNearestFilter: Bt, NearestMipmapLinearFilter: Ft, LinearFilter: Ut, LinearMipmapNearestFilter: zt, LinearMipmapLinearFilter: Ht };

    function Ah(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Su.call(this, t), this.options = { premultiplyAlpha: "none" } }

    function Lh() { this.type = "ShapePath", this.color = new li, this.subPaths = [], this.currentPath = null }

    function Rh(t) { this.type = "Font", this.data = t }

    function Ch(t) { Su.call(this, t) }
    Ah.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Ah,
        isImageBitmapLoader: !0,
        setOptions: function(t) { return this.options = t, this },
        load: function(e, n, t, r) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var i = this,
                o = bu.get(e);
            if (void 0 !== o) return i.manager.itemStart(e), setTimeout(function() { n && n(o), i.manager.itemEnd(e) }, 0), o;
            fetch(e).then(function(t) { return t.blob() }).then(function(t) { return createImageBitmap(t, i.options) }).then(function(t) { bu.add(e, t), n && n(t), i.manager.itemEnd(e) }).catch(function(t) { r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) }), i.manager.itemStart(e)
        }
    }), Object.assign(Lh.prototype, {
        moveTo: function(t, e) { return this.currentPath = new th, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this },
        lineTo: function(t, e) { return this.currentPath.lineTo(t, e), this },
        quadraticCurveTo: function(t, e, n, r) { return this.currentPath.quadraticCurveTo(t, e, n, r), this },
        bezierCurveTo: function(t, e, n, r, i, o) { return this.currentPath.bezierCurveTo(t, e, n, r, i, o), this },
        splineThru: function(t) { return this.currentPath.splineThru(t), this },
        toShapes: function(t, e) {
            function n(t) {
                for (var e = [], n = 0, r = t.length; n < r; n++) {
                    var i = t[n],
                        o = new eh;
                    o.curves = i.curves, e.push(o)
                }
                return e
            }
            var r, i, o, a = Ml.isClockWise,
                s = this.subPaths;
            if (0 === s.length) return [];
            if (!0 === e) return n(s);
            var c = [];
            if (1 === s.length) return i = s[0], (o = new eh).curves = i.curves, c.push(o), c;
            var l, u = !a(s[0].getPoints()),
                u = t ? !u : u,
                h = [],
                p = [],
                d = [],
                f = 0;
            p[f] = void 0, d[f] = [];
            for (var m, g = 0, v = s.length; g < v; g++) r = a(l = (i = s[g]).getPoints()), (r = t ? !r : r) ? (!u && p[f] && f++, p[f] = { s: new eh, p: l }, p[f].s.curves = i.curves, u && f++, d[f] = []) : d[f].push({ h: i, p: l[0] });
            if (!p[0]) return n(s);
            if (1 < p.length) {
                for (var y = !1, _ = [], x = 0, b = p.length; x < b; x++) h[x] = [];
                for (var w = 0, M = p.length; w < M; w++)
                    for (var S = d[w], E = 0; E < S.length; E++) {
                        for (var T = S[E], A = !0, L = 0; L < p.length; L++) ! function(t, e) {
                            for (var n = e.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                                var a = e[i],
                                    s = e[o],
                                    c = s.x - a.x,
                                    l = s.y - a.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (a = e[o], c = -c, s = e[i], l = -l), !(t.y < a.y || t.y > s.y))
                                        if (t.y === a.y) { if (t.x === a.x) return 1 } else {
                                            c = l * (t.x - a.x) - c * (t.y - a.y);
                                            if (0 == c) return 1;
                                            c < 0 || (r = !r)
                                        }
                                } else if (t.y === a.y && (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)) return 1
                            }
                            return r
                        }(T.p, p[L].p) || (w !== L && _.push({ froms: w, tos: L, hole: E }), A ? (A = !1, h[L].push(T)) : y = !0);
                        A && h[w].push(T)
                    }
                0 < _.length && (y || (d = h))
            }
            for (var R = 0, C = p.length; R < C; R++) { o = p[R].s, c.push(o); for (var P = 0, O = (m = d[R]).length; P < O; P++) o.holes.push(m[P].h) }
            return c
        }
    }), Object.assign(Rh.prototype, {
        isFont: !0,
        generateShapes: function(t, e) {
            void 0 === e && (e = 100);
            for (var n = [], r = function(t, e, n) {
                    for (var r = Array.from ? Array.from(t) : String(t).split(""), i = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, a = [], s = 0, c = 0, l = 0; l < r.length; l++) {
                        var u = r[l];
                        "\n" === u ? (s = 0, c -= o) : (u = function(t, e, n, r, i) {
                            var o = i.glyphs[t] || i.glyphs["?"];
                            if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + i.familyName + ".");
                            var a, s, c, l, u, h, p, d, f = new Lh;
                            if (o.o)
                                for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), g = 0, v = m.length; g < v;) switch (m[g++]) {
                                    case "m":
                                        a = m[g++] * e + n, s = m[g++] * e + r, f.moveTo(a, s);
                                        break;
                                    case "l":
                                        a = m[g++] * e + n, s = m[g++] * e + r, f.lineTo(a, s);
                                        break;
                                    case "q":
                                        c = m[g++] * e + n, l = m[g++] * e + r, u = m[g++] * e + n, h = m[g++] * e + r, f.quadraticCurveTo(u, h, c, l);
                                        break;
                                    case "b":
                                        c = m[g++] * e + n, l = m[g++] * e + r, u = m[g++] * e + n, h = m[g++] * e + r, p = m[g++] * e + n, d = m[g++] * e + r, f.bezierCurveTo(u, h, p, d, c, l)
                                }
                            return { offsetX: o.ha * e, path: f }
                        }(u, i, s, c, n), s += u.offsetX, a.push(u.path))
                    }
                    return a
                }(t, e, this.data), i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
            return n
        }
    }), Ch.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Ch,
        load: function(t, r, e, n) {
            var i = this,
                o = new Tu(this.manager);
            o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.load(t, function(e) {
                var n;
                try { n = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2)) }
                var t = i.parse(n);
                r && r(t)
            }, e, n)
        },
        parse: function(t) { return new Rh(t) }
    });
    var Ph = { getContext: function() { return void 0 === Mh && (Mh = new(window.AudioContext || window.webkitAudioContext)), Mh }, setContext: function(t) { Mh = t } };

    function Oh(t) { Su.call(this, t) }

    function Ih(t, e, n) {
        mh.call(this, void 0, n);
        var r = (new li).set(t),
            n = (new li).set(e),
            t = new kn(r.r, r.g, r.b),
            e = new kn(n.r, n.g, n.b),
            r = Math.sqrt(Math.PI),
            n = r * Math.sqrt(.75);
        this.sh.coefficients[0].copy(t).add(e).multiplyScalar(r), this.sh.coefficients[1].copy(t).sub(e).multiplyScalar(n)
    }

    function Dh(t, e) {
        mh.call(this, void 0, e);
        t = (new li).set(t);
        this.sh.coefficients[0].set(t.r, t.g, t.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    Oh.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Oh,
        load: function(n, r, t, i) {
            var o = this,
                e = new Tu(o.manager);
            e.setResponseType("arraybuffer"), e.setPath(o.path), e.setRequestHeader(o.requestHeader), e.load(n, function(t) {
                try {
                    var e = t.slice(0);
                    Ph.getContext().decodeAudioData(e, function(t) { r(t) })
                } catch (t) { i ? i(t) : console.error(t), o.manager.itemError(n) }
            }, t, i)
        }
    }), Ih.prototype = Object.assign(Object.create(mh.prototype), { constructor: Ih, isHemisphereLightProbe: !0, copy: function(t) { return mh.prototype.copy.call(this, t), this }, toJSON: function(t) { return mh.prototype.toJSON.call(this, t) } }), Dh.prototype = Object.assign(Object.create(mh.prototype), { constructor: Dh, isAmbientLightProbe: !0, copy: function(t) { return mh.prototype.copy.call(this, t), this }, toJSON: function(t) { return mh.prototype.toJSON.call(this, t) } });
    var Nh = new mr,
        Bh = new mr;

    function Fh() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new vo, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new vo, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } }
    Object.assign(Fh.prototype, {
        update: function(t) {
            var e, n, r, i, o, a = this._cache;
            a.focus === t.focus && a.fov === t.fov && a.aspect === t.aspect * this.aspect && a.near === t.near && a.far === t.far && a.zoom === t.zoom && a.eyeSep === this.eyeSep || (a.focus = t.focus, a.fov = t.fov, a.aspect = t.aspect * this.aspect, a.near = t.near, a.far = t.far, a.zoom = t.zoom, a.eyeSep = this.eyeSep, e = t.projectionMatrix.clone(), n = (o = a.eyeSep / 2) * a.near / a.focus, r = a.near * Math.tan(An.DEG2RAD * a.fov * .5) / a.zoom, Bh.elements[12] = -o, Nh.elements[12] = o, i = -r * a.aspect + n, o = r * a.aspect + n, e.elements[0] = 2 * a.near / (o - i), e.elements[8] = (o + i) / (o - i), this.cameraL.projectionMatrix.copy(e), i = -r * a.aspect - n, o = r * a.aspect - n, e.elements[0] = 2 * a.near / (o - i), e.elements[8] = (o + i) / (o - i), this.cameraR.projectionMatrix.copy(e)), this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Bh), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Nh)
        }
    });

    function Uh(t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 }
    Uh.prototype.start = function() { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }, Uh.prototype.stop = function() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }, Uh.prototype.getElapsedTime = function() { return this.getDelta(), this.elapsedTime }, Uh.prototype.getDelta = function() { var t, e = 0; return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (e = ((t = ("undefined" == typeof performance ? Date : performance).now()) - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e), e) };

    function zh(t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) }
    var Hh = new kn,
        kh = new zn,
        Gh = new kn,
        Vh = new kn,
        jh = function(r) {
            function t() { r.call(this), this.type = "AudioListener", this.context = Ph.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Uh }
            return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.getInput = function() { return this.gain }, t.prototype.removeFilter = function() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, t.prototype.getFilter = function() { return this.filter }, t.prototype.setFilter = function(t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, t.prototype.getMasterVolume = function() { return this.gain.gain.value }, t.prototype.setMasterVolume = function(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }, t.prototype.updateMatrixWorld = function(t) {
                r.prototype.updateMatrixWorld.call(this, t);
                var e = this.context.listener,
                    n = this.up;
                this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Hh, kh, Gh), Vh.set(0, 0, -1).applyQuaternion(kh), e.positionX ? (t = this.context.currentTime + this.timeDelta, e.positionX.linearRampToValueAtTime(Hh.x, t), e.positionY.linearRampToValueAtTime(Hh.y, t), e.positionZ.linearRampToValueAtTime(Hh.z, t), e.forwardX.linearRampToValueAtTime(Vh.x, t), e.forwardY.linearRampToValueAtTime(Vh.y, t), e.forwardZ.linearRampToValueAtTime(Vh.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)) : (e.setPosition(Hh.x, Hh.y, Hh.z), e.setOrientation(Vh.x, Vh.y, Vh.z, n.x, n.y, n.z))
            }, t
        }(kr),
        Wh = function(e) {
            function t(t) { e.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] }
            return e && (t.__proto__ = e), ((t.prototype = Object.create(e && e.prototype)).constructor = t).prototype.getOutput = function() { return this.gain }, t.prototype.setNodeSource = function(t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }, t.prototype.setMediaElementSource = function(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }, t.prototype.setMediaStreamSource = function(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this }, t.prototype.setBuffer = function(t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }, t.prototype.play = function(t) {
                if (void 0 === t && (t = 0), !0 !== this.isPlaying) {
                    if (!1 !== this.hasPlaybackControl) {
                        this._startedAt = this.context.currentTime + t;
                        t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                } else console.warn("THREE.Audio: Audio is already playing.")
            }, t.prototype.pause = function() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, t.prototype.stop = function() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, t.prototype.connect = function() {
                if (0 < this.filters.length) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }, t.prototype.disconnect = function() {
                if (0 < this.filters.length) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }, t.prototype.getFilters = function() { return this.filters }, t.prototype.setFilters = function(t) { return t = t || [], !0 === this._connected ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, t.prototype.setDetune = function(t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, t.prototype.getDetune = function() { return this.detune }, t.prototype.getFilter = function() { return this.getFilters()[0] }, t.prototype.setFilter = function(t) { return this.setFilters(t ? [t] : []) }, t.prototype.setPlaybackRate = function(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, t.prototype.getPlaybackRate = function() { return this.playbackRate }, t.prototype.onEnded = function() { this.isPlaying = !1 }, t.prototype.getLoop = function() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, t.prototype.setLoop = function(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }, t.prototype.setLoopStart = function(t) { return this.loopStart = t, this }, t.prototype.setLoopEnd = function(t) { return this.loopEnd = t, this }, t.prototype.getVolume = function() { return this.gain.gain.value }, t.prototype.setVolume = function(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }, t
        }(kr),
        qh = new kn,
        Xh = new zn,
        Yh = new kn,
        Zh = new kn,
        Jh = function(n) {
            function t(t) { n.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) }
            return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.getOutput = function() { return this.panner }, t.prototype.getRefDistance = function() { return this.panner.refDistance }, t.prototype.setRefDistance = function(t) { return this.panner.refDistance = t, this }, t.prototype.getRolloffFactor = function() { return this.panner.rolloffFactor }, t.prototype.setRolloffFactor = function(t) { return this.panner.rolloffFactor = t, this }, t.prototype.getDistanceModel = function() { return this.panner.distanceModel }, t.prototype.setDistanceModel = function(t) { return this.panner.distanceModel = t, this }, t.prototype.getMaxDistance = function() { return this.panner.maxDistance }, t.prototype.setMaxDistance = function(t) { return this.panner.maxDistance = t, this }, t.prototype.setDirectionalCone = function(t, e, n) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this }, t.prototype.updateMatrixWorld = function(t) {
                var e;
                n.prototype.updateMatrixWorld.call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying || (this.matrixWorld.decompose(qh, Xh, Yh), Zh.set(0, 0, 1).applyQuaternion(Xh), (e = this.panner).positionX ? (t = this.context.currentTime + this.listener.timeDelta, e.positionX.linearRampToValueAtTime(qh.x, t), e.positionY.linearRampToValueAtTime(qh.y, t), e.positionZ.linearRampToValueAtTime(qh.z, t), e.orientationX.linearRampToValueAtTime(Zh.x, t), e.orientationY.linearRampToValueAtTime(Zh.y, t), e.orientationZ.linearRampToValueAtTime(Zh.z, t)) : (e.setPosition(qh.x, qh.y, qh.z), e.setOrientation(Zh.x, Zh.y, Zh.z)))
            }, t
        }(Wh);

    function Kh(t, e, n) {
        var r, i, o;
        switch (this.binding = t, this.valueSize = n, e) {
            case "quaternion":
                r = this._slerp, i = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                r = this._select, i = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                break;
            default:
                r = this._lerp, i = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    zh.prototype.getFrequencyData = function() { return this.analyser.getByteFrequencyData(this.data), this.data }, zh.prototype.getAverageFrequency = function() { for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n]; return t / e.length }, Object.assign(Kh.prototype, {
        accumulate: function(t, e) {
            var n = this.buffer,
                r = this.valueSize,
                i = t * r + r,
                t = this.cumulativeWeight;
            if (0 === t) {
                for (var o = 0; o !== r; ++o) n[i + o] = n[o];
                t = e
            } else {
                e = e / (t += e);
                this._mixBufferRegion(n, i, 0, e, r)
            }
            this.cumulativeWeight = t
        },
        accumulateAdditive: function(t) {
            var e = this.buffer,
                n = this.valueSize,
                r = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
        },
        apply: function(t) {
            var e = this.valueSize,
                n = this.buffer,
                r = t * e + e,
                i = this.cumulativeWeight,
                o = this.cumulativeWeightAdditive,
                a = this.binding;
            this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1 && (t = e * this._origIndex, this._mixBufferRegion(n, r, t, 1 - i, e)), 0 < o && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
            for (var s = e, c = e + e; s !== c; ++s)
                if (n[s] !== n[s + e]) { a.setValue(n, r); break }
        },
        saveOriginalState: function() {
            var t = this.binding,
                e = this.buffer,
                n = this.valueSize,
                r = n * this._origIndex;
            t.getValue(e, r);
            for (var i = n, o = r; i !== o; ++i) e[i] = e[r + i % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
        },
        restoreOriginalState: function() {
            var t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _setAdditiveIdentityNumeric: function() { for (var t = this._addIndex * this.valueSize, e = t + this.valueSize, n = t; n < e; n++) this.buffer[n] = 0 },
        _setAdditiveIdentityQuaternion: function() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 },
        _setAdditiveIdentityOther: function() { for (var t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n] },
        _select: function(t, e, n, r, i) {
            if (.5 <= r)
                for (var o = 0; o !== i; ++o) t[e + o] = t[n + o]
        },
        _slerp: function(t, e, n, r) { zn.slerpFlat(t, e, t, e, t, n, r) },
        _slerpAdditive: function(t, e, n, r, i) {
            i = this._workIndex * i;
            zn.multiplyQuaternionsFlat(t, i, t, e, t, n), zn.slerpFlat(t, e, t, e, t, i, r)
        },
        _lerp: function(t, e, n, r, i) {
            for (var o = 1 - r, a = 0; a !== i; ++a) {
                var s = e + a;
                t[s] = t[s] * o + t[n + a] * r
            }
        },
        _lerpAdditive: function(t, e, n, r, i) {
            for (var o = 0; o !== i; ++o) {
                var a = e + o;
                t[a] = t[a] + t[n + o] * r
            }
        }
    });
    var Qh = "\\[\\]\\.:\\/",
        $h = new RegExp("[" + Qh + "]", "g"),
        tp = "[^" + Qh + "]",
        ep = "[^" + Qh.replace("\\.", "") + "]",
        np = /((?:WC+[\/:])*)/.source.replace("WC", tp),
        rp = /(WCOD+)?/.source.replace("WCOD", ep),
        ip = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", tp),
        op = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", tp),
        ap = new RegExp("^" + np + rp + ip + op + "$"),
        sp = ["material", "materials", "bones"];

    function cp(t, e, n) {
        n = n || lp.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, n)
    }

    function lp(t, e, n) { this.path = e, this.parsedPath = n || lp.parseTrackName(e), this.node = lp.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t }

    function up() {
        var t = arguments;
        this.uuid = An.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var n = 0, r = arguments.length; n !== r; ++n) e[t[n].uuid] = n;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var i = this;
        this.stats = { objects: {get total() { return i._objects.length }, get inUse() { return this.total - i.nCachedObjects_ } }, get bindingsPerObject() { return i._bindings.length } }
    }
    Object.assign(cp.prototype, {
        getValue: function(t, e) {
            this.bind();
            var n = this._targetGroup.nCachedObjects_,
                n = this._bindings[n];
            void 0 !== n && n.getValue(t, e)
        },
        setValue: function(t, e) { for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e) },
        bind: function() { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind() },
        unbind: function() { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind() }
    }), Object.assign(lp, {
        Composite: cp,
        create: function(t, e, n) { return new(t && t.isAnimationObjectGroup ? lp.Composite : lp)(t, e, n) },
        sanitizeNodeName: function(t) { return t.replace(/\s/g, "_").replace($h, "") },
        parseTrackName: function(t) {
            var e = ap.exec(t);
            if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            var n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
                r = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== r && -1 !== r && (e = n.nodeName.substring(r + 1), -1 !== sp.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e)), null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n
        },
        findNode: function(t, r) {
            if (!r || "" === r || "." === r || -1 === r || r === t.name || r === t.uuid) return t;
            if (t.skeleton) { var e = t.skeleton.getBoneByName(r); if (void 0 !== e) return e }
            if (t.children) {
                var i = function(t) {
                        for (var e = 0; e < t.length; e++) {
                            var n = t[e];
                            if (n.name === r || n.uuid === r) return n;
                            n = i(n.children);
                            if (n) return n
                        }
                        return null
                    },
                    t = i(t.children);
                if (t) return t
            }
            return null
        }
    }), Object.assign(lp.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
        Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
        GetterByBindingType: [function(t, e) { t[e] = this.node[this.propertyName] }, function(t, e) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) t[e++] = n[r] }, function(t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function(t, e) { this.resolvedProperty.toArray(t, e) }],
        SetterByBindingTypeAndVersioning: [
            [function(t, e) { this.targetObject[this.propertyName] = t[e] }, function(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }],
            [function(t, e) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++] }, function(t, e) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                this.targetObject.needsUpdate = !0
            }, function(t, e) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }],
            [function(t, e) { this.resolvedProperty.fromArray(t, e) }, function(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]
        ],
        getValue: function(t, e) { this.bind(), this.getValue(t, e) },
        setValue: function(t, e) { this.bind(), this.setValue(t, e) },
        bind: function() {
            var t = this.node,
                e = this.parsedPath,
                n = e.objectName,
                r = e.propertyName,
                i = e.propertyIndex;
            if (t || (t = lp.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                if (n) {
                    var o = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (var a = 0; a < t.length; a++)
                                if (t[a].name === o) { o = a; break }
                            break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                var s = t[r];
                if (void 0 !== s) {
                    var c = this.Versioning.None;
                    void 0 !== (this.targetObject = t).needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                    var l = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
                        }
                        l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                } else {
                    e = e.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + e + "." + r + " but it wasn't found.", t)
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
    }), Object.assign(lp.prototype, { _getValue_unbound: lp.prototype.getValue, _setValue_unbound: lp.prototype.setValue }), Object.assign(up.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var t = arguments, e = this._objects, n = this._indicesByUUID, r = this._paths, i = this._parsedPaths, o = this._bindings, a = o.length, s = void 0, c = e.length, l = this.nCachedObjects_, u = 0, h = arguments.length; u !== h; ++u) {
                var p = t[u],
                    d = p.uuid,
                    f = n[d];
                if (void 0 === f) { f = c++, n[d] = f, e.push(p); for (var m = 0, g = a; m !== g; ++m) o[m].push(new lp(p, r[m], i[m])) } else if (f < l) {
                    s = e[f];
                    var v = --l,
                        y = e[v];
                    e[n[y.uuid] = f] = y, e[n[d] = v] = p;
                    for (var _ = 0, x = a; _ !== x; ++_) {
                        var b = o[_],
                            w = b[v],
                            M = b[f];
                        b[f] = w, void 0 === M && (M = new lp(p, r[_], i[_])), b[v] = M
                    }
                } else e[f] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = l
        },
        remove: function() {
            for (var t = arguments, e = this._objects, n = this._indicesByUUID, r = this._bindings, i = r.length, o = this.nCachedObjects_, a = 0, s = arguments.length; a !== s; ++a) {
                var c = t[a],
                    l = c.uuid,
                    u = n[l];
                if (void 0 !== u && o <= u) {
                    var h = o++,
                        p = e[h];
                    e[n[p.uuid] = u] = p, e[n[l] = h] = c;
                    for (var d = 0, f = i; d !== f; ++d) {
                        var m = r[d],
                            g = m[h],
                            v = m[u];
                        m[u] = g, m[h] = v
                    }
                }
            }
            this.nCachedObjects_ = o
        },
        uncache: function() {
            for (var t = arguments, e = this._objects, n = this._indicesByUUID, r = this._bindings, i = r.length, o = this.nCachedObjects_, a = e.length, s = 0, c = arguments.length; s !== c; ++s) {
                var l = t[s].uuid,
                    u = n[l];
                if (void 0 !== u)
                    if (delete n[l], u < o) {
                        var h = --o,
                            l = e[h],
                            p = --a,
                            d = e[p];
                        e[n[l.uuid] = u] = l, e[n[d.uuid] = h] = d, e.pop();
                        for (var f = 0, m = i; f !== m; ++f) {
                            var g = r[f],
                                v = g[h],
                                y = g[p];
                            g[u] = v, g[h] = y, g.pop()
                        }
                    } else {
                        var _ = --a,
                            d = e[_];
                        e[n[d.uuid] = u] = d, e.pop();
                        for (var x = 0, b = i; x !== b; ++x) {
                            var w = r[x];
                            w[u] = w[_], w.pop()
                        }
                    }
            }
            this.nCachedObjects_ = o
        },
        subscribe_: function(t, e) {
            var n = this._bindingsIndicesByPath,
                r = n[t],
                i = this._bindings;
            if (void 0 !== r) return i[r];
            var o = this._paths,
                a = this._parsedPaths,
                s = this._objects,
                c = s.length,
                l = this.nCachedObjects_,
                u = new Array(c),
                r = i.length;
            n[t] = r, o.push(t), a.push(e), i.push(u);
            for (var h = l, p = s.length; h !== p; ++h) {
                var d = s[h];
                u[h] = new lp(d, t, e)
            }
            return u
        },
        unsubscribe_: function(t) {
            var e, n, r, i, o, a = this._bindingsIndicesByPath,
                s = a[t];
            void 0 !== s && (e = this._paths, n = this._parsedPaths, o = (r = this._bindings)[i = r.length - 1], r[a[t[i]] = s] = o, r.pop(), n[s] = n[i], n.pop(), e[s] = e[i], e.pop())
        }
    });

    function hp(t, e, n, r) {
        this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = r || e.blendMode;
        for (var i = e.tracks, o = i.length, a = new Array(o), s = { endingStart: en, endingEnd: en }, c = 0; c !== o; ++c) {
            var l = i[c].createInterpolant(null);
            (a[c] = l).settings = s
        }
        this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function pp(t) { this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 }
    hp.prototype.play = function() { return this._mixer._activateAction(this), this }, hp.prototype.stop = function() { return this._mixer._deactivateAction(this), this.reset() }, hp.prototype.reset = function() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, hp.prototype.isRunning = function() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, hp.prototype.isScheduled = function() { return this._mixer._isActiveAction(this) }, hp.prototype.startAt = function(t) { return this._startTime = t, this }, hp.prototype.setLoop = function(t, e) { return this.loop = t, this.repetitions = e, this }, hp.prototype.setEffectiveWeight = function(t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, hp.prototype.getEffectiveWeight = function() { return this._effectiveWeight }, hp.prototype.fadeIn = function(t) { return this._scheduleFading(t, 0, 1) }, hp.prototype.fadeOut = function(t) { return this._scheduleFading(t, 1, 0) }, hp.prototype.crossFadeFrom = function(t, e, n) { var r, i; return t.fadeOut(e), this.fadeIn(e), n && (r = this._clip.duration, n = (i = t._clip.duration) / r, i = r / i, t.warp(1, n, e), this.warp(i, 1, e)), this }, hp.prototype.crossFadeTo = function(t, e, n) { return t.crossFadeFrom(this, e, n) }, hp.prototype.stopFading = function() { var t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, hp.prototype.setEffectiveTimeScale = function(t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, hp.prototype.getEffectiveTimeScale = function() { return this._effectiveTimeScale }, hp.prototype.setDuration = function(t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, hp.prototype.syncWith = function(t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, hp.prototype.halt = function(t) { return this.warp(this._effectiveTimeScale, 0, t) }, hp.prototype.warp = function(t, e, n) {
        var r = this._mixer,
            i = r.time,
            o = this.timeScale,
            a = this._timeScaleInterpolant;
        null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
        r = a.parameterPositions, a = a.sampleValues;
        return r[0] = i, r[1] = i + n, a[0] = t / o, a[1] = e / o, this
    }, hp.prototype.stopWarping = function() { var t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, hp.prototype.getMixer = function() { return this._mixer }, hp.prototype.getClip = function() { return this._clip }, hp.prototype.getRoot = function() { return this._localRoot || this._mixer._root }, hp.prototype._update = function(t, e, n, r) {
        if (this.enabled) {
            var i = this._startTime;
            if (null !== i) {
                i = (t - i) * n;
                if (i < 0 || 0 === n) return;
                this._startTime = null, e = n * i
            }
            e *= this._updateTimeScale(t);
            var o = this._updateTime(e),
                a = this._updateWeight(t);
            if (0 < a) {
                var s = this._interpolants,
                    c = this._propertyBindings;
                switch (this.blendMode) {
                    case 2501:
                        for (var l = 0, u = s.length; l !== u; ++l) s[l].evaluate(o), c[l].accumulateAdditive(a);
                        break;
                    case 2500:
                    default:
                        for (var h = 0, p = s.length; h !== p; ++h) s[h].evaluate(o), c[h].accumulate(r, a)
                }
            }
        } else this._updateWeight(t)
    }, hp.prototype._updateWeight = function(t) { var e, n, r = 0; return this.enabled && (r = this.weight, null !== (e = this._weightInterpolant) && (r *= n = e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)))), this._effectiveWeight = r }, hp.prototype._updateTimeScale = function(t) { var e, n = 0; return this.paused || (n = this.timeScale, null !== (e = this._timeScaleInterpolant) && (n *= e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopWarping(), 0 === n ? this.paused = !0 : this.timeScale = n))), this._effectiveTimeScale = n }, hp.prototype._updateTime = function(t) {
        var e, n = this._clip.duration,
            r = this.loop,
            i = this.time + t,
            o = this._loopCount,
            a = 2202 === r;
        if (0 === t) return -1 !== o && a && 1 == (1 & o) ? n - i : i;
        if (2200 === r) {
            -1 === o && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            t: {
                if (n <= i) i = n;
                else {
                    if (!(i < 0)) { this.time = i; break t }
                    i = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 })
            }
        } else if (-1 === o && (0 <= t ? (o = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), n <= i || i < 0 ? (i -= n * (e = Math.floor(i / n)), o += Math.abs(e), (r = this.repetitions - o) <= 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = 0 < t ? n : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < t ? 1 : -1 })) : (1 == r ? (r = t < 0, this._setEndings(r, !r, a)) : this._setEndings(!1, !1, a), this._loopCount = o, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: e }))) : this.time = i, a && 1 == (1 & o)) return n - i;
        return i
    }, hp.prototype._setEndings = function(t, e, n) {
        var r = this._interpolantSettings;
        n ? (r.endingStart = nn, r.endingEnd = nn) : (r.endingStart = t ? this.zeroSlopeAtStart ? nn : en : rn, r.endingEnd = e ? this.zeroSlopeAtEnd ? nn : en : rn)
    }, hp.prototype._scheduleFading = function(t, e, n) {
        var r = this._mixer,
            i = r.time,
            o = this._weightInterpolant;
        null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
        r = o.parameterPositions, o = o.sampleValues;
        return r[0] = i, o[0] = e, r[1] = i + t, o[1] = n, this
    }, pp.prototype = Object.assign(Object.create(Mn.prototype), {
        constructor: pp,
        _bindAction: function(t, e) {
            var n = t._localRoot || this._root,
                r = t._clip.tracks,
                i = r.length,
                o = t._propertyBindings,
                a = t._interpolants,
                s = n.uuid,
                t = this._bindingsByRootAndName,
                c = t[s];
            void 0 === c && (c = {}, t[s] = c);
            for (var l = 0; l !== i; ++l) {
                var u = r[l],
                    h = u.name;
                if (void 0 !== (p = c[h])) o[l] = p;
                else { if (void 0 !== (p = o[l])) { null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, h)); continue } var p, d = e && e._propertyBindings[l].binding.parsedPath;++(p = new Kh(lp.create(n, h, d), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(p, s, h), o[l] = p }
                a[l].resultBuffer = p.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                var e, n, r;
                null === t._cacheIndex && (e = (t._localRoot || this._root).uuid, n = t._clip.uuid, r = this._actionsByClip[n], this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e));
                for (var i = t._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                    var s = i[o];
                    0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                    var i = e[n];
                    0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = { actions: {get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: {get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: {get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } }
        },
        _isActiveAction: function(t) { t = t._cacheIndex; return null !== t && t < this._nActiveActions },
        _addInactiveAction: function(t, e, n) {
            var r = this._actions,
                i = this._actionsByClip,
                o = i[e];
            void 0 === o ? (o = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, i[e] = o) : (e = o.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t
        },
        _removeInactiveAction: function(t) {
            var e = this._actions,
                n = e[e.length - 1],
                r = t._cacheIndex;
            e[n._cacheIndex = r] = n, e.pop(), t._cacheIndex = null;
            var i = t._clip.uuid,
                o = this._actionsByClip,
                a = o[i],
                r = a.knownActions,
                n = r[r.length - 1],
                e = t._byClipCacheIndex;
            r[n._byClipCacheIndex = e] = n, r.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === r.length && delete o[i], this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                var i = e[n];
                0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
        },
        _lendAction: function(t) {
            var e = this._actions,
                n = t._cacheIndex,
                r = this._nActiveActions++,
                i = e[r];
            e[t._cacheIndex = r] = t, e[i._cacheIndex = n] = i
        },
        _takeBackAction: function(t) {
            var e = this._actions,
                n = t._cacheIndex,
                r = --this._nActiveActions,
                i = e[r];
            e[t._cacheIndex = r] = t, e[i._cacheIndex = n] = i
        },
        _addInactiveBinding: function(t, e, n) {
            var r = this._bindingsByRootAndName,
                i = this._bindings,
                o = r[e];
            void 0 === o && (o = {}, r[e] = o), (o[n] = t)._cacheIndex = i.length, i.push(t)
        },
        _removeInactiveBinding: function(t) {
            var e = this._bindings,
                n = t.binding,
                r = n.rootNode.uuid,
                i = n.path,
                o = this._bindingsByRootAndName,
                a = o[r],
                n = e[e.length - 1],
                t = t._cacheIndex;
            e[n._cacheIndex = t] = n, e.pop(), delete a[i], 0 === Object.keys(a).length && delete o[r]
        },
        _lendBinding: function(t) {
            var e = this._bindings,
                n = t._cacheIndex,
                r = this._nActiveBindings++,
                i = e[r];
            e[t._cacheIndex = r] = t, e[i._cacheIndex = n] = i
        },
        _takeBackBinding: function(t) {
            var e = this._bindings,
                n = t._cacheIndex,
                r = --this._nActiveBindings,
                i = e[r];
            e[t._cacheIndex = r] = t, e[i._cacheIndex = n] = i
        },
        _lendControlInterpolant: function() {
            var t = this._controlInterpolants,
                e = this._nActiveControlInterpolants++,
                n = t[e];
            return void 0 === n && (t[(n = new lu(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e] = n), n
        },
        _takeBackControlInterpolant: function(t) {
            var e = this._controlInterpolants,
                n = t.__cacheIndex,
                r = --this._nActiveControlInterpolants,
                i = e[r];
            e[t.__cacheIndex = r] = t, e[i.__cacheIndex = n] = i
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e, n) {
            var r = e || this._root,
                i = r.uuid,
                o = "string" == typeof t ? _u.findByName(r, t) : t,
                a = null !== o ? o.uuid : t,
                s = this._actionsByClip[a],
                r = null;
            if (void 0 === n && (n = null !== o ? o.blendMode : 2500), void 0 !== s) {
                t = s.actionByRoot[i];
                if (void 0 !== t && t.blendMode === n) return t;
                r = s.knownActions[0], null === o && (o = r._clip)
            }
            if (null === o) return null;
            n = new hp(this, o, e, n);
            return this._bindAction(n, r), this._addInactiveAction(n, a, i), n
        },
        existingAction: function(t, e) {
            var n = e || this._root,
                e = n.uuid,
                n = "string" == typeof t ? _u.findByName(n, t) : t,
                t = n ? n.uuid : t,
                t = this._actionsByClip[t];
            return void 0 !== t && t.actionByRoot[e] || null
        },
        stopAllAction: function() { for (var t = this._actions, e = this._nActiveActions - 1; 0 <= e; --e) t[e].stop(); return this },
        update: function(t) { t *= this.timeScale; for (var e = this._actions, n = this._nActiveActions, r = this.time += t, i = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) e[a]._update(r, t, i, o); for (var s = this._bindings, c = this._nActiveBindings, l = 0; l !== c; ++l) s[l].apply(o); return this },
        setTime: function(t) { for (var e = this.time = 0; e < this._actions.length; e++) this._actions[e].time = 0; return this.update(t) },
        getRoot: function() { return this._root },
        uncacheClip: function(t) {
            var e = this._actions,
                n = t.uuid,
                r = this._actionsByClip,
                t = r[n];
            if (void 0 !== t) {
                for (var i = t.knownActions, o = 0, a = i.length; o !== a; ++o) {
                    var s = i[o];
                    this._deactivateAction(s);
                    var c = s._cacheIndex,
                        l = e[e.length - 1];
                    s._cacheIndex = null, s._byClipCacheIndex = null, e[l._cacheIndex = c] = l, e.pop(), this._removeInactiveBindingsForAction(s)
                }
                delete r[n]
            }
        },
        uncacheRoot: function(t) {
            var e, n = t.uuid,
                r = this._actionsByClip;
            for (e in r) {
                var i = r[e].actionByRoot[n];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            var o = this._bindingsByRootAndName[n];
            if (void 0 !== o)
                for (var a in o) {
                    var s = o[a];
                    s.restoreOriginalState(), this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function(t, e) {
            e = this.existingAction(t, e);
            null !== e && (this._deactivateAction(e), this._removeInactiveAction(e))
        }
    });

    function dp(t, e) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t }

    function fp(t, e, n) { Bs.call(this, t, e), this.meshPerAttribute = n || 1 }

    function mp(t, e, n, r, i) { this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0 }

    function gp(t, e, n, r) { this.ray = new fr(t, e), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new Ar, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) }

    function vp(t, e) { return t.distance - e.distance }

    function yp(t, e, n, r) {
        if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r)
            for (var i = t.children, o = 0, a = i.length; o < a; o++) yp(i[o], e, n, !0)
    }
    dp.prototype.clone = function() { return new dp(void 0 === this.value.clone ? this.value : this.value.clone()) }, fp.prototype = Object.assign(Object.create(Bs.prototype), { constructor: fp, isInstancedInterleavedBuffer: !0, copy: function(t) { return Bs.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, clone: function(t) { t = Bs.prototype.clone.call(this, t); return t.meshPerAttribute = this.meshPerAttribute, t }, toJSON: function(t) { t = Bs.prototype.toJSON.call(this, t); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } }), Object.defineProperty(mp.prototype, "needsUpdate", { set: function(t) {!0 === t && this.version++ } }), Object.assign(mp.prototype, { isGLBufferAttribute: !0, setBuffer: function(t) { return this.buffer = t, this }, setType: function(t, e) { return this.type = t, this.elementSize = e, this }, setItemSize: function(t) { return this.itemSize = t, this }, setCount: function(t) { return this.count = t, this } }), Object.assign(gp.prototype, { set: function(t, e) { this.ray.set(t, e) }, setFromCamera: function(t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function(t, e, n) { n = n || []; return yp(t, this, n, e), n.sort(vp), n }, intersectObjects: function(t, e, n) { var r = n || []; if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r; for (var i = 0, o = t.length; i < o; i++) yp(t[i], this, r, e); return r.sort(vp), r } });

    function _p(t, e, n) { return void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), this.radius = t, this.phi = e, this.theta = n, this }
    _p.prototype.set = function(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this }, _p.prototype.clone = function() { return (new this.constructor).copy(this) }, _p.prototype.copy = function(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this }, _p.prototype.makeSafe = function() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, _p.prototype.setFromVector3 = function(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, _p.prototype.setFromCartesianCoords = function(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(An.clamp(e / this.radius, -1, 1))), this };

    function xp(t, e, n) { return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this }
    xp.prototype.set = function(t, e, n) { return this.radius = t, this.theta = e, this.y = n, this }, xp.prototype.clone = function() { return (new this.constructor).copy(this) }, xp.prototype.copy = function(t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }, xp.prototype.setFromVector3 = function(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, xp.prototype.setFromCartesianCoords = function(t, e, n) { return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this };

    function bp(t, e) { Object.defineProperty(this, "isBox2", { value: !0 }), this.min = void 0 !== t ? t : new Ln(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ln(-1 / 0, -1 / 0) }
    var wp = new Ln;
    bp.prototype.set = function(t, e) { return this.min.copy(t), this.max.copy(e), this }, bp.prototype.setFromPoints = function(t) { this.makeEmpty(); for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }, bp.prototype.setFromCenterAndSize = function(t, e) { e = wp.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(e), this.max.copy(t).add(e), this }, bp.prototype.clone = function() { return (new this.constructor).copy(this) }, bp.prototype.copy = function(t) { return this.min.copy(t.min), this.max.copy(t.max), this }, bp.prototype.makeEmpty = function() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, bp.prototype.isEmpty = function() { return this.max.x < this.min.x || this.max.y < this.min.y }, bp.prototype.getCenter = function(t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Ln), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, bp.prototype.getSize = function(t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Ln), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }, bp.prototype.expandByPoint = function(t) { return this.min.min(t), this.max.max(t), this }, bp.prototype.expandByVector = function(t) { return this.min.sub(t), this.max.add(t), this }, bp.prototype.expandByScalar = function(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, bp.prototype.containsPoint = function(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, bp.prototype.containsBox = function(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, bp.prototype.getParameter = function(t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Ln), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, bp.prototype.intersectsBox = function(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, bp.prototype.clampPoint = function(t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Ln), e.copy(t).clamp(this.min, this.max) }, bp.prototype.distanceToPoint = function(t) { return wp.copy(t).clamp(this.min, this.max).sub(t).length() }, bp.prototype.intersect = function(t) { return this.min.max(t.min), this.max.min(t.max), this }, bp.prototype.union = function(t) { return this.min.min(t.min), this.max.max(t.max), this }, bp.prototype.translate = function(t) { return this.min.add(t), this.max.add(t), this }, bp.prototype.equals = function(t) { return t.min.equals(this.min) && t.max.equals(this.max) };

    function Mp(t, e) { this.start = void 0 !== t ? t : new kn, this.end = void 0 !== e ? e : new kn }
    var Sp = new kn,
        Ep = new kn;

    function Tp(t) { kr.call(this), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 }
    Mp.prototype.set = function(t, e) { return this.start.copy(t), this.end.copy(e), this }, Mp.prototype.clone = function() { return (new this.constructor).copy(this) }, Mp.prototype.copy = function(t) { return this.start.copy(t.start), this.end.copy(t.end), this }, Mp.prototype.getCenter = function(t) { return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new kn), t.addVectors(this.start, this.end).multiplyScalar(.5) }, Mp.prototype.delta = function(t) { return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new kn), t.subVectors(this.end, this.start) }, Mp.prototype.distanceSq = function() { return this.start.distanceToSquared(this.end) }, Mp.prototype.distance = function() { return this.start.distanceTo(this.end) }, Mp.prototype.at = function(t, e) { return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new kn), this.delta(e).multiplyScalar(t).add(this.start) }, Mp.prototype.closestPointToPointParameter = function(t, e) {
        Sp.subVectors(t, this.start), Ep.subVectors(this.end, this.start);
        t = Ep.dot(Ep), t = Ep.dot(Sp) / t;
        return e && (t = An.clamp(t, 0, 1)), t
    }, Mp.prototype.closestPointToPoint = function(t, e, n) { e = this.closestPointToPointParameter(t, e); return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new kn), this.delta(n).multiplyScalar(e).add(this.start) }, Mp.prototype.applyMatrix4 = function(t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, Mp.prototype.equals = function(t) { return t.start.equals(this.start) && t.end.equals(this.end) }, ((Tp.prototype = Object.create(kr.prototype)).constructor = Tp).prototype.isImmediateRenderObject = !0;
    var Ap = new kn,
        Lp = function(s) {
            function t(t, e) {
                s.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var t = new Ni, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, i = 1; r < 32; r++, i++) {
                    var o = r / 32 * Math.PI * 2,
                        a = i / 32 * Math.PI * 2;
                    n.push(Math.cos(o), Math.sin(o), 1, Math.cos(a), Math.sin(a), 1)
                }
                t.setAttribute("position", new Si(n, 3));
                e = new _c({ fog: !1, toneMapped: !1 });
                this.cone = new Lc(t, e), this.add(this.cone), this.update()
            }
            return s && (t.__proto__ = s), ((t.prototype = Object.create(s && s.prototype)).constructor = t).prototype.dispose = function() { this.cone.geometry.dispose(), this.cone.material.dispose() }, t.prototype.update = function() {
                this.light.updateMatrixWorld();
                var t = this.light.distance || 1e3,
                    e = t * Math.tan(this.light.angle);
                this.cone.scale.set(e, e, t), Ap.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ap), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }, t
        }(kr),
        Rp = new kn,
        Cp = new mr,
        Pp = new mr,
        Op = function(u) {
            function t(t) {
                for (var e = function t(e) {
                        var n = [];
                        e && e.isBone && n.push(e);
                        for (var r = 0; r < e.children.length; r++) n.push.apply(n, t(e.children[r]));
                        return n
                    }(t), n = new Ni, r = [], i = [], o = new li(0, 0, 1), a = new li(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
                }
                n.setAttribute("position", new Si(r, 3)), n.setAttribute("color", new Si(i, 3));
                var l = new _c({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
                u.call(this, n, l), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }
            return u && (t.__proto__ = u), ((t.prototype = Object.create(u && u.prototype)).constructor = t).prototype.updateMatrixWorld = function(t) {
                var e = this.bones,
                    n = this.geometry,
                    r = n.getAttribute("position");
                Pp.getInverse(this.root.matrixWorld);
                for (var i = 0, o = 0; i < e.length; i++) {
                    var a = e[i];
                    a.parent && a.parent.isBone && (Cp.multiplyMatrices(Pp, a.matrixWorld), Rp.setFromMatrixPosition(Cp), r.setXYZ(o, Rp.x, Rp.y, Rp.z), Cp.multiplyMatrices(Pp, a.parent.matrixWorld), Rp.setFromMatrixPosition(Cp), r.setXYZ(o + 1, Rp.x, Rp.y, Rp.z), o += 2)
                }
                n.getAttribute("position").needsUpdate = !0, u.prototype.updateMatrixWorld.call(this, t)
            }, t
        }(Lc);
    var Ip = function(i) {
            function t(t, e, n) {
                var r = new Il(e, 4, 2),
                    e = new di({ wireframe: !0, fog: !1, toneMapped: !1 });
                i.call(this, r, e), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }
            return i && (t.__proto__ = i), ((t.prototype = Object.create(i && i.prototype)).constructor = t).prototype.dispose = function() { this.geometry.dispose(), this.material.dispose() }, t.prototype.update = function() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }, t
        }($i),
        Dp = new kn,
        Np = new li,
        Bp = new li,
        Rn = function(r) {
            function t(t, e, n) {
                r.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                n = new Zc(e);
                n.rotateY(.5 * Math.PI), this.material = new di({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0);
                e = n.getAttribute("position"), e = new Float32Array(3 * e.count);
                n.setAttribute("color", new gi(e, 3)), this.add(new $i(n, this.material)), this.update()
            }
            return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.dispose = function() { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, t.prototype.update = function() {
                var t = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var e = t.geometry.getAttribute("color");
                    Np.copy(this.light.color), Bp.copy(this.light.groundColor);
                    for (var n = 0, r = e.count; n < r; n++) {
                        var i = n < r / 2 ? Np : Bp;
                        e.setXYZ(n, i.r, i.g, i.b)
                    }
                    e.needsUpdate = !0
                }
                t.lookAt(Dp.setFromMatrixPosition(this.light.matrixWorld).negate())
            }, t
        }(kr),
        Bn = function(f) {
            function t(t, e, n, r) {
                t = t || 10, e = e || 10, n = new li(void 0 !== n ? n : 4473924), r = new li(void 0 !== r ? r : 8947848);
                for (var i = e / 2, o = t / e, a = t / 2, s = [], c = [], l = 0, u = 0, h = -a; l <= e; l++, h += o) {
                    s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                    var p = l === i ? n : r;
                    p.toArray(c, u), u += 3, p.toArray(c, u), u += 3, p.toArray(c, u), u += 3, p.toArray(c, u), u += 3
                }
                var d = new Ni;
                d.setAttribute("position", new Si(s, 3)), d.setAttribute("color", new Si(c, 3));
                t = new _c({ vertexColors: !0, toneMapped: !1 });
                f.call(this, d, t), this.type = "GridHelper"
            }
            return f && (t.__proto__ = f), (t.prototype = Object.create(f && f.prototype)).constructor = t
        }(Lc),
        Hn = function(x) {
            function t(t, e, n, r, i, o) {
                t = t || 10, e = e || 16, n = n || 8, r = r || 64, i = new li(void 0 !== i ? i : 4473924), o = new li(void 0 !== o ? o : 8947848);
                for (var a = [], s = [], c = 0; c <= e; c++) {
                    var l = c / e * (2 * Math.PI),
                        u = Math.sin(l) * t,
                        l = Math.cos(l) * t;
                    a.push(0, 0, 0), a.push(u, 0, l);
                    l = 1 & c ? i : o;
                    s.push(l.r, l.g, l.b), s.push(l.r, l.g, l.b)
                }
                for (var h = 0; h <= n; h++)
                    for (var p = 1 & h ? i : o, d = t - t / n * h, f = 0; f < r; f++) {
                        var m = f / r * (2 * Math.PI),
                            g = Math.sin(m) * d,
                            v = Math.cos(m) * d;
                        a.push(g, 0, v), s.push(p.r, p.g, p.b), m = (f + 1) / r * (2 * Math.PI), g = Math.sin(m) * d, v = Math.cos(m) * d, a.push(g, 0, v), s.push(p.r, p.g, p.b)
                    }
                var y = new Ni;
                y.setAttribute("position", new Si(a, 3)), y.setAttribute("color", new Si(s, 3));
                var _ = new _c({ vertexColors: !0, toneMapped: !1 });
                x.call(this, y, _), this.type = "PolarGridHelper"
            }
            return x && (t.__proto__ = x), (t.prototype = Object.create(x && x.prototype)).constructor = t
        }(Lc),
        Fp = new kn,
        Up = new kn,
        zp = new kn,
        Sr = function(r) {
            function t(t, e, n) {
                r.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                n = new Ni;
                n.setAttribute("position", new Si([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                e = new _c({ fog: !1, toneMapped: !1 });
                this.lightPlane = new Ec(n, e), this.add(this.lightPlane), (n = new Ni).setAttribute("position", new Si([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ec(n, e), this.add(this.targetLine), this.update()
            }
            return r && (t.__proto__ = r), ((t.prototype = Object.create(r && r.prototype)).constructor = t).prototype.dispose = function() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, t.prototype.update = function() { Fp.setFromMatrixPosition(this.light.matrixWorld), Up.setFromMatrixPosition(this.light.target.matrixWorld), zp.subVectors(Up, Fp), this.lightPlane.lookAt(Up), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Up), this.targetLine.scale.z = zp.length() }, t
        }(kr),
        Hp = new kn,
        kp = new go,
        Qh = function(d) {
            function t(t) {
                var e = new Ni,
                    n = new _c({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
                    r = [],
                    i = [],
                    o = {},
                    a = new li(16755200),
                    s = new li(16711680),
                    c = new li(43775),
                    l = new li(16777215),
                    u = new li(3355443);

                function h(t, e, n) { p(t, n), p(e, n) }

                function p(t, e) { r.push(0, 0, 0), i.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(r.length / 3 - 1) }
                h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", l), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), e.setAttribute("position", new Si(r, 3)), e.setAttribute("color", new Si(i, 3)), d.call(this, e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }
            return d && (t.__proto__ = d), ((t.prototype = Object.create(d && d.prototype)).constructor = t).prototype.update = function() {
                var t = this.geometry,
                    e = this.pointMap;
                kp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Gp("c", e, t, kp, 0, 0, -1), Gp("t", e, t, kp, 0, 0, 1), Gp("n1", e, t, kp, -1, -1, -1), Gp("n2", e, t, kp, 1, -1, -1), Gp("n3", e, t, kp, -1, 1, -1), Gp("n4", e, t, kp, 1, 1, -1), Gp("f1", e, t, kp, -1, -1, 1), Gp("f2", e, t, kp, 1, -1, 1), Gp("f3", e, t, kp, -1, 1, 1), Gp("f4", e, t, kp, 1, 1, 1), Gp("u1", e, t, kp, .7, 1.1, -1), Gp("u2", e, t, kp, -.7, 1.1, -1), Gp("u3", e, t, kp, 0, 2, -1), Gp("cf1", e, t, kp, -1, 0, 1), Gp("cf2", e, t, kp, 1, 0, 1), Gp("cf3", e, t, kp, 0, -1, 1), Gp("cf4", e, t, kp, 0, 1, 1), Gp("cn1", e, t, kp, -1, 0, -1), Gp("cn2", e, t, kp, 1, 0, -1), Gp("cn3", e, t, kp, 0, -1, -1), Gp("cn4", e, t, kp, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
            }, t
        }(Lc);

    function Gp(t, e, n, r, i, o, a) {
        Hp.set(i, o, a).unproject(r);
        var s = e[t];
        if (void 0 !== s)
            for (var c = n.getAttribute("position"), l = 0, u = s.length; l < u; l++) c.setXYZ(s[l], Hp.x, Hp.y, Hp.z)
    }
    var Vp, jp, Wp = new jn,
        qp = function(o) {
            function t(t, e) {
                void 0 === e && (e = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new Ni;
                i.setIndex(new gi(n, 1)), i.setAttribute("position", new gi(r, 3)), o.call(this, i, new _c({ color: e, toneMapped: !1 })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
            }
            return o && (t.__proto__ = o), ((t.prototype = Object.create(o && o.prototype)).constructor = t).prototype.update = function(t) {
                var e, n, r;
                void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Wp.setFromObject(this.object), Wp.isEmpty() || (e = Wp.min, n = Wp.max, (t = (r = this.geometry.attributes.position).array)[0] = n.x, t[1] = n.y, t[2] = n.z, t[3] = e.x, t[4] = n.y, t[5] = n.z, t[6] = e.x, t[7] = e.y, t[8] = n.z, t[9] = n.x, t[10] = e.y, t[11] = n.z, t[12] = n.x, t[13] = n.y, t[14] = e.z, t[15] = e.x, t[16] = n.y, t[17] = e.z, t[18] = e.x, t[19] = e.y, t[20] = e.z, t[21] = n.x, t[22] = e.y, t[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere())
            }, t.prototype.setFromObject = function(t) { return this.object = t, this.update(), this }, t.prototype.copy = function(t) { return o.prototype.copy.call(this, t), this.object = t.object, this }, t
        }(Lc),
        ep = function(i) {
            function t(t, e) {
                void 0 === e && (e = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Ni;
                r.setIndex(new gi(n, 1)), r.setAttribute("position", new Si([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), i.call(this, r, new _c({ color: e, toneMapped: !1 })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
            }
            return i && (t.__proto__ = i), ((t.prototype = Object.create(i && i.prototype)).constructor = t).prototype.updateMatrixWorld = function(t) {
                var e = this.box;
                e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), i.prototype.updateMatrixWorld.call(this, t))
            }, t
        }(Lc),
        tp = function(i) {
            function t(t, e, n) {
                var r = void 0 !== n ? n : 16776960,
                    n = new Ni;
                n.setAttribute("position", new Si([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), n.computeBoundingSphere(), i.call(this, n, new _c({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                e = new Ni;
                e.setAttribute("position", new Si([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), e.computeBoundingSphere(), this.add(new $i(e, new di({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 })))
            }
            return i && (t.__proto__ = i), ((t.prototype = Object.create(i && i.prototype)).constructor = t).prototype.updateMatrixWorld = function(t) {
                var e = -this.plane.constant;
                Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? j : X, this.lookAt(this.plane.normal), i.prototype.updateMatrixWorld.call(this, t)
            }, t
        }(Ec),
        Xp = new kn,
        np = function(a) {
            function t(t, e, n, r, i, o) { a.call(this), this.type = "ArrowHelper", void 0 === t && (t = new kn(0, 0, 1)), void 0 === e && (e = new kn(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === Vp && ((Vp = new Ni).setAttribute("position", new Si([0, 0, 0, 0, 1, 0], 3)), (jp = new Vl(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Ec(Vp, new _c({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new $i(jp, new di({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, i, o) }
            return a && (t.__proto__ = a), ((t.prototype = Object.create(a && a.prototype)).constructor = t).prototype.setDirection = function(t) { .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Xp.set(t.z, 0, -t.x).normalize(), t = Math.acos(t.y), this.quaternion.setFromAxisAngle(Xp, t)) }, t.prototype.setLength = function(t, e, n) { void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix() }, t.prototype.setColor = function(t) { this.line.material.color.set(t), this.cone.material.color.set(t) }, t.prototype.copy = function(t) { return a.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }, t
        }(kr),
        Yp = function(n) {
            function t(t) {
                void 0 === t && (t = 1);
                var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    t = new Ni;
                t.setAttribute("position", new Si(e, 3)), t.setAttribute("color", new Si([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                e = new _c({ vertexColors: !0, toneMapped: !1 });
                n.call(this, t, e), this.type = "AxesHelper"
            }
            return n && (t.__proto__ = n), (t.prototype = Object.create(n && n.prototype)).constructor = t
        }(Lc),
        Zp = Math.pow(2, 8),
        Jp = [.125, .215, .35, .446, .526, .582],
        Kp = 5 + Jp.length,
        Qp = {};
    Qp[an] = 0, Qp[sn] = 1, Qp[ln] = 2, Qp[hn] = 3, Qp[pn] = 4, Qp[dn] = 5, Qp[cn] = 6;
    var $p = new lh,
        rp = function() {
            for (var t = [], e = [], n = [], r = 8, i = 0; i < Kp; i++) {
                var o = Math.pow(2, r);
                e.push(o);
                var a = 1 / o;
                4 < i ? a = Jp[i - 8 + 4 - 1] : 0 == i && (a = 0), n.push(a);
                for (var a = 1 / (o - 1), o = -a / 2, a = 1 + a / 2, s = [o, o, a, o, a, a, o, o, a, a, o, a], c = new Float32Array(108), l = new Float32Array(72), u = new Float32Array(36), h = 0; h < 6; h++) {
                    var p = h % 3 * 2 / 3 - 1,
                        d = 2 < h ? 0 : -1,
                        d = [p, d, 0, p + 2 / 3, d, 0, p + 2 / 3, 1 + d, 0, p, d, 0, p + 2 / 3, 1 + d, 0, p, 1 + d, 0];
                    c.set(d, 18 * h), l.set(s, 12 * h);
                    d = [h, h, h, h, h, h];
                    u.set(d, 6 * h)
                }
                a = new Ni;
                a.setAttribute("position", new gi(c, 3)), a.setAttribute("uv", new gi(l, 2)), a.setAttribute("faceIndex", new gi(u, 1)), t.push(a), 4 < r && r--
            }
            return { _lodPlanes: t, _sizeLods: e, _sigmas: n }
        }(),
        td = rp._lodPlanes,
        ed = rp._sizeLods,
        nd = rp._sigmas,
        rd = null,
        ip = (1 + Math.sqrt(5)) / 2,
        op = 1 / ip,
        id = [new kn(1, 1, 1), new kn(-1, 1, 1), new kn(1, 1, -1), new kn(-1, 1, -1), new kn(0, ip, op), new kn(0, ip, -op), new kn(op, 0, ip), new kn(-op, 0, ip), new kn(ip, op, 0), new kn(-ip, op, 0)],
        rp = function(t) {
            var e, n;
            this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = (e = 20, n = new Float32Array(e), t = new kn(0, 1, 0), new Jl({ name: "SphericalGaussianBlur", defines: { n: e }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: t }, inputEncoding: { value: Qp[an] }, outputEncoding: { value: Qp[an] } }, vertexShader: ld(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t" + ud() + "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: W, depthTest: !1, depthWrite: !1 })), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
        };

    function od(t) { t = new Fn(3 * Zp, 3 * Zp, t); return t.texture.mapping = Ct, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t }

    function ad(t, e, n, r, i) { t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i) }

    function sd() { return new Jl({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: new Ln(1, 1) }, inputEncoding: { value: Qp[an] }, outputEncoding: { value: Qp[an] } }, vertexShader: ld(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t" + ud() + "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: W, depthTest: !1, depthWrite: !1 }) }

    function cd() { return new Jl({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Qp[an] }, outputEncoding: { value: Qp[an] } }, vertexShader: ld(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t" + ud() + "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: W, depthTest: !1, depthWrite: !1 }) }

    function ld() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" }

    function ud() { return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t" }
    rp.prototype.fromScene = function(t, e, n, r) { void 0 === e && (e = 0), void 0 === n && (n = .1), void 0 === r && (r = 100), rd = this._renderer.getRenderTarget(); var i = this._allocateTargets(); return this._sceneToCubeUV(t, n, r, i), 0 < e && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i }, rp.prototype.fromEquirectangular = function(t) { return this._fromTexture(t) }, rp.prototype.fromCubemap = function(t) { return this._fromTexture(t) }, rp.prototype.compileCubemapShader = function() { null === this._cubemapShader && (this._cubemapShader = cd(), this._compileMaterial(this._cubemapShader)) }, rp.prototype.compileEquirectangularShader = function() { null === this._equirectShader && (this._equirectShader = sd(), this._compileMaterial(this._equirectShader)) }, rp.prototype.dispose = function() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (var t = 0; t < td.length; t++) td[t].dispose() }, rp.prototype._cleanup = function(t) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(rd), t.scissorTest = !1, ad(t, 0, 0, t.width, t.height) }, rp.prototype._fromTexture = function(t) { rd = this._renderer.getRenderTarget(); var e = this._allocateTargets(t); return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e }, rp.prototype._allocateTargets = function(t) {
        var e = { magFilter: Nt, minFilter: Nt, generateMipmaps: !1, type: kt, format: ie, encoding: void 0 === (n = t) || n.type !== kt || n.encoding !== an && n.encoding !== sn && n.encoding !== cn ? ln : t.encoding, depthBuffer: !1 },
            n = od(e);
        return n.depthBuffer = !t, this._pingPongRenderTarget = od(e), n
    }, rp.prototype._compileMaterial = function(t) {
        t = new $i(td[0], t);
        this._renderer.compile(t, $p)
    }, rp.prototype._sceneToCubeUV = function(t, e, n, r) {
        var i = new vo(90, 1, e, n),
            o = [1, -1, 1, 1, 1, 1],
            a = [1, 1, 1, -1, -1, -1],
            s = this._renderer,
            c = s.outputEncoding,
            l = s.toneMapping,
            u = s.getClearColor(),
            h = s.getClearAlpha();
        s.toneMapping = Et, s.outputEncoding = an;
        e = t.background;
        e && e.isColor && (e.convertSRGBToLinear(), n = Math.max(e.r, e.g, e.b), n = Math.min(Math.max(Math.ceil(Math.log2(n)), -128), 127), e = e.multiplyScalar(Math.pow(2, -n)), n = (n + 128) / 255, s.setClearColor(e, n), t.background = null);
        for (var p = 0; p < 6; p++) {
            var d = p % 3;
            0 == d ? (i.up.set(0, o[p], 0), i.lookAt(a[p], 0, 0)) : 1 == d ? (i.up.set(0, 0, o[p]), i.lookAt(0, a[p], 0)) : (i.up.set(0, o[p], 0), i.lookAt(0, 0, a[p])), ad(r, d * Zp, 2 < p ? Zp : 0, Zp, Zp), s.setRenderTarget(r), s.render(t, i)
        }
        s.toneMapping = l, s.outputEncoding = c, s.setClearColor(u, h)
    }, rp.prototype._textureToCubeUV = function(t, e) {
        var n = this._renderer;
        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = cd()) : null == this._equirectShader && (this._equirectShader = sd());
        var r = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
            i = new $i(td[0], r),
            r = r.uniforms;
        (r.envMap.value = t).isCubeTexture || r.texelSize.value.set(1 / t.image.width, 1 / t.image.height), r.inputEncoding.value = Qp[t.encoding], r.outputEncoding.value = Qp[e.texture.encoding], ad(e, 0, 0, 3 * Zp, 2 * Zp), n.setRenderTarget(e), n.render(i, $p)
    }, rp.prototype._applyPMREM = function(t) {
        var e = this._renderer,
            n = e.autoClear;
        e.autoClear = !1;
        for (var r = 1; r < Kp; r++) {
            var i = Math.sqrt(nd[r] * nd[r] - nd[r - 1] * nd[r - 1]),
                o = id[(r - 1) % id.length];
            this._blur(t, r - 1, r, i, o)
        }
        e.autoClear = n
    }, rp.prototype._blur = function(t, e, n, r, i) {
        var o = this._pingPongRenderTarget;
        this._halfBlur(t, o, e, n, r, "latitudinal", i), this._halfBlur(o, t, n, n, r, "longitudinal", i)
    }, rp.prototype._halfBlur = function(t, e, n, r, i, o, a) {
        var s = this._renderer,
            c = this._blurMaterial;
        "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
        var l = new $i(td[r], c),
            u = c.uniforms,
            c = ed[n] - 1,
            c = isFinite(i) ? Math.PI / (2 * c) : 2 * Math.PI / 39,
            h = i / c,
            p = isFinite(i) ? 1 + Math.floor(3 * h) : 20;
        20 < p && console.warn("sigmaRadians, " + i + ", is too large and will clip, as it requested " + p + " samples when the maximum is set to 20");
        for (var d = [], f = 0, m = 0; m < 20; ++m) {
            var g = m / h,
                g = Math.exp(-g * g / 2);
            d.push(g), 0 == m ? f += g : m < p && (f += 2 * g)
        }
        for (var v = 0; v < d.length; v++) d[v] = d[v] / f;
        u.envMap.value = t.texture, u.samples.value = p, u.weights.value = d, u.latitudinal.value = "latitudinal" === o, a && (u.poleAxis.value = a), u.dTheta.value = c, u.mipInt.value = 8 - n, u.inputEncoding.value = Qp[t.texture.encoding], u.outputEncoding.value = Qp[t.texture.encoding];
        t = ed[r];
        ad(e, 3 * Math.max(0, Zp - 2 * t), (0 === r ? 0 : 2 * Zp) + 2 * t * (4 < r ? r - 8 + 4 : 0), 3 * t, 2 * t), s.setRenderTarget(e), s.render(l, $p)
    };

    function hd(t) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ku.call(this, t), this.type = "catmullrom", this.closed = !0 }

    function pd(t) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ku.call(this, t), this.type = "catmullrom" }

    function dd(t) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), ku.call(this, t), this.type = "catmullrom" }
    Iu.create = function(t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Iu.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t }, Object.assign($u.prototype, {
        createPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            t = this.getPoints(t);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            t = this.getSpacedPoints(t);
            return this.createGeometry(t)
        },
        createGeometry: function(t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var e = new ao, n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.vertices.push(new kn(i.x, i.y, i.z || 0))
            }
            return e
        }
    }), Object.assign(th.prototype, { fromPoints: function(t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) } }), hd.prototype = Object.create(ku.prototype), pd.prototype = Object.create(ku.prototype), dd.prototype = Object.create(ku.prototype), Object.assign(dd.prototype, { initFromArray: function() { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function() { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function() { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), Bn.prototype.setColors = function() { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, Op.prototype.update = function() { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(Su.prototype, { extractUrlBase: function(t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), vh.extractUrlBase(t) } }), Su.Handlers = { add: function() { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function() { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Object.assign(wh.prototype, { setTexturePath: function(t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) } }), Object.assign(bp.prototype, { center: function(t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function() { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, size: function(t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(jn.prototype, { center: function(t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function() { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function(t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, size: function(t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(ar.prototype, { empty: function() { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() } }), Mo.prototype.setFromMatrix = function(t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, Mp.prototype.center = function(t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Object.assign(An, { random16: function() { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function(t) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), An.floorPowerOfTwo(t) }, nextPowerOfTwo: function(t) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), An.ceilPowerOfTwo(t) } }), Object.assign(Pn.prototype, { flattenToArrayOffset: function(t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, multiplyVector3: function(t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBufferAttribute: function(t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, applyToVector3Array: function() { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(mr.prototype, { extractPosition: function(t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, flattenToArrayOffset: function(t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, getPosition: function() { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new kn).setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function(t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyToArray: function() { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function(t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector4: function(t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function(t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function(t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function() { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function() { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function() { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function() { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function() { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBufferAttribute: function(t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, applyToVector3Array: function() { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function(t, e, n, r, i, o) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, o) } }), Wr.prototype.isIntersectionLine = function(t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, zn.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, Object.assign(fr.prototype, { isIntersectionBox: function(t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function(t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function(t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(ni.prototype, { area: function() { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function(t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, midpoint: function(t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, normal: function(t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, plane: function(t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) } }), Object.assign(ni, { barycoordFromPoint: function(t, e, n, r, i) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ni.getBarycoord(t, e, n, r, i) }, normal: function(t, e, n, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ni.getNormal(t, e, n, r) } }), Object.assign(eh.prototype, { extractAllPoints: function(t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, extrude: function(t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Tl(this, t) }, makeGeometry: function(t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ul(this, t) } }), Object.assign(Ln.prototype, { fromAttribute: function(t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function(t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function() { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(kn.prototype, { setEulerFromRotationMatrix: function() { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function() { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function(t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function(t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function(t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, applyProjection: function(t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, fromAttribute: function(t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function(t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function() { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Nn.prototype, { fromAttribute: function(t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, lengthManhattan: function() { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(ao.prototype, { computeTangents: function() { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function() { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") }, applyMatrix: function(t) { return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.assign(kr.prototype, { getChildByName: function(t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function() { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function(t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, getWorldRotation: function() { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, applyMatrix: function(t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(kr.prototype, { eulerOrder: { get: function() { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function(t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.assign($i.prototype, { setDrawMode: function() { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } }), Object.defineProperties($i.prototype, { drawMode: { get: function() { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function() { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Object.defineProperties(cc.prototype, { objects: { get: function() { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(pc.prototype, "useVertexTexture", { get: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), lc.prototype.initBones = function() { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Iu.prototype, "__arcLengthDivisions", { get: function() { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function(t) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t } }), vo.prototype.setLens = function(t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(nh.prototype, { onlyShadow: { set: function() { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function(t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function(t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function(t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function(t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function(t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function(t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function(t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function() { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function(t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function() { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function(t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function(t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(gi.prototype, { length: { get: function() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function() { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === bn }, set: function() { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(bn) } } }), Object.assign(gi.prototype, { setDynamic: function(t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? bn : xn), this }, copyIndicesArray: function() { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, setArray: function() { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Ni.prototype, { addIndex: function(t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addAttribute: function(t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new gi(e, arguments[2]))) }, addDrawCall: function(t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function() { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function() { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function() { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, removeAttribute: function(t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, applyMatrix: function(t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(Ni.prototype, { drawcalls: { get: function() { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function() { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(yh.prototype, { maxInstancedCount: { get: function() { return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount }, set: function(t) { console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t } } }), Object.defineProperties(gp.prototype, { linePrecision: { get: function() { return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold }, set: function(t) { console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t } } }), Object.defineProperties(Bs.prototype, { dynamic: { get: function() { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === bn }, set: function(t) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t) } } }), Object.assign(Bs.prototype, { setDynamic: function(t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? bn : xn), this }, setArray: function() { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Al.prototype, { getArrays: function() { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function() { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function() { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.assign(Ns.prototype, { dispose: function() { console.error("THREE.Scene: .dispose() has been removed.") } }), Object.defineProperties(dp.prototype, { dynamic: { set: function() { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function() { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(pi.prototype, { wrapAround: { get: function() { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function() { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function() { console.warn("THREE.Material: .overdraw has been removed.") }, set: function() { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function() { return console.warn("THREE.Material: .wrapRGB has been removed."), new li } }, shading: { get: function() { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function(t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } }, stencilMask: { get: function() { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function(t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties($l.prototype, { metal: { get: function() { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function() { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(Ql.prototype, { transparency: { get: function() { return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission }, set: function(t) { console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t } } }), Object.defineProperties(mo.prototype, { derivatives: { get: function() { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function(t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), Object.assign(Ps.prototype, { clearTarget: function(t, e, n, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r) }, animate: function(t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, getCurrentRenderTarget: function() { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function() { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function() { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function() { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function() { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function() { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function() { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function(t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function() { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function() { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function() { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function() { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function() { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function() { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function() { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function() { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function() { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, getActiveMipMapLevel: function() { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() } }), Object.defineProperties(Ps.prototype, { shadowMapEnabled: { get: function() { return this.shadowMap.enabled }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function() { return this.shadowMap.type }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function() { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function() { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function() { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function(t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? sn : an } }, toneMappingWhitePoint: { get: function() { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function() { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(ws.prototype, { cullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Fn.prototype, { wrapS: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function() { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function() { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function() { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function() { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function() { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function() { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.defineProperties(Wh.prototype, { load: { value: function(t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var e = this; return (new Oh).load(t, function(t) { e.setBuffer(t) }), this } }, startTime: { set: function() { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), zh.prototype.getData = function() { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, yo.prototype.updateCubeMap = function(t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) };
    ip = {
        merge: function(t, e, n) {
            var r;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), r = e.matrix, e = e.geometry), t.merge(e, r, n)
        },
        center: function(t) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center() }
    };
    On.crossOrigin = void 0, On.loadTexture = function(t, e, n, r) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var i = new Ou;
        i.setCrossOrigin(this.crossOrigin);
        r = i.load(t, n, void 0, r);
        return e && (r.mapping = e), r
    }, On.loadTextureCube = function(t, e, n, r) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var i = new Cu;
        i.setCrossOrigin(this.crossOrigin);
        r = i.load(t, n, void 0, r);
        return e && (r.mapping = e), r
    }, On.loadCompressedTexture = function() { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, On.loadCompressedTextureCube = function() { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") };
    op = { createMultiMaterialObject: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } };
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "120" } }));
    var Cl = Object.freeze({ __proto__: null, ACESFilmicToneMapping: Mt, AddEquation: $, AddOperation: F, AdditiveAnimationBlendMode: 2501, AdditiveBlending: Z, AlphaFormat: $t, AlwaysDepth: gt, AlwaysStencilFunc: _n, AmbientLight: ph, AmbientLightProbe: Dh, AnimationClip: _u, AnimationLoader: Au, AnimationMixer: pp, AnimationObjectGroup: up, AnimationUtils: au, ArcCurve: Nu, ArrayCamera: Ts, ArrowHelper: np, Audio: Wh, AudioAnalyser: zh, AudioContext: Ph, AudioListener: jh, AudioLoader: Oh, AxesHelper: Yp, AxisHelper: function(t) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Yp(t) }, BackSide: j, BasicDepthPacking: fn, BasicShadowMap: 0, BinaryTextureLoader: function(t) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Pu(t) }, Bone: dc, BooleanKeyframeTrack: pu, BoundingBoxHelper: function(t, e) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new qp(t, e) }, Box2: bp, Box3: jn, Box3Helper: ep, BoxBufferGeometry: co, BoxGeometry: so, BoxHelper: qp, BufferAttribute: gi, BufferGeometry: Ni, BufferGeometryLoader: xh, ByteType: Gt, Cache: bu, Camera: go, CameraHelper: Qh, CanvasRenderer: function() { console.error("THREE.CanvasRenderer has been removed") }, CanvasTexture: zc, CatmullRomCurve3: ku, CineonToneMapping: H, CircleBufferGeometry: Xl, CircleGeometry: ql, ClampToEdgeWrapping: It, Clock: Uh, ClosedSplineCurve3: hd, Color: li, ColorKeyframeTrack: du, CompressedTexture: Uc, CompressedTextureLoader: Lu, ConeBufferGeometry: Wl, ConeGeometry: jl, CubeCamera: yo, CubeGeometry: so, CubeReflectionMapping: Tt, CubeRefractionMapping: At, CubeTexture: Wo, CubeTextureLoader: Cu, CubeUVReflectionMapping: Ct, CubeUVRefractionMapping: Pt, CubicBezierCurve: Wu, CubicBezierCurve3: qu, CubicInterpolant: cu, CullFaceBack: G, CullFaceFront: V, CullFaceFrontBack: 3, CullFaceNone: k, Curve: Iu, CurvePath: $u, CustomBlending: Q, CustomToneMapping: St, CylinderBufferGeometry: Vl, CylinderGeometry: Gl, Cylindrical: xp, DataTexture: xo, DataTexture2DArray: qo, DataTexture3D: Xo, DataTextureLoader: Pu, DecrementStencilOp: 7683, DecrementWrapStencilOp: 34056, DefaultLoadingManager: Mu, DepthFormat: oe, DepthStencilFormat: ae, DepthTexture: Hc, DirectionalLight: hh, DirectionalLightHelper: Sr, DiscreteInterpolant: uu, DodecahedronBufferGeometry: $c, DodecahedronGeometry: Qc, DoubleSide: Y, DstAlphaFactor: ut, DstColorFactor: pt, DynamicBufferAttribute: function(t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new gi(t, e).setUsage(bn) }, DynamicCopyUsage: 35050, DynamicDrawUsage: bn, DynamicReadUsage: 35049, EdgesGeometry: kl, EdgesHelper: function(t, e) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Lc(new kl(t.geometry), new _c({ color: void 0 !== e ? e : 16777215 })) }, EllipseCurve: Du, EqualDepth: _t, EqualStencilFunc: 514, EquirectangularReflectionMapping: Lt, EquirectangularRefractionMapping: Rt, Euler: Mr, EventDispatcher: Mn, ExtrudeBufferGeometry: Al, ExtrudeGeometry: Tl, Face3: ui, Face4: function(t, e, n, r, i, o, a) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ui(t, e, n, i, o, a) }, FaceColors: 1, FileLoader: Tu, FlatShading: 1, Float32Attribute: function(t, e) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Si(t, e) }, Float32BufferAttribute: Si, Float64Attribute: function(t, e) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Ei(t, e) }, Float64BufferAttribute: Ei, FloatType: Xt, Fog: Ds, FogExp2: Is, Font: Rh, FontLoader: Ch, FrontSide: X, Frustum: Mo, GLBufferAttribute: mp, GLSL1: "100", GLSL3: wn, GammaEncoding: cn, Geometry: ao, GeometryUtils: ip, GreaterDepth: bt, GreaterEqualDepth: xt, GreaterEqualStencilFunc: 518, GreaterStencilFunc: 516, GridHelper: Bn, Group: As, HalfFloatType: Yt, HemisphereLight: rh, HemisphereLightHelper: Rn, HemisphereLightProbe: Ih, IcosahedronBufferGeometry: Kc, IcosahedronGeometry: Jc, ImageBitmapLoader: Ah, ImageLoader: Ru, ImageUtils: On, ImmediateRenderObject: Tp, IncrementStencilOp: 7682, IncrementWrapStencilOp: 34055, InstancedBufferAttribute: _h, InstancedBufferGeometry: yh, InstancedInterleavedBuffer: fp, InstancedMesh: yc, Int16Attribute: function(t, e) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new xi(t, e) }, Int16BufferAttribute: xi, Int32Attribute: function(t, e) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new wi(t, e) }, Int32BufferAttribute: wi, Int8Attribute: function(t, e) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new vi(t, e) }, Int8BufferAttribute: vi, IntType: Wt, InterleavedBuffer: Bs, InterleavedBufferAttribute: zs, Interpolant: su, InterpolateDiscrete: $e, InterpolateLinear: tn, InterpolateSmooth: 2302, InvertStencilOp: 5386, JSONLoader: function() { console.error("THREE.JSONLoader has been removed.") }, KeepStencilOp: yn, KeyframeTrack: hu, LOD: cc, LatheBufferGeometry: Fl, LatheGeometry: Bl, Layers: Ar, LensFlare: function() { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") }, LessDepth: vt, LessEqualDepth: yt, LessEqualStencilFunc: 515, LessStencilFunc: 513, Light: nh, LightProbe: mh, LightShadow: ih, Line: Ec, Line3: Mp, LineBasicMaterial: _c, LineCurve: Xu, LineCurve3: Yu, LineDashedMaterial: iu, LineLoop: Rc, LinePieces: 1, LineSegments: Lc, LineStrip: 0, LinearEncoding: an, LinearFilter: Ut, LinearInterpolant: lu, LinearMipMapLinearFilter: 1008, LinearMipMapNearestFilter: 1007, LinearMipmapLinearFilter: Ht, LinearMipmapNearestFilter: zt, LinearToneMapping: U, Loader: Su, LoaderUtils: vh, LoadingManager: wu, LogLuvEncoding: un, LoopOnce: 2200, LoopPingPong: 2202, LoopRepeat: 2201, LuminanceAlphaFormat: re, LuminanceFormat: ne, MOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Material: pi, MaterialLoader: gh, Math: An, MathUtils: An, Matrix3: Pn, Matrix4: mr, MaxEquation: rt, Mesh: $i, MeshBasicMaterial: di, MeshDepthMaterial: ys, MeshDistanceMaterial: _s, MeshFaceMaterial: function(t) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t }, MeshLambertMaterial: nu, MeshMatcapMaterial: ru, MeshNormalMaterial: eu, MeshPhongMaterial: $l, MeshPhysicalMaterial: Ql, MeshStandardMaterial: Kl, MeshToonMaterial: tu, MinEquation: nt, MirroredRepeatWrapping: Dt, MixOperation: B, MultiMaterial: function(t) { return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, (t.materials = t).clone = function() { return t.slice() }, t }, MultiplyBlending: K, MultiplyOperation: N, NearestFilter: Nt, NearestMipMapLinearFilter: 1005, NearestMipMapNearestFilter: 1004, NearestMipmapLinearFilter: Ft, NearestMipmapNearestFilter: Bt, NeverDepth: mt, NeverStencilFunc: 512, NoBlending: W, NoColors: 0, NoToneMapping: Et, NormalAnimationBlendMode: 2500, NormalBlending: q, NotEqualDepth: wt, NotEqualStencilFunc: 517, NumberKeyframeTrack: fu, Object3D: kr, ObjectLoader: wh, ObjectSpaceNormalMap: vn, OctahedronBufferGeometry: Zc, OctahedronGeometry: Yc, OneFactor: ot, OneMinusDstAlphaFactor: ht, OneMinusDstColorFactor: dt, OneMinusSrcAlphaFactor: lt, OneMinusSrcColorFactor: st, OrthographicCamera: lh, PCFShadowMap: O, PCFSoftShadowMap: I, PMREMGenerator: rp, ParametricBufferGeometry: Vc, ParametricGeometry: Gc, Particle: function(t) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new $s(t) }, ParticleBasicMaterial: function(t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Cc(t) }, ParticleSystem: function(t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Nc(t, e) }, ParticleSystemMaterial: function(t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Cc(t) }, Path: th, PerspectiveCamera: vo, Plane: Wr, PlaneBufferGeometry: Ao, PlaneGeometry: To, PlaneHelper: tp, PointCloud: function(t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Nc(t, e) }, PointCloudMaterial: function(t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Cc(t) }, PointLight: ch, PointLightHelper: Ip, Points: Nc, PointsMaterial: Cc, PolarGridHelper: Hn, PolyhedronBufferGeometry: Wc, PolyhedronGeometry: jc, PositionalAudio: Jh, PropertyBinding: lp, PropertyMixer: Kh, QuadraticBezierCurve: Zu, QuadraticBezierCurve3: Ju, Quaternion: zn, QuaternionKeyframeTrack: gu, QuaternionLinearInterpolant: mu, REVISION: "120", RGBADepthPacking: mn, RGBAFormat: ee, RGBAIntegerFormat: pe, RGBA_ASTC_10x10_Format: Ne, RGBA_ASTC_10x5_Format: Oe, RGBA_ASTC_10x6_Format: Ie, RGBA_ASTC_10x8_Format: De, RGBA_ASTC_12x10_Format: Be, RGBA_ASTC_12x12_Format: Fe, RGBA_ASTC_4x4_Format: Se, RGBA_ASTC_5x4_Format: Ee, RGBA_ASTC_5x5_Format: Te, RGBA_ASTC_6x5_Format: Ae, RGBA_ASTC_6x6_Format: Le, RGBA_ASTC_8x5_Format: Re, RGBA_ASTC_8x6_Format: Ce, RGBA_ASTC_8x8_Format: Pe, RGBA_BPTC_Format: Ue, RGBA_ETC2_EAC_Format: Me, RGBA_PVRTC_2BPPV1_Format: xe, RGBA_PVRTC_4BPPV1_Format: _e, RGBA_S3TC_DXT1_Format: fe, RGBA_S3TC_DXT3_Format: me, RGBA_S3TC_DXT5_Format: ge, RGBDEncoding: dn, RGBEEncoding: ln, RGBEFormat: ie, RGBFormat: te, RGBIntegerFormat: he, RGBM16Encoding: pn, RGBM7Encoding: hn, RGB_ETC1_Format: be, RGB_ETC2_Format: we, RGB_PVRTC_2BPPV1_Format: ye, RGB_PVRTC_4BPPV1_Format: ve, RGB_S3TC_DXT1_Format: de, RGFormat: le, RGIntegerFormat: ue, RawShaderMaterial: Jl, Ray: fr, Raycaster: gp, RectAreaLight: dh, RedFormat: se, RedIntegerFormat: ce, ReinhardToneMapping: z, RepeatWrapping: Ot, ReplaceStencilOp: 7681, ReverseSubtractEquation: et, RingBufferGeometry: Nl, RingGeometry: Dl, SRGB8_ALPHA8_ASTC_10x10_Format: Je, SRGB8_ALPHA8_ASTC_10x5_Format: Xe, SRGB8_ALPHA8_ASTC_10x6_Format: Ye, SRGB8_ALPHA8_ASTC_10x8_Format: Ze, SRGB8_ALPHA8_ASTC_12x10_Format: Ke, SRGB8_ALPHA8_ASTC_12x12_Format: Qe, SRGB8_ALPHA8_ASTC_4x4_Format: ze, SRGB8_ALPHA8_ASTC_5x4_Format: He, SRGB8_ALPHA8_ASTC_5x5_Format: ke, SRGB8_ALPHA8_ASTC_6x5_Format: Ge, SRGB8_ALPHA8_ASTC_6x6_Format: Ve, SRGB8_ALPHA8_ASTC_8x5_Format: je, SRGB8_ALPHA8_ASTC_8x6_Format: We, SRGB8_ALPHA8_ASTC_8x8_Format: qe, Scene: Ns, SceneUtils: op, ShaderChunk: Lo, ShaderLib: Co, ShaderMaterial: mo, ShadowMaterial: Zl, Shape: eh, ShapeBufferGeometry: zl, ShapeGeometry: Ul, ShapePath: Lh, ShapeUtils: Ml, ShortType: Vt, Skeleton: pc, SkeletonHelper: Op, SkinnedMesh: lc, SmoothShading: 2, Sphere: ar, SphereBufferGeometry: Il, SphereGeometry: Ol, Spherical: _p, SphericalHarmonics3: fh, Spline: dd, SplineCurve: Ku, SplineCurve3: pd, SpotLight: ah, SpotLightHelper: Lp, Sprite: $s, SpriteMaterial: Hs, SrcAlphaFactor: ct, SrcAlphaSaturateFactor: ft, SrcColorFactor: at, StaticCopyUsage: 35046, StaticDrawUsage: xn, StaticReadUsage: 35045, StereoCamera: Fh, StreamCopyUsage: 35042, StreamDrawUsage: 35040, StreamReadUsage: 35041, StringKeyframeTrack: vu, SubtractEquation: tt, SubtractiveBlending: J, TOUCH: { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, TangentSpaceNormalMap: gn, TetrahedronBufferGeometry: Xc, TetrahedronGeometry: qc, TextBufferGeometry: Pl, TextGeometry: Cl, Texture: Dn, TextureLoader: Ou, TorusBufferGeometry: ol, TorusGeometry: il, TorusKnotBufferGeometry: rl, TorusKnotGeometry: nl, Triangle: ni, TriangleFanDrawMode: on, TriangleStripDrawMode: 1, TrianglesDrawMode: 0, TubeBufferGeometry: el, TubeGeometry: tl, UVMapping: 300, Uint16Attribute: function(t, e) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new bi(t, e) }, Uint16BufferAttribute: bi, Uint32Attribute: function(t, e) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Mi(t, e) }, Uint32BufferAttribute: Mi, Uint8Attribute: function(t, e) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new yi(t, e) }, Uint8BufferAttribute: yi, Uint8ClampedAttribute: function(t, e) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new _i(t, e) }, Uint8ClampedBufferAttribute: _i, Uniform: dp, UniformsLib: Ro, UniformsUtils: ho, UnsignedByteType: kt, UnsignedInt248Type: Qt, UnsignedIntType: qt, UnsignedShort4444Type: Zt, UnsignedShort5551Type: Jt, UnsignedShort565Type: Kt, UnsignedShortType: jt, VSMShadowMap: D, Vector2: Ln, Vector3: kn, Vector4: Nn, VectorKeyframeTrack: yu, Vertex: function(t, e, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new kn(t, e, n) }, VertexColors: 2, VideoTexture: Fc, WebGL1Renderer: Os, WebGLCubeRenderTarget: _o, WebGLMultisampleRenderTarget: Un, WebGLRenderTarget: Fn, WebGLRenderTargetCube: function(t, e, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new _o(t, n) }, WebGLRenderer: Ps, WebGLUtils: Es, WireframeGeometry: kc, WireframeHelper: function(t, e) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Lc(new kc(t.geometry), new _c({ color: void 0 !== e ? e : 16777215 })) }, WrapAroundEnding: rn, XHRLoader: function(t) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Tu(t) }, ZeroCurvatureEnding: en, ZeroFactor: it, ZeroSlopeEnding: nn, ZeroStencilOp: 0, sRGBEncoding: sn }),
        fd = { update: null, begin: null, loopBegin: null, changeBegin: null, change: null, changeComplete: null, loopComplete: null, complete: null, loop: 1, direction: "normal", autoplay: !0, timelineOffset: 0 },
        md = { duration: 1e3, delay: 0, endDelay: 0, easing: "easeOutElastic(1, .5)", round: 0 },
        gd = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"],
        vd = { CSS: {}, springs: {} };

    function yd(t, e, n) { return Math.min(Math.max(t, e), n) }

    function _d(t, e) { return -1 < t.indexOf(e) }

    function xd(t, e) { return t.apply(null, e) }
    var bd = { arr: function(t) { return Array.isArray(t) }, obj: function(t) { return _d(Object.prototype.toString.call(t), "Object") }, pth: function(t) { return bd.obj(t) && t.hasOwnProperty("totalLength") }, svg: function(t) { return t instanceof SVGElement }, inp: function(t) { return t instanceof HTMLInputElement }, dom: function(t) { return t.nodeType || bd.svg(t) }, str: function(t) { return "string" == typeof t }, fnc: function(t) { return "function" == typeof t }, und: function(t) { return void 0 === t }, nil: function(t) { return bd.und(t) || null === t }, hex: function(t) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t) }, rgb: function(t) { return /^rgb/.test(t) }, hsl: function(t) { return /^hsl/.test(t) }, col: function(t) { return bd.hex(t) || bd.rgb(t) || bd.hsl(t) }, key: function(t) { return !fd.hasOwnProperty(t) && !md.hasOwnProperty(t) && "targets" !== t && "keyframes" !== t } };

    function wd(t) { t = /\(([^)]+)\)/.exec(t); return t ? t[1].split(",").map(function(t) { return parseFloat(t) }) : [] }

    function Md(r, n) {
        var t = wd(r),
            e = yd(bd.und(t[0]) ? 1 : t[0], .1, 100),
            i = yd(bd.und(t[1]) ? 100 : t[1], .1, 100),
            o = yd(bd.und(t[2]) ? 10 : t[2], .1, 100),
            t = yd(bd.und(t[3]) ? 0 : t[3], .1, 100),
            a = Math.sqrt(i / e),
            s = o / (2 * Math.sqrt(i * e)),
            c = s < 1 ? a * Math.sqrt(1 - s * s) : 0,
            l = 1,
            u = s < 1 ? (s * a - t) / c : -t + a;

        function h(t) {
            var e = n ? n * t / 1e3 : t,
                e = s < 1 ? Math.exp(-e * s * a) * (l * Math.cos(c * e) + u * Math.sin(c * e)) : (l + u * e) * Math.exp(-e * a);
            return 0 === t || 1 === t ? t : 1 - e
        }
        return n ? h : function() {
            var t = vd.springs[r];
            if (t) return t;
            for (var e = 0, n = 0;;)
                if (1 === h(e += 1 / 6)) { if (16 <= ++n) break } else n = 0;
            return t = e * (1 / 6) * 1e3, vd.springs[r] = t
        }
    }

    function Sd(e) {
        return void 0 === e && (e = 10),
            function(t) { return Math.ceil(yd(t, 1e-6, 1) * e) * (1 / e) }
    }
    var Ed = function(o, e, a, n) {
        if (0 <= o && o <= 1 && 0 <= a && a <= 1) {
            var s = new Float32Array(11);
            if (o !== e || a !== n)
                for (var t = 0; t < 11; ++t) s[t] = Ad(.1 * t, o, a);
            return function(t) { return o === e && a === n || 0 === t || 1 === t ? t : Ad(r(t), e, n) }
        }

        function r(t) {
            for (var e = 0, n = 1; 10 !== n && s[n] <= t; ++n) e += .1;
            var r = e + .1 * ((t - s[--n]) / (s[n + 1] - s[n])),
                i = Ld(r, o, a);
            return .001 <= i ? function(t, e, n, r) {
                for (var i = 0; i < 4; ++i) {
                    var o = Ld(e, n, r);
                    if (0 === o) return e;
                    e -= (Ad(e, n, r) - t) / o
                }
                return e
            }(t, r, o, a) : 0 === i ? r : function(t, e, n, r, i) { for (var o, a, s = 0; 0 < (o = Ad(a = e + (n - e) / 2, r, i) - t) ? n = a : e = a, 1e-7 < Math.abs(o) && ++s < 10;); return a }(t, e, e + .1, o, a)
        }
    };

    function Td(t, e) { return 1 - 3 * e + 3 * t }

    function Ad(t, e, n) { return ((Td(e, n) * t + (3 * n - 6 * e)) * t + 3 * e) * t }

    function Ld(t, e, n) { return 3 * Td(e, n) * t * t + 2 * (3 * n - 6 * e) * t + 3 * e }
    var Rd, Cd, Pd = (Rd = { linear: function() { return function(t) { return t } } }, Cd = {
        Sine: function() { return function(t) { return 1 - Math.cos(t * Math.PI / 2) } },
        Circ: function() { return function(t) { return 1 - Math.sqrt(1 - t * t) } },
        Back: function() { return function(t) { return t * t * (3 * t - 2) } },
        Bounce: function() { return function(t) { for (var e, n = 4; t < ((e = Math.pow(2, --n)) - 1) / 11;); return 1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2) } },
        Elastic: function(t, e) {
            void 0 === t && (t = 1), void 0 === e && (e = .5);
            var n = yd(t, 1, 10),
                r = yd(e, .1, 2);
            return function(t) { return 0 === t || 1 === t ? t : -n * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - r / (2 * Math.PI) * Math.asin(1 / n)) * (2 * Math.PI) / r) }
        }
    }, ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function(t, e) { Cd[t] = function() { return function(t) { return Math.pow(t, e + 2) } } }), Object.keys(Cd).forEach(function(t) {
        var r = Cd[t];
        Rd["easeIn" + t] = r, Rd["easeOut" + t] = function(e, n) { return function(t) { return 1 - r(e, n)(1 - t) } }, Rd["easeInOut" + t] = function(e, n) { return function(t) { return t < .5 ? r(e, n)(2 * t) / 2 : 1 - r(e, n)(-2 * t + 2) / 2 } }, Rd["easeOutIn" + t] = function(e, n) { return function(t) { return t < .5 ? (1 - r(e, n)(1 - 2 * t)) / 2 : (r(e, n)(2 * t - 1) + 1) / 2 } }
    }), Rd);

    function Od(t, e) {
        if (bd.fnc(t)) return t;
        var n = t.split("(")[0],
            r = Pd[n],
            i = wd(t);
        switch (n) {
            case "spring":
                return Md(t, e);
            case "cubicBezier":
                return xd(Ed, i);
            case "steps":
                return xd(Sd, i);
            default:
                return xd(r, i)
        }
    }

    function Id(t) { try { return document.querySelectorAll(t) } catch (t) { return } }

    function Dd(t, e) { for (var n, r = t.length, i = 2 <= arguments.length ? e : void 0, o = [], a = 0; a < r; a++) a in t && (n = t[a], e.call(i, n, a, t) && o.push(n)); return o }

    function Nd(t) { return t.reduce(function(t, e) { return t.concat(bd.arr(e) ? Nd(e) : e) }, []) }

    function Bd(t) { return bd.arr(t) ? t : (bd.str(t) && (t = Id(t) || t), t instanceof NodeList || t instanceof HTMLCollection ? [].slice.call(t) : [t]) }

    function Fd(t, e) { return t.some(function(t) { return t === e }) }

    function Ud(t) { var e, n = {}; for (e in t) n[e] = t[e]; return n }

    function zd(t, e) { var n, r = Ud(t); for (n in t) r[n] = (e.hasOwnProperty(n) ? e : t)[n]; return r }

    function Hd(t, e) { var n, r = Ud(t); for (n in e) r[n] = (bd.und(t[n]) ? e : t)[n]; return r }

    function kd(t) {
        return bd.rgb(t) ? (e = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(o = t)) ? "rgba(" + e[1] + ",1)" : o : bd.hex(t) ? (a = (a = t).replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, n, r) { return e + e + n + n + r + r }), a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a), "rgba(" + parseInt(a[1], 16) + "," + parseInt(a[2], 16) + "," + parseInt(a[3], 16) + ",1)") : bd.hsl(t) ? (o = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e = t) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(e), a = parseInt(o[1], 10) / 360, t = parseInt(o[2], 10) / 100, e = parseInt(o[3], 10) / 100, o = o[4] || 1, 0 == t ? n = r = i = e : (n = s(t = 2 * e - (e = e < .5 ? e * (1 + t) : e + t - e * t), e, a + 1 / 3), r = s(t, e, a), i = s(t, e, a - 1 / 3)), "rgba(" + 255 * n + "," + 255 * r + "," + 255 * i + "," + o + ")") : void 0;
        var e, n, r, i, o, a;

        function s(t, e, n) { return n < 0 && (n += 1), 1 < n && --n, n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t }
    }

    function Gd(t) { t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(t); if (t) return t[1] }

    function Vd(t, e) { return bd.fnc(t) ? t(e.target, e.id, e.total) : t }

    function jd(t, e) { return t.getAttribute(e) }

    function Wd(t, e, n) {
        if (Fd([n, "deg", "rad", "turn"], Gd(e))) return e;
        var r = vd.CSS[e + n];
        if (!bd.und(r)) return r;
        var i = document.createElement(t.tagName),
            r = t.parentNode && t.parentNode !== document ? t.parentNode : document.body;
        r.appendChild(i), i.style.position = "absolute", i.style.width = 100 + n;
        t = 100 / i.offsetWidth;
        r.removeChild(i);
        t *= parseFloat(e);
        return vd.CSS[e + n] = t
    }

    function qd(t, e, n) {
        if (e in t.style) {
            var r = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
                r = t.style[e] || getComputedStyle(t).getPropertyValue(r) || "0";
            return n ? Wd(t, r, n) : r
        }
    }

    function Xd(t, e) { return bd.dom(t) && !bd.inp(t) && (!bd.nil(jd(t, e)) || bd.svg(t) && t[e]) ? "attribute" : bd.dom(t) && Fd(gd, e) ? "transform" : bd.dom(t) && "transform" !== e && qd(t, e) ? "css" : null != t[e] ? "object" : void 0 }

    function Yd(t) { if (bd.dom(t)) { for (var e, n = t.style.transform || "", r = /(\w+)\(([^)]*)\)/g, i = new Map; e = r.exec(n);) i.set(e[1], e[2]); return i } }

    function Zd(t, e, n, r) {
        var i = _d(e, "scale") ? 1 : 0 + (_d(i = e, "translate") || "perspective" === i ? "px" : _d(i, "rotate") || _d(i, "skew") ? "deg" : void 0),
            i = Yd(t).get(e) || i;
        return n && (n.transforms.list.set(e, i), n.transforms.last = e), r ? Wd(t, i, r) : i
    }

    function Jd(t, e, n, r) {
        switch (Xd(t, e)) {
            case "transform":
                return Zd(t, e, r, n);
            case "css":
                return qd(t, e, n);
            case "attribute":
                return jd(t, e);
            default:
                return t[e] || 0
        }
    }

    function Kd(t, e) {
        var n = /^(\*=|\+=|-=)/.exec(t);
        if (!n) return t;
        var r = Gd(t) || 0,
            i = parseFloat(e),
            o = parseFloat(t.replace(n[0], ""));
        switch (n[0][0]) {
            case "+":
                return i + o + r;
            case "-":
                return i - o + r;
            case "*":
                return i * o + r
        }
    }

    function Qd(t, e) {
        if (bd.col(t)) return kd(t);
        if (/\s/g.test(t)) return t;
        var n = Gd(t),
            t = n ? t.substr(0, t.length - n.length) : t;
        return e ? t + e : t
    }

    function $d(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) }

    function tf(t) {
        for (var e, n = t.points, r = 0, i = 0; i < n.numberOfItems; i++) {
            var o = n.getItem(i);
            0 < i && (r += $d(e, o)), e = o
        }
        return r
    }

    function ef(t) {
        if (t.getTotalLength) return t.getTotalLength();
        switch (t.tagName.toLowerCase()) {
            case "circle":
                return r = t, 2 * Math.PI * jd(r, "r");
            case "rect":
                return 2 * jd(n = t, "width") + 2 * jd(n, "height");
            case "line":
                return $d({ x: jd(e = t, "x1"), y: jd(e, "y1") }, { x: jd(e, "x2"), y: jd(e, "y2") });
            case "polyline":
                return tf(t);
            case "polygon":
                return e = (n = t).points, tf(n) + $d(e.getItem(e.numberOfItems - 1), e.getItem(0))
        }
        var e, n, r
    }

    function nf(t, e) {
        var n = e || {},
            r = n.el || function(t) { for (var e = t.parentNode; bd.svg(e) && bd.svg(e.parentNode);) e = e.parentNode; return e }(t),
            i = r.getBoundingClientRect(),
            e = jd(r, "viewBox"),
            t = i.width,
            i = i.height,
            e = n.viewBox || (e ? e.split(" ") : [0, 0, t, i]);
        return { el: r, viewBox: e, x: +e[0], y: +e[1], w: t, h: i, vW: e[2], vH: e[3] }
    }

    function rf(t, e) {
        var n = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
            r = Qd(bd.pth(t) ? t.totalLength : t, e) + "";
        return { original: r, numbers: r.match(n) ? r.match(n).map(Number) : [0], strings: bd.str(t) || e ? r.split(n) : [] }
    }

    function of(t) { return Dd(t ? Nd(bd.arr(t) ? t.map(Bd) : Bd(t)) : [], function(t, e, n) { return n.indexOf(t) === e }) }

    function af(t) { var n = of(t); return n.map(function(t, e) { return { target: t, id: e, total: n.length, transforms: { list: Yd(t) } } }) }

    function sf(t, e) {
        var n, r = [],
            i = e.keyframes;
        for (n in i && (e = Hd(function(e) {
                for (var n = Dd(Nd(e.map(function(t) { return Object.keys(t) })), function(t) { return bd.key(t) }).reduce(function(t, e) { return t.indexOf(e) < 0 && t.push(e), t }, []), i = {}, t = 0; t < n.length; t++) ! function(t) {
                    var r = n[t];
                    i[r] = e.map(function(t) { var e, n = {}; for (e in t) bd.key(e) ? e == r && (n.value = t[e]) : n[e] = t[e]; return n })
                }(t);
                return i
            }(i), e)), e) bd.key(n) && r.push({ name: n, tweens: function(t, n) { var e, r = Ud(n); /^spring/.test(r.easing) && (r.duration = Md(r.easing)), bd.arr(t) && (2 === (e = t.length) && !bd.obj(t[0]) ? t = { value: t } : bd.fnc(n.duration) || (r.duration = n.duration / e)); var i = bd.arr(t) ? t : [t]; return i.map(function(t, e) { t = bd.obj(t) && !bd.pth(t) ? t : { value: t }; return bd.und(t.delay) && (t.delay = e ? 0 : n.delay), bd.und(t.endDelay) && (t.endDelay = e === i.length - 1 ? n.endDelay : 0), t }).map(function(t) { return Hd(t, r) }) }(e[n], t) });
        return r
    }

    function cf(s, c) {
        var l;
        return s.tweens.map(function(t) {
            var e = function(t, e) {
                    var n, r = {};
                    for (n in t) {
                        var i = Vd(t[n], e);
                        bd.arr(i) && 1 === (i = i.map(function(t) { return Vd(t, e) })).length && (i = i[0]), r[n] = i
                    }
                    return r.duration = parseFloat(r.duration), r.delay = parseFloat(r.delay), r
                }(t, c),
                n = e.value,
                r = bd.arr(n) ? n[1] : n,
                i = Gd(r),
                o = Jd(c.target, s.name, i, c),
                a = l ? l.to.original : o,
                t = bd.arr(n) ? n[0] : a,
                o = Gd(t) || Gd(o),
                o = i || o;
            return bd.und(r) && (r = a), e.from = rf(t, o), e.to = rf(Kd(r, t), o), e.start = l ? l.end : 0, e.end = e.start + e.delay + e.duration + e.endDelay, e.easing = Od(e.easing, e.duration), e.isPath = bd.pth(n), e.isPathTargetInsideSVG = e.isPath && bd.svg(c.target), e.isColor = bd.col(e.from.original), e.isColor && (e.round = 1), l = e
        })
    }
    var lf = {
        css: function(t, e, n) { return t.style[e] = n },
        attribute: function(t, e, n) { return t.setAttribute(e, n) },
        object: function(t, e, n) { return t[e] = n },
        transform: function(t, e, n, r, i) {
            var o;
            r.list.set(e, n), e !== r.last && !i || (o = "", r.list.forEach(function(t, e) { o += e + "(" + t + ") " }), t.style.transform = o)
        }
    };

    function uf(t, a) {
        af(t).forEach(function(t) {
            for (var e in a) {
                var n = Vd(a[e], t),
                    r = t.target,
                    i = Gd(n),
                    o = Jd(r, e, i, t),
                    i = Kd(Qd(n, i || Gd(o)), o),
                    o = Xd(r, e);
                lf[o](r, e, i, t.transforms, !0)
            }
        })
    }

    function hf(t, n) {
        return Dd(Nd(t.map(function(e) {
            return n.map(function(t) {
                return function(t, e) {
                    var n = Xd(t.target, e.name);
                    if (n) {
                        var r = cf(e, t),
                            i = r[r.length - 1];
                        return { type: n, property: e.name, animatable: t, tweens: r, duration: i.end, delay: r[0].delay, endDelay: i.endDelay }
                    }
                }(e, t)
            })
        })), function(t) { return !bd.und(t) })
    }

    function pf(t, e) {
        function n(t) { return t.timelineOffset || 0 }
        var r = t.length,
            i = {};
        return i.duration = r ? Math.max.apply(Math, t.map(function(t) { return n(t) + t.duration })) : e.duration, i.delay = r ? Math.min.apply(Math, t.map(function(t) { return n(t) + t.delay })) : e.delay, i.endDelay = r ? i.duration - Math.max.apply(Math, t.map(function(t) { return n(t) + t.duration - t.endDelay })) : e.endDelay, i
    }
    var df = 0;
    var ff, mf = [],
        gf = ("undefined" != typeof document && document.addEventListener("visibilitychange", function() { _f.suspendWhenDocumentHidden && (yf() ? ff = cancelAnimationFrame(ff) : (mf.forEach(function(t) { return t._onDocumentVisibility() }), gf())) }), function() { ff || yf() && _f.suspendWhenDocumentHidden || !(0 < mf.length) || (ff = requestAnimationFrame(vf)) });

    function vf(t) {
        for (var e = mf.length, n = 0; n < e;) {
            var r = mf[n];
            r.paused ? (mf.splice(n, 1), e--) : (r.tick(t), n++)
        }
        ff = 0 < n ? requestAnimationFrame(vf) : void 0
    }

    function yf() { return document && document.hidden }

    function _f(t) {
        void 0 === t && (t = {});
        var o, a = 0,
            s = 0,
            c = 0,
            l = 0,
            u = null;

        function h(t) { var e = window.Promise && new Promise(function(t) { return u = t }); return t.finished = e }
        var e, n, r, i, M = (n = zd(fd, e = t), r = sf(i = zd(md, e), e), t = af(e.targets), r = pf(e = hf(t, r), i), i = df, df++, Hd(n, { id: i, children: [], animatables: t, animations: e, duration: r.duration, delay: r.delay, endDelay: r.endDelay }));
        h(M);

        function p() { var t = M.direction; "alternate" !== t && (M.direction = "normal" !== t ? "normal" : "reverse"), M.reversed = !M.reversed, o.forEach(function(t) { return t.reversed = M.reversed }) }

        function d(t) { return M.reversed ? M.duration - t : t }

        function f() { a = 0, s = d(M.currentTime) * (1 / _f.speed) }

        function m(t, e) { e && e.seek(t - e.timelineOffset) }

        function g(e) {
            for (var t = 0, n = M.animations, r = n.length; t < r;) {
                var i = n[t],
                    o = i.animatable,
                    a = i.tweens,
                    s = a.length - 1,
                    c = a[s];
                s && (c = Dd(a, function(t) { return e < t.end })[0] || c);
                for (var a = yd(e - c.start - c.delay, 0, c.duration) / c.duration, l = isNaN(a) ? 1 : c.easing(a), u = c.to.strings, h = c.round, p = [], d = c.to.numbers.length, f = void 0, m = 0; m < d; m++) {
                    var g = void 0,
                        v = c.to.numbers[m],
                        y = c.from.numbers[m] || 0,
                        g = c.isPath ? function(e, n, t) {
                            function r(t) {
                                void 0 === t && (t = 0);
                                t = 1 <= n + t ? n + t : 0;
                                return e.el.getPointAtLength(t)
                            }
                            var i = nf(e.el, e.svg),
                                o = r(),
                                a = r(-1),
                                s = r(1),
                                c = t ? 1 : i.w / i.vW,
                                l = t ? 1 : i.h / i.vH;
                            switch (e.property) {
                                case "x":
                                    return (o.x - i.x) * c;
                                case "y":
                                    return (o.y - i.y) * l;
                                case "angle":
                                    return 180 * Math.atan2(s.y - a.y, s.x - a.x) / Math.PI
                            }
                        }(c.value, l * v, c.isPathTargetInsideSVG) : y + l * (v - y);
                    h && (c.isColor && 2 < m || (g = Math.round(g * h) / h)), p.push(g)
                }
                var _ = u.length;
                if (_) {
                    f = u[0];
                    for (var x = 0; x < _; x++) {
                        u[x];
                        var b = u[x + 1],
                            w = p[x];
                        isNaN(w) || (f += b ? w + b : w + " ")
                    }
                } else f = p[0];
                lf[i.type](o.target, i.property, f, o.transforms), i.currentValue = f, t++
            }
        }

        function v(t) { M[t] && !M.passThrough && M[t](M) }

        function y(t) {
            var e = M.duration,
                n = M.delay,
                r = e - M.endDelay,
                i = d(t);
            M.progress = yd(i / e * 100, 0, 100), M.reversePlayback = i < M.currentTime, o && function(t) {
                if (M.reversePlayback)
                    for (var e = l; e--;) m(t, o[e]);
                else
                    for (var n = 0; n < l; n++) m(t, o[n])
            }(i), !M.began && 0 < M.currentTime && (M.began = !0, v("begin")), !M.loopBegan && 0 < M.currentTime && (M.loopBegan = !0, v("loopBegin")), i <= n && 0 !== M.currentTime && g(0), (r <= i && M.currentTime !== e || !e) && g(e), n < i && i < r ? (M.changeBegan || (M.changeBegan = !0, M.changeCompleted = !1, v("changeBegin")), v("change"), g(i)) : M.changeBegan && (M.changeCompleted = !0, M.changeBegan = !1, v("changeComplete")), M.currentTime = yd(i, 0, e), M.began && v("update"), e <= t && (s = 0, M.remaining && !0 !== M.remaining && M.remaining--, M.remaining ? (a = c, v("loopComplete"), M.loopBegan = !1, "alternate" === M.direction && p()) : (M.paused = !0, M.completed || (M.completed = !0, v("loopComplete"), v("complete"), !M.passThrough && "Promise" in window && (u(), h(M)))))
        }
        return M.reset = function() {
            var t = M.direction;
            M.passThrough = !1, M.currentTime = 0, M.progress = 0, M.paused = !0, M.began = !1, M.loopBegan = !1, M.changeBegan = !1, M.completed = !1, M.changeCompleted = !1, M.reversePlayback = !1, M.reversed = "reverse" === t, M.remaining = M.loop, o = M.children;
            for (var e = l = o.length; e--;) M.children[e].reset();
            (M.reversed && !0 !== M.loop || "alternate" === t && 1 === M.loop) && M.remaining++, g(M.reversed ? M.duration : 0)
        }, M._onDocumentVisibility = f, M.set = function(t, e) { return uf(t, e), M }, M.tick = function(t) { y(((c = t) + (s - (a = a || c))) * _f.speed) }, M.seek = function(t) { y(d(t)) }, M.pause = function() { M.paused = !0, f() }, M.play = function() { M.paused && (M.completed && M.reset(), M.paused = !1, mf.push(M), f(), gf()) }, M.reverse = function() { p(), M.completed = !M.reversed, f() }, M.restart = function() { M.reset(), M.play() }, M.remove = function(t) { bf(of(t), M) }, M.reset(), M.autoplay && M.play(), M
    }

    function xf(t, e) { for (var n = e.length; n--;) Fd(t, e[n].animatable.target) && e.splice(n, 1) }

    function bf(t, e) {
        var n = e.animations,
            r = e.children;
        xf(t, n);
        for (var i = r.length; i--;) {
            var o = r[i],
                a = o.animations;
            xf(t, a), a.length || o.children.length || r.splice(i, 1)
        }
        n.length || r.length || e.pause()
    }
    _f.version = "3.2.1", _f.speed = 1, _f.suspendWhenDocumentHidden = !0, _f.running = mf, _f.remove = function(t) { for (var e = of(t), n = mf.length; n--;) bf(e, mf[n]) }, _f.get = Jd, _f.set = uf, _f.convertPx = Wd, _f.path = function(t, e) {
        var n = bd.str(t) ? Id(t)[0] : t,
            r = e || 100;
        return function(t) { return { property: t, el: n, svg: nf(n), totalLength: ef(n) * (r / 100) } }
    }, _f.setDashoffset = function(t) { var e = ef(t); return t.setAttribute("stroke-dasharray", e), e }, _f.stagger = function(t, e) {
        void 0 === e && (e = {});
        var s = e.direction || "normal",
            c = e.easing ? Od(e.easing) : null,
            l = e.grid,
            u = e.axis,
            h = e.from || 0,
            p = "first" === h,
            d = "center" === h,
            f = "last" === h,
            m = bd.arr(t),
            g = m ? parseFloat(t[0]) : parseFloat(t),
            v = m ? parseFloat(t[1]) : 0,
            y = Gd(m ? t[1] : t) || 0,
            _ = e.start || 0 + (m ? g : 0),
            x = [],
            b = 0;
        return function(t, e, n) {
            if (p && (h = 0), d && (h = (n - 1) / 2), f && (h = n - 1), !x.length) {
                for (var r, i, o, a = 0; a < n; a++) l ? (i = d ? (l[0] - 1) / 2 : h % l[0], o = d ? (l[1] - 1) / 2 : Math.floor(h / l[0]), r = i - a % l[0], i = o - Math.floor(a / l[0]), o = Math.sqrt(r * r + i * i), "x" === u && (o = -r), "y" === u && (o = -i), x.push(o)) : x.push(Math.abs(h - a)), b = Math.max.apply(Math, x);
                c && (x = x.map(function(t) { return c(t / b) * b })), "reverse" === s && (x = x.map(function(t) { return u ? t < 0 ? -1 * t : -t : Math.abs(b - t) }))
            }
            return _ + (m ? (v - g) / b : g) * (Math.round(100 * x[e]) / 100) + y
        }
    }, _f.timeline = function(a) {
        void 0 === a && (a = {});
        var s = _f(a);
        return s.duration = 0, s.add = function(t, e) {
            var n = mf.indexOf(s),
                r = s.children;

            function i(t) { t.passThrough = !0 } - 1 < n && mf.splice(n, 1);
            for (var o = 0; o < r.length; o++) i(r[o]);
            n = Hd(t, zd(md, a));
            n.targets = n.targets || a.targets;
            t = s.duration;
            n.autoplay = !1, n.direction = s.direction, n.timelineOffset = bd.und(e) ? t : Kd(e, t), i(s), s.seek(n.timelineOffset);
            n = _f(n);
            i(n), r.push(n);
            n = pf(r, a);
            return s.delay = n.delay, s.endDelay = n.endDelay, s.duration = n.duration, s.seek(0), s.reset(), s.autoplay && s.play(), s
        }, s
    }, _f.easing = Od, _f.penner = Pd, _f.random = function(t, e) { return Math.floor(Math.random() * (e - t + 1)) + t };
    il = function() { this.el = document.documentElement, this.bodyEl = document.body, this.width = 0, this.height = 0, this.x = this._getScrollLeft(), this.y = this._getScrollTop(), this.breakPoints = { xxs: 350, xs: 500, s: 800, m: 1100, l: 1500, xl: 2e3, xxl: 2500 }, this.supportsTouch = "ontouchstart" in window, this.isMobileDevice = this._detectMobileDevice(), this._updateDimensions(), window.addEventListener("resize", this), document.addEventListener("scroll", this, { pasive: !0 }) };
    il.prototype.isMinWidth = function(t) { return this.breakPoints[t] <= this.width }, il.prototype._detectMobileDevice = function() { return this.supportsTouch && this.width < this.breakPoints.s }, il.prototype._getScrollLeft = function() { return window.pageXOffset || this.el.scrollLeft || this.bodyEl.scrollLeft || 0 }, il.prototype._getScrollTop = function() { return window.pageYOffset || this.el.scrollTop || this.bodyEl.scrollTop || 0 }, il.prototype._updateScrollPosition = function() { this.x = this._getScrollLeft(), this.y = this._getScrollTop() }, il.prototype._updateDimensions = function() { this._updateScrollPosition(), this.width = this.el.clientWidth || this.bodyEl.clientWidth, this.height = window.innerHeight, this.scrollHeight = this.bodyEl.scrollHeight, this.el.style.setProperty("--doc-width", this.width + "px"), this.el.style.setProperty("--doc-height", this.height + "px"), this.isMobileDevice = this._detectMobileDevice() }, il.prototype.handleEvent = function(t) {
        switch (t.type) {
            case "resize":
                this._updateDimensions();
                break;
            case "scroll":
                this._updateScrollPosition()
        }
    };
    var wf = new il;

    function Mf(t, e) {
        var n = t.__state.conversionName.toString(),
            r = Math.round(t.r),
            i = Math.round(t.g),
            o = Math.round(t.b),
            a = t.a,
            s = Math.round(t.h),
            c = t.s.toFixed(1),
            l = t.v.toFixed(1);
        if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) { for (var u = t.hex.toString(16); u.length < 6;) u = "0" + u; return "#" + u }
        return "CSS_RGB" === n ? "rgb(" + r + "," + i + "," + o + ")" : "CSS_RGBA" === n ? "rgba(" + r + "," + i + "," + o + "," + a + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + r + "," + i + "," + o + "]" : "RGBA_ARRAY" === n ? "[" + r + "," + i + "," + o + "," + a + "]" : "RGB_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + o + "}" : "RGBA_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + o + ",a:" + a + "}" : "HSV_OBJ" === n ? "{h:" + s + ",s:" + c + ",v:" + l + "}" : "HSVA_OBJ" === n ? "{h:" + s + ",s:" + c + ",v:" + l + ",a:" + a + "}" : "unknown format"
    }
    var Sf, Ef = Array.prototype.forEach,
        Tf = Array.prototype.slice,
        Af = {
            BREAK: {},
            extend: function(n) {
                return this.each(Tf.call(arguments, 1), function(e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(t) { this.isUndefined(e[t]) || (n[t] = e[t]) }.bind(this))
                }, this), n
            },
            defaults: function(n) {
                return this.each(Tf.call(arguments, 1), function(e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(t) { this.isUndefined(n[t]) && (n[t] = e[t]) }.bind(this))
                }, this), n
            },
            compose: function() { var n = Tf.call(arguments); return function() { for (var t = Tf.call(arguments), e = n.length - 1; 0 <= e; e--) t = [n[e].apply(this, t)]; return t[0] } },
            each: function(t, e, n) {
                if (t)
                    if (Ef && t.forEach && t.forEach === Ef) t.forEach(e, n);
                    else if (t.length === t.length + 0) {
                    for (var r = void 0, r = 0, i = t.length; r < i; r++)
                        if (r in t && e.call(n, t[r], r) === this.BREAK) return
                } else
                    for (var o in t)
                        if (e.call(n, t[o], o) === this.BREAK) return
            },
            defer: function(t) { setTimeout(t, 0) },
            debounce: function(r, i, o) {
                var a = void 0;
                return function() {
                    var t = this,
                        e = arguments;
                    var n = o || !a;
                    clearTimeout(a), a = setTimeout(function() { a = null, o || r.apply(t, e) }, i), n && r.apply(t, e)
                }
            },
            toArray: function(t) { return t.toArray ? t.toArray() : Tf.call(t) },
            isUndefined: function(t) { return void 0 === t },
            isNull: function(t) { return null === t },
            isNaN: (Sf = function(t) { return isNaN(t) }, Lf.toString = function() { return Sf.toString() }, Lf),
            isArray: Array.isArray || function(t) { return t.constructor === Array },
            isObject: function(t) { return t === Object(t) },
            isNumber: function(t) { return t === t + 0 },
            isString: function(t) { return t === t + "" },
            isBoolean: function(t) { return !1 === t || !0 === t },
            isFunction: function(t) { return t instanceof Function }
        };

    function Lf(t) { return Sf.apply(this, arguments) }
    var Rf, Cf = [{ litmus: Af.isString, conversions: { THREE_CHAR_HEX: { read: function(t) { t = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) } }, write: Mf }, SIX_CHAR_HEX: { read: function(t) { t = t.match(/^#([A-F0-9]{6})$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) } }, write: Mf }, CSS_RGB: { read: function(t) { t = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) } }, write: Mf }, CSS_RGBA: { read: function(t) { t = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) } }, write: Mf } } }, { litmus: Af.isNumber, conversions: { HEX: { read: function(t) { return { space: "HEX", hex: t, conversionName: "HEX" } }, write: function(t) { return t.hex } } } }, { litmus: Af.isArray, conversions: { RGB_ARRAY: { read: function(t) { return 3 === t.length && { space: "RGB", r: t[0], g: t[1], b: t[2] } }, write: function(t) { return [t.r, t.g, t.b] } }, RGBA_ARRAY: { read: function(t) { return 4 === t.length && { space: "RGB", r: t[0], g: t[1], b: t[2], a: t[3] } }, write: function(t) { return [t.r, t.g, t.b, t.a] } } } }, { litmus: Af.isObject, conversions: { RGBA_OBJ: { read: function(t) { return !!(Af.isNumber(t.r) && Af.isNumber(t.g) && Af.isNumber(t.b) && Af.isNumber(t.a)) && { space: "RGB", r: t.r, g: t.g, b: t.b, a: t.a } }, write: function(t) { return { r: t.r, g: t.g, b: t.b, a: t.a } } }, RGB_OBJ: { read: function(t) { return !!(Af.isNumber(t.r) && Af.isNumber(t.g) && Af.isNumber(t.b)) && { space: "RGB", r: t.r, g: t.g, b: t.b } }, write: function(t) { return { r: t.r, g: t.g, b: t.b } } }, HSVA_OBJ: { read: function(t) { return !!(Af.isNumber(t.h) && Af.isNumber(t.s) && Af.isNumber(t.v) && Af.isNumber(t.a)) && { space: "HSV", h: t.h, s: t.s, v: t.v, a: t.a } }, write: function(t) { return { h: t.h, s: t.s, v: t.v, a: t.a } } }, HSV_OBJ: { read: function(t) { return !!(Af.isNumber(t.h) && Af.isNumber(t.s) && Af.isNumber(t.v)) && { space: "HSV", h: t.h, s: t.s, v: t.v } }, write: function(t) { return { h: t.h, s: t.s, v: t.v } } } } }],
        Pf = void 0,
        Of = void 0,
        If = function(t) { Of = !1; var n = 1 < arguments.length ? Af.toArray(arguments) : t; return Af.each(Cf, function(t) { if (t.litmus(n)) return Af.each(t.conversions, function(t, e) { if (Pf = t.read(n), !1 === Of && !1 !== Pf) return (Of = Pf).conversionName = e, Pf.conversion = t, Af.BREAK }), Af.BREAK }), Of },
        Df = {
            hsv_to_rgb: function(t, e, n) {
                var r = Math.floor(t / 60) % 6,
                    i = t / 60 - Math.floor(t / 60),
                    o = n * (1 - e),
                    t = n * (1 - i * e),
                    e = n * (1 - (1 - i) * e),
                    r = [
                        [n, e, o],
                        [t, n, o],
                        [o, n, e],
                        [o, t, n],
                        [e, o, n],
                        [n, o, t]
                    ][r];
                return { r: 255 * r[0], g: 255 * r[1], b: 255 * r[2] }
            },
            rgb_to_hsv: function(t, e, n) {
                var r = Math.min(t, e, n),
                    i = Math.max(t, e, n),
                    o = i - r,
                    r = void 0;
                return 0 === i ? { h: NaN, s: 0, v: 0 } : (r = t === i ? (e - n) / o : e === i ? 2 + (n - t) / o : 4 + (t - e) / o, (r /= 6) < 0 && (r += 1), { h: 360 * r, s: o / i, v: i / 255 })
            },
            rgb_to_hex: function(t, e, n) { t = this.hex_with_component(0, 2, t), t = this.hex_with_component(t, 1, e); return t = this.hex_with_component(t, 0, n) },
            component_from_hex: function(t, e) { return t >> 8 * e & 255 },
            hex_with_component: function(t, e, n) { return n << (Rf = 8 * e) | t & ~(255 << Rf) }
        },
        Nf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) { return typeof t } : function(t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t },
        Bf = function(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") },
        nl = function(t, e, n) { return e && Ff(t.prototype, e), n && Ff(t, n), t };

    function Ff(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }

    function Uf(t, e, n) {
        null === t && (t = Function.prototype);
        var r = Object.getOwnPropertyDescriptor(t, e);
        if (void 0 !== r) {
            if ("value" in r) return r.value;
            r = r.get;
            return void 0 !== r ? r.call(n) : void 0
        }
        if (t = Object.getPrototypeOf(t), null !== t) return Uf(t, e, n)
    }
    var tl = function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
            t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
        },
        zf = function(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e },
        Hf = (nl(kf, [{ key: "toString", value: function() { return Mf(this) } }, { key: "toHexString", value: function() { return Mf(this, !0) } }, { key: "toOriginal", value: function() { return this.__state.conversion.write(this) } }]), kf);

    function kf() {
        if (Bf(this, kf), this.__state = If.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
        this.__state.a = this.__state.a || 1
    }

    function Gf(t, e, n) { Object.defineProperty(t, e, { get: function() { return "RGB" === this.__state.space || Hf.recalculateRGB(this, e, n), this.__state[e] }, set: function(t) { "RGB" !== this.__state.space && (Hf.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = t } }) }

    function Vf(t, e) { Object.defineProperty(t, e, { get: function() { return "HSV" === this.__state.space || Hf.recalculateHSV(this), this.__state[e] }, set: function(t) { "HSV" !== this.__state.space && (Hf.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t } }) }
    Hf.recalculateRGB = function(t, e, n) {
        if ("HEX" === t.__state.space) t.__state[e] = Df.component_from_hex(t.__state.hex, n);
        else {
            if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
            Af.extend(t.__state, Df.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
        }
    }, Hf.recalculateHSV = function(t) {
        var e = Df.rgb_to_hsv(t.r, t.g, t.b);
        Af.extend(t.__state, { s: e.s, v: e.v }), Af.isNaN(e.h) ? Af.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
    }, Hf.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], Gf(Hf.prototype, "r", 2), Gf(Hf.prototype, "g", 1), Gf(Hf.prototype, "b", 0), Vf(Hf.prototype, "h"), Vf(Hf.prototype, "s"), Vf(Hf.prototype, "v"), Object.defineProperty(Hf.prototype, "a", { get: function() { return this.__state.a }, set: function(t) { this.__state.a = t } }), Object.defineProperty(Hf.prototype, "hex", { get: function() { return "HEX" !== this.__state.space && (this.__state.hex = Df.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex }, set: function(t) { this.__state.space = "HEX", this.__state.hex = t } });
    var jf = (nl(Wf, [{ key: "onChange", value: function(t) { return this.__onChange = t, this } }, { key: "onFinishChange", value: function(t) { return this.__onFinishChange = t, this } }, { key: "setValue", value: function(t) { return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this } }, { key: "getValue", value: function() { return this.object[this.property] } }, { key: "updateDisplay", value: function() { return this } }, { key: "isModified", value: function() { return this.initialValue !== this.getValue() } }]), Wf);

    function Wf(t, e) { Bf(this, Wf), this.initialValue = t[e], this.domElement = document.createElement("div"), this.object = t, this.property = e, this.__onChange = void 0, this.__onFinishChange = void 0 }
    var qf = {};
    Af.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, function(t, e) { Af.each(t, function(t) { qf[t] = e }) });
    var Xf = /(\d+(\.\d+)?)px/;

    function Yf(t) {
        if ("0" === t || Af.isUndefined(t)) return 0;
        t = t.match(Xf);
        return Af.isNull(t) ? 0 : parseFloat(t[1])
    }
    var Zf = {
            makeSelectable: function(t, e) { void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() { return !1 } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off") },
            makeFullscreen: function(t, e, n) { Af.isUndefined(e) && (e = !0), Af.isUndefined(n) && (n = !0), t.style.position = "absolute", e && (t.style.left = 0, t.style.right = 0), n && (t.style.top = 0, t.style.bottom = 0) },
            fakeEvent: function(t, e, n, r) {
                var i = n || {},
                    n = qf[e];
                if (!n) throw new Error("Event type " + e + " not supported.");
                var o = document.createEvent(n);
                switch (n) {
                    case "MouseEvents":
                        var a = i.x || i.clientX || 0,
                            s = i.y || i.clientY || 0;
                        o.initMouseEvent(e, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, a, s, !1, !1, !1, !1, 0, null);
                        break;
                    case "KeyboardEvents":
                        s = o.initKeyboardEvent || o.initKeyEvent;
                        Af.defaults(i, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), s(e, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
                        break;
                    default:
                        o.initEvent(e, i.bubbles || !1, i.cancelable || !0)
                }
                Af.defaults(o, r), t.dispatchEvent(o)
            },
            bind: function(t, e, n, r) { r = r || !1; return t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on" + e, n), Zf },
            unbind: function(t, e, n, r) { r = r || !1; return t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on" + e, n), Zf },
            addClass: function(t, e) { var n; return void 0 === t.className ? t.className = e : t.className === e || -1 === (n = t.className.split(/ +/)).indexOf(e) && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")), Zf },
            removeClass: function(t, e) { var n; return e ? t.className === e ? t.removeAttribute("class") : -1 !== (e = (n = t.className.split(/ +/)).indexOf(e)) && (n.splice(e, 1), t.className = n.join(" ")) : t.className = void 0, Zf },
            hasClass: function(t, e) { return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1 },
            getWidth: function(t) { t = getComputedStyle(t); return Yf(t["border-left-width"]) + Yf(t["border-right-width"]) + Yf(t["padding-left"]) + Yf(t["padding-right"]) + Yf(t.width) },
            getHeight: function(t) { t = getComputedStyle(t); return Yf(t["border-top-width"]) + Yf(t["border-bottom-width"]) + Yf(t["padding-top"]) + Yf(t["padding-bottom"]) + Yf(t.height) },
            getOffset: function(t) {
                var e = t,
                    n = { left: 0, top: 0 };
                if (e.offsetParent)
                    for (; n.left += e.offsetLeft, n.top += e.offsetTop, e = e.offsetParent, e;);
                return n
            },
            isActive: function(t) { return t === document.activeElement && (t.type || t.href) }
        },
        Jf = (tl(Kf, jf), nl(Kf, [{ key: "setValue", value: function(t) { t = Uf(Kf.prototype.__proto__ || Object.getPrototypeOf(Kf.prototype), "setValue", this).call(this, t); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), t } }, { key: "updateDisplay", value: function() { return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), Uf(Kf.prototype.__proto__ || Object.getPrototypeOf(Kf.prototype), "updateDisplay", this).call(this) } }]), Kf);

    function Kf(t, e) {
        Bf(this, Kf);
        var e = zf(this, (Kf.__proto__ || Object.getPrototypeOf(Kf)).call(this, t, e)),
            n = e;
        return e.__prev = e.getValue(), e.__checkbox = document.createElement("input"), e.__checkbox.setAttribute("type", "checkbox"), Zf.bind(e.__checkbox, "change", function() { n.setValue(!n.__prev) }, !1), e.domElement.appendChild(e.__checkbox), e.updateDisplay(), e
    }
    var Qf = (tl($f, jf), nl($f, [{ key: "setValue", value: function(t) { t = Uf($f.prototype.__proto__ || Object.getPrototypeOf($f.prototype), "setValue", this).call(this, t); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), t } }, { key: "updateDisplay", value: function() { return Zf.isActive(this.__select) ? this : (this.__select.value = this.getValue(), Uf($f.prototype.__proto__ || Object.getPrototypeOf($f.prototype), "updateDisplay", this).call(this)) } }]), $f);

    function $f(t, e, n) {
        Bf(this, $f);
        var r, e = zf(this, ($f.__proto__ || Object.getPrototypeOf($f)).call(this, t, e)),
            n = n,
            i = e;
        return e.__select = document.createElement("select"), Af.isArray(n) && (r = {}, Af.each(n, function(t) { r[t] = t }), n = r), Af.each(n, function(t, e) {
            var n = document.createElement("option");
            n.innerHTML = e, n.setAttribute("value", t), i.__select.appendChild(n)
        }), e.updateDisplay(), Zf.bind(e.__select, "change", function() {
            var t = this.options[this.selectedIndex].value;
            i.setValue(t)
        }), e.domElement.appendChild(e.__select), e
    }
    var tm = (tl(em, jf), nl(em, [{ key: "updateDisplay", value: function() { return Zf.isActive(this.__input) || (this.__input.value = this.getValue()), Uf(em.prototype.__proto__ || Object.getPrototypeOf(em.prototype), "updateDisplay", this).call(this) } }]), em);

    function em(t, e) {
        Bf(this, em);
        var e = zf(this, (em.__proto__ || Object.getPrototypeOf(em)).call(this, t, e)),
            n = e;

        function r() { n.setValue(n.__input.value) }
        return e.__input = document.createElement("input"), e.__input.setAttribute("type", "text"), Zf.bind(e.__input, "keyup", r), Zf.bind(e.__input, "change", r), Zf.bind(e.__input, "blur", function() { n.__onFinishChange && n.__onFinishChange.call(n, n.getValue()) }), Zf.bind(e.__input, "keydown", function(t) { 13 === t.keyCode && this.blur() }), e.updateDisplay(), e.domElement.appendChild(e.__input), e
    }

    function nm(t) { t = t.toString(); return -1 < t.indexOf(".") ? t.length - t.indexOf(".") - 1 : 0 }
    tl(rm, jf), nl(rm, [{ key: "setValue", value: function(t) { return void 0 !== this.__min && t < this.__min ? t = this.__min : void 0 !== this.__max && t > this.__max && (t = this.__max), void 0 !== this.__step && t % this.__step != 0 && (t = Math.round(t / this.__step) * this.__step), Uf(rm.prototype.__proto__ || Object.getPrototypeOf(rm.prototype), "setValue", this).call(this, t) } }, { key: "min", value: function(t) { return this.__min = t, this } }, { key: "max", value: function(t) { return this.__max = t, this } }, { key: "step", value: function(t) { return this.__step = t, this.__impliedStep = t, this.__precision = nm(t), this } }]), il = rm;

    function rm(t, e, n) {
        Bf(this, rm);
        e = zf(this, (rm.__proto__ || Object.getPrototypeOf(rm)).call(this, t, e)), n = n || {};
        return e.__min = n.min, e.__max = n.max, e.__step = n.step, Af.isUndefined(e.__step) ? 0 === e.initialValue ? e.__impliedStep = 1 : e.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(e.initialValue)) / Math.LN10)) / 10 : e.__impliedStep = e.__step, e.__precision = nm(e.__impliedStep), e
    }
    var im = (tl(om, il), nl(om, [{ key: "updateDisplay", value: function() { var t, e; return this.__input.value = this.__truncationSuspended ? this.getValue() : (t = this.getValue(), e = this.__precision, e = Math.pow(10, e), Math.round(t * e) / e), Uf(om.prototype.__proto__ || Object.getPrototypeOf(om.prototype), "updateDisplay", this).call(this) } }]), om);

    function om(t, e, n) {
        Bf(this, om);
        n = zf(this, (om.__proto__ || Object.getPrototypeOf(om)).call(this, t, e, n));
        n.__truncationSuspended = !1;
        var r = n,
            i = void 0;

        function o() { r.__onFinishChange && r.__onFinishChange.call(r, r.getValue()) }

        function a(t) {
            var e = i - t.clientY;
            r.setValue(r.getValue() + e * r.__impliedStep), i = t.clientY
        }

        function s() { Zf.unbind(window, "mousemove", a), Zf.unbind(window, "mouseup", s), o() }
        return n.__input = document.createElement("input"), n.__input.setAttribute("type", "text"), Zf.bind(n.__input, "change", function() {
            var t = parseFloat(r.__input.value);
            Af.isNaN(t) || r.setValue(t)
        }), Zf.bind(n.__input, "blur", function() { o() }), Zf.bind(n.__input, "mousedown", function(t) { Zf.bind(window, "mousemove", a), Zf.bind(window, "mouseup", s), i = t.clientY }), Zf.bind(n.__input, "keydown", function(t) { 13 === t.keyCode && (r.__truncationSuspended = !0, this.blur(), r.__truncationSuspended = !1, o()) }), n.updateDisplay(), n.domElement.appendChild(n.__input), n
    }

    function am(t, e, n, r, i) { return r + (t - e) / (n - e) * (i - r) }
    var sm = (tl(cm, il), nl(cm, [{ key: "updateDisplay", value: function() { var t = (this.getValue() - this.__min) / (this.__max - this.__min); return this.__foreground.style.width = 100 * t + "%", Uf(cm.prototype.__proto__ || Object.getPrototypeOf(cm.prototype), "updateDisplay", this).call(this) } }]), cm);

    function cm(t, e, n, r, i) {
        Bf(this, cm);
        var i = zf(this, (cm.__proto__ || Object.getPrototypeOf(cm)).call(this, t, e, { min: n, max: r, step: i })),
            o = i;

        function a(t) { t.preventDefault(); var e = o.__background.getBoundingClientRect(); return o.setValue(am(t.clientX, e.left, e.right, o.__min, o.__max)), !1 }

        function s() { Zf.unbind(window, "mousemove", a), Zf.unbind(window, "mouseup", s), o.__onFinishChange && o.__onFinishChange.call(o, o.getValue()) }

        function c(t) {
            var e = t.touches[0].clientX,
                t = o.__background.getBoundingClientRect();
            o.setValue(am(e, t.left, t.right, o.__min, o.__max))
        }

        function l() { Zf.unbind(window, "touchmove", c), Zf.unbind(window, "touchend", l), o.__onFinishChange && o.__onFinishChange.call(o, o.getValue()) }
        return i.__background = document.createElement("div"), i.__foreground = document.createElement("div"), Zf.bind(i.__background, "mousedown", function(t) { document.activeElement.blur(), Zf.bind(window, "mousemove", a), Zf.bind(window, "mouseup", s), a(t) }), Zf.bind(i.__background, "touchstart", function(t) {
            if (1 !== t.touches.length) return;
            Zf.bind(window, "touchmove", c), Zf.bind(window, "touchend", l), c(t)
        }), Zf.addClass(i.__background, "slider"), Zf.addClass(i.__foreground, "slider-fg"), i.updateDisplay(), i.__background.appendChild(i.__foreground), i.domElement.appendChild(i.__background), i
    }
    var lm = (tl(um, jf), nl(um, [{ key: "fire", value: function() { this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()) } }]), um);

    function um(t, e, n) {
        Bf(this, um);
        var e = zf(this, (um.__proto__ || Object.getPrototypeOf(um)).call(this, t, e)),
            r = e;
        return e.__button = document.createElement("div"), e.__button.innerHTML = void 0 === n ? "Fire" : n, Zf.bind(e.__button, "click", function(t) { return t.preventDefault(), r.fire(), !1 }), Zf.addClass(e.__button, "button"), e.domElement.appendChild(e.__button), e
    }
    var hm = (tl(pm, jf), nl(pm, [{
        key: "updateDisplay",
        value: function() {
            var e, n = If(this.getValue());
            !1 !== n && (e = !1, Af.each(Hf.COMPONENTS, function(t) { if (!Af.isUndefined(n[t]) && !Af.isUndefined(this.__color.__state[t]) && n[t] !== this.__color.__state[t]) return e = !0, {} }, this), e && Af.extend(this.__color.__state, n)), Af.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
            var t = this.__color.v < .5 || .5 < this.__color.s ? 255 : 0,
                r = 255 - t;
            Af.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + t + "," + t + "," + t + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, fm(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), Af.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + t + "," + t + "," + t + ")", textShadow: this.__input_textShadow + "rgba(" + r + "," + r + "," + r + ",.7)" })
        }
    }]), pm);

    function pm(t, e) {
        Bf(this, pm);
        var n = zf(this, (pm.__proto__ || Object.getPrototypeOf(pm)).call(this, t, e));
        n.__color = new Hf(n.getValue()), n.__temp = new Hf(0);
        var r = n;
        n.domElement = document.createElement("div"), Zf.makeSelectable(n.domElement, !1), n.__selector = document.createElement("div"), n.__selector.className = "selector", n.__saturation_field = document.createElement("div"), n.__saturation_field.className = "saturation-field", n.__field_knob = document.createElement("div"), n.__field_knob.className = "field-knob", n.__field_knob_border = "2px solid ", n.__hue_knob = document.createElement("div"), n.__hue_knob.className = "hue-knob", n.__hue_field = document.createElement("div"), n.__hue_field.className = "hue-field", n.__input = document.createElement("input"), n.__input.type = "text", n.__input_textShadow = "0 1px 1px ", Zf.bind(n.__input, "keydown", function(t) { 13 === t.keyCode && c.call(this) }), Zf.bind(n.__input, "blur", c), Zf.bind(n.__selector, "mousedown", function() { Zf.addClass(this, "drag").bind(window, "mouseup", function() { Zf.removeClass(r.__selector, "drag") }) }), Zf.bind(n.__selector, "touchstart", function() { Zf.addClass(this, "drag").bind(window, "touchend", function() { Zf.removeClass(r.__selector, "drag") }) });
        t = document.createElement("div");

        function i(t) { u(t), Zf.bind(window, "mousemove", u), Zf.bind(window, "touchmove", u), Zf.bind(window, "mouseup", a), Zf.bind(window, "touchend", a) }

        function o(t) { h(t), Zf.bind(window, "mousemove", h), Zf.bind(window, "touchmove", h), Zf.bind(window, "mouseup", s), Zf.bind(window, "touchend", s) }

        function a() { Zf.unbind(window, "mousemove", u), Zf.unbind(window, "touchmove", u), Zf.unbind(window, "mouseup", a), Zf.unbind(window, "touchend", a), l() }

        function s() { Zf.unbind(window, "mousemove", h), Zf.unbind(window, "touchmove", h), Zf.unbind(window, "mouseup", s), Zf.unbind(window, "touchend", s), l() }

        function c() { var t = If(this.value);!1 !== t ? (r.__color.__state = t, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString() }

        function l() { r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal()) }

        function u(t) {
            -1 === t.type.indexOf("touch") && t.preventDefault();
            var e = r.__saturation_field.getBoundingClientRect(),
                n = t.touches && t.touches[0] || t,
                t = n.clientX,
                n = n.clientY,
                t = (t - e.left) / (e.right - e.left),
                e = 1 - (n - e.top) / (e.bottom - e.top);
            return 1 < e ? e = 1 : e < 0 && (e = 0), 1 < t ? t = 1 : t < 0 && (t = 0), r.__color.v = e, r.__color.s = t, r.setValue(r.__color.toOriginal()), !1
        }

        function h(t) {
            -1 === t.type.indexOf("touch") && t.preventDefault();
            var e = r.__hue_field.getBoundingClientRect(),
                e = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
            return 1 < e ? e = 1 : e < 0 && (e = 0), r.__color.h = 360 * e, r.setValue(r.__color.toOriginal()), !1
        }
        return Af.extend(n.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), Af.extend(n.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: n.__field_knob_border + (n.__color.v < .5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), Af.extend(n.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), Af.extend(n.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), Af.extend(t.style, { width: "100%", height: "100%", background: "none" }), fm(t, "top", "rgba(0,0,0,0)", "#000"), Af.extend(n.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (e = n.__hue_field).style.background = "", e.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", e.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", Af.extend(n.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: n.__input_textShadow + "rgba(0,0,0,0.7)" }), Zf.bind(n.__saturation_field, "mousedown", i), Zf.bind(n.__saturation_field, "touchstart", i), Zf.bind(n.__field_knob, "mousedown", i), Zf.bind(n.__field_knob, "touchstart", i), Zf.bind(n.__hue_field, "mousedown", o), Zf.bind(n.__hue_field, "touchstart", o), n.__saturation_field.appendChild(t), n.__selector.appendChild(n.__field_knob), n.__selector.appendChild(n.__saturation_field), n.__selector.appendChild(n.__hue_field), n.__hue_field.appendChild(n.__hue_knob), n.domElement.appendChild(n.__input), n.domElement.appendChild(n.__selector), n.updateDisplay(), n
    }
    var dm = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

    function fm(e, n, r, i) { e.style.background = "", Af.each(dm, function(t) { e.style.cssText += "background: " + t + "linear-gradient(" + n + ", " + r + " 0%, " + i + " 100%); " }) }
    var tl = function(t, e) {
            var e = e || document,
                n = document.createElement("style");
            n.type = "text/css", n.innerHTML = t;
            var r = e.getElementsByTagName("head")[0];
            try { r.appendChild(n) } catch (t) {}
        },
        mm = function(t, e, n, r, i) { var o = t[e]; return Af.isArray(n) || Af.isObject(n) ? new Qf(t, e, n) : Af.isNumber(o) ? Af.isNumber(n) && Af.isNumber(r) ? Af.isNumber(i) ? new sm(t, e, n, r, i) : new sm(t, e, n, r) : Af.isNumber(i) ? new im(t, e, { min: n, max: r, step: i }) : new im(t, e, { min: n, max: r }) : Af.isString(o) ? new tm(t, e) : Af.isFunction(o) ? new lm(t, e, "") : Af.isBoolean(o) ? new Jf(t, e) : null };
    var gm = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) { setTimeout(t, 1e3 / 60) },
        vm = (nl(ym, [{
            key: "show",
            value: function() {
                var t = this;
                this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), Af.defer(function() { t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)" })
            }
        }, {
            key: "hide",
            value: function() {
                function t() { e.domElement.style.display = "none", e.backgroundElement.style.display = "none", Zf.unbind(e.domElement, "webkitTransitionEnd", t), Zf.unbind(e.domElement, "transitionend", t), Zf.unbind(e.domElement, "oTransitionEnd", t) }
                var e = this;
                Zf.bind(this.domElement, "webkitTransitionEnd", t), Zf.bind(this.domElement, "transitionend", t), Zf.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
            }
        }, { key: "layout", value: function() { this.domElement.style.left = window.innerWidth / 2 - Zf.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - Zf.getHeight(this.domElement) / 2 + "px" } }]), ym);

    function ym() {
        Bf(this, ym), this.backgroundElement = document.createElement("div"), Af.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), Zf.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), Af.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
        var t = this;
        Zf.bind(this.backgroundElement, "click", function() { t.hide() })
    }
    tl(function(t) { if (t && "undefined" != typeof window) { var e = document.createElement("style"); return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t } }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
    var _m = "Default",
        xm = function() { try { return !!window.localStorage } catch (t) { return !1 } }(),
        bm = void 0,
        wm = !0,
        Mm = void 0,
        Sm = !1,
        Em = [],
        Tm = function e(t) {
            var n = this,
                r = t || {};
            this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), Zf.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], r = Af.defaults(r, { closeOnTop: !1, autoPlace: !0, width: e.DEFAULT_WIDTH }), r = Af.defaults(r, { resizable: r.autoPlace, hideable: r.autoPlace }), Af.isUndefined(r.load) ? r.load = { preset: _m } : r.preset && (r.load.preset = r.preset), Af.isUndefined(r.parent) && r.hideable && Em.push(this), r.resizable = Af.isUndefined(r.parent) && r.resizable, r.autoPlace && Af.isUndefined(r.scrollable) && (r.scrollable = !0);
            var i, o, a, s, c = xm && "true" === localStorage.getItem(Om(0, "isLocal")),
                l = void 0,
                u = void 0;

            function h(t) { return t.preventDefault(), o.width += a - t.clientX, o.onResize(), a = t.clientX, !1 }

            function p() { Zf.removeClass(o.__closeButton, Tm.CLASS_DRAG), Zf.unbind(window, "mousemove", h), Zf.unbind(window, "mouseup", p) }

            function d(t) { return t.preventDefault(), a = t.clientX, Zf.addClass(o.__closeButton, Tm.CLASS_DRAG), Zf.bind(window, "mousemove", h), Zf.bind(window, "mouseup", p), !1 }
            Object.defineProperties(this, {
                parent: { get: function() { return r.parent } },
                scrollable: { get: function() { return r.scrollable } },
                autoPlace: { get: function() { return r.autoPlace } },
                closeOnTop: { get: function() { return r.closeOnTop } },
                preset: {
                    get: function() { return (n.parent ? n.getRoot() : r.load).preset },
                    set: function(t) {
                        n.parent ? n.getRoot().preset = t : r.load.preset = t,
                            function(t) { for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e) }(this), n.revert()
                    }
                },
                width: { get: function() { return r.width }, set: function(t) { r.width = t, Nm(n, t) } },
                name: { get: function() { return r.name }, set: function(t) { r.name = t, u && (u.innerHTML = r.name) } },
                closed: { get: function() { return r.closed }, set: function(t) { r.closed = t, r.closed ? Zf.addClass(n.__ul, e.CLASS_CLOSED) : Zf.removeClass(n.__ul, e.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED) } },
                load: { get: function() { return r.load } },
                useLocalStorage: { get: function() { return c }, set: function(t) { xm && ((c = t) ? Zf.bind(window, "unload", l) : Zf.unbind(window, "unload", l), localStorage.setItem(Om(0, "isLocal"), t)) } }
            }), Af.isUndefined(r.parent) ? (this.closed = r.closed || !1, Zf.addClass(this.domElement, e.CLASS_MAIN), Zf.makeSelectable(this.domElement, !1), xm && c && (n.useLocalStorage = !0, (i = localStorage.getItem(Om(0, "gui"))) && (r.load = JSON.parse(i))), this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = e.TEXT_CLOSED, Zf.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON), r.closeOnTop ? (Zf.addClass(this.__closeButton, e.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Zf.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), Zf.bind(this.__closeButton, "click", function() { n.closed = !n.closed })) : (void 0 === r.closed && (r.closed = !0), i = document.createTextNode(r.name), Zf.addClass(i, "controller-name"), u = Am(n, i), Zf.addClass(this.__ul, e.CLASS_CLOSED), Zf.addClass(u, "title"), Zf.bind(u, "click", function(t) { return t.preventDefault(), n.closed = !n.closed, !1 }), r.closed || (this.closed = !1)), r.autoPlace && (Af.isUndefined(r.parent) && (wm && (Mm = document.createElement("div"), Zf.addClass(Mm, "dg"), Zf.addClass(Mm, e.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Mm), wm = !1), Mm.appendChild(this.domElement), Zf.addClass(this.domElement, e.CLASS_AUTO_PLACE)), this.parent || Nm(n, r.width)), this.__resizeHandler = function() { n.onResizeDebounced() }, Zf.bind(window, "resize", this.__resizeHandler), Zf.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), Zf.bind(this.__ul, "transitionend", this.__resizeHandler), Zf.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), r.resizable && (a = void 0, (o = this).__resize_handle = document.createElement("div"), Af.extend(o.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), Zf.bind(o.__resize_handle, "mousedown", d), Zf.bind(o.__closeButton, "mousedown", d), o.domElement.insertBefore(o.__resize_handle, o.domElement.firstElementChild)), l = function() { xm && "true" === localStorage.getItem(Om(0, "isLocal")) && localStorage.setItem(Om(0, "gui"), JSON.stringify(n.getSaveObject())) }, this.saveToLocalStorageIfPossible = l, r.parent || ((s = n.getRoot()).width += 1, Af.defer(function() {--s.width }))
        };

    function Am(t, e, n) { var r = document.createElement("li"); return e && r.appendChild(e), n ? t.__ul.insertBefore(r, n) : t.__ul.appendChild(r), t.onResize(), r }

    function Lm(t) { Zf.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && Zf.unbind(window, "unload", t.saveToLocalStorageIfPossible) }

    function Rm(t, e) {
        t = t.__preset_select[t.__preset_select.selectedIndex];
        t.innerHTML = e ? t.value + "*" : t.value
    }

    function Cm(t, e) {
        var n = t.getRoot(),
            r = n.__rememberedObjects.indexOf(e.object);
        if (-1 !== r) {
            var i = n.__rememberedObjectIndecesToControllers[r];
            if (void 0 === i && (i = {}, n.__rememberedObjectIndecesToControllers[r] = i), i[e.property] = e, n.load && n.load.remembered) {
                i = n.load.remembered, n = void 0;
                if (i[t.preset]) n = i[t.preset];
                else {
                    if (!i[_m]) return;
                    n = i[_m]
                }
                n[r] && void 0 !== n[r][e.property] && (r = n[r][e.property], e.initialValue = r, e.setValue(r))
            }
        }
    }

    function Pm(t, e, n, r) {
        if (void 0 === e[n]) throw new Error('Object "' + e + '" has no property "' + n + '"');
        var i = void 0;
        i = r.color ? new hm(e, n) : (o = [e, n].concat(r.factoryArgs), mm.apply(t, o)), r.before instanceof jf && (r.before = r.before.__li), Cm(t, i), Zf.addClass(i.domElement, "c");
        n = document.createElement("span");
        Zf.addClass(n, "property-name"), n.innerHTML = i.property;
        var o = document.createElement("div");
        o.appendChild(n), o.appendChild(i.domElement);
        var a, s, c, l, r = Am(t, o, r.before);
        return Zf.addClass(r, Tm.CLASS_CONTROLLER_ROW), i instanceof hm ? Zf.addClass(r, "color") : Zf.addClass(r, Nf(i.getValue())), a = t, s = r, (c = i).__li = s, c.__gui = a, Af.extend(c, { options: function(t) { if (1 < arguments.length) { var e = c.__li.nextElementSibling; return c.remove(), Pm(a, c.object, c.property, { before: e, factoryArgs: [Af.toArray(arguments)] }) } if (Af.isArray(t) || Af.isObject(t)) { e = c.__li.nextElementSibling; return c.remove(), Pm(a, c.object, c.property, { before: e, factoryArgs: [t] }) } }, name: function(t) { return c.__li.firstElementChild.firstElementChild.innerHTML = t, c }, listen: function() { return c.__gui.listen(c), c }, remove: function() { return c.__gui.remove(c), c } }), c instanceof sm ? (l = new im(c.object, c.property, { min: c.__min, max: c.__max, step: c.__step }), Af.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(t) {
            var e = c[t],
                n = l[t];
            c[t] = l[t] = function() { var t = Array.prototype.slice.call(arguments); return n.apply(l, t), e.apply(c, t) }
        }), Zf.addClass(s, "has-slider"), c.domElement.insertBefore(l.domElement, c.domElement.firstElementChild)) : c instanceof im ? (r = function(t) {
            if (Af.isNumber(c.__min) && Af.isNumber(c.__max)) {
                var e = c.__li.firstElementChild.firstElementChild.innerHTML,
                    n = -1 < c.__gui.__listening.indexOf(c);
                c.remove();
                var r = Pm(a, c.object, c.property, { before: c.__li.nextElementSibling, factoryArgs: [c.__min, c.__max, c.__step] });
                return r.name(e), n && r.listen(), r
            }
            return t
        }, c.min = Af.compose(r, c.min), c.max = Af.compose(r, c.max)) : c instanceof Jf ? (Zf.bind(s, "click", function() { Zf.fakeEvent(c.__checkbox, "click") }), Zf.bind(c.__checkbox, "click", function(t) { t.stopPropagation() })) : c instanceof lm ? (Zf.bind(s, "click", function() { Zf.fakeEvent(c.__button, "click") }), Zf.bind(s, "mouseover", function() { Zf.addClass(c.__button, "hover") }), Zf.bind(s, "mouseout", function() { Zf.removeClass(c.__button, "hover") })) : c instanceof hm && (Zf.addClass(s, "color"), c.updateDisplay = Af.compose(function(t) { return s.style.borderLeftColor = c.__color.toString(), t }, c.updateDisplay), c.updateDisplay()), c.setValue = Af.compose(function(t) { return a.getRoot().__preset_select && c.isModified() && Rm(a.getRoot(), !0), t }, c.setValue), t.__controllers.push(i), i
    }

    function Om(t, e) { return document.location.href + "." + e }

    function Im(t, e, n) {
        var r = document.createElement("option");
        r.innerHTML = e, r.value = e, t.__preset_select.appendChild(r), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
    }

    function Dm(t, e) { e.style.display = t.useLocalStorage ? "block" : "none" }

    function Nm(t, e) { t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px") }

    function Bm(i, o) {
        var a = {};
        return Af.each(i.__rememberedObjects, function(t, e) {
            var n = {},
                r = i.__rememberedObjectIndecesToControllers[e];
            Af.each(r, function(t, e) { n[e] = o ? t.initialValue : t.getValue() }), a[e] = n
        }), a
    }
    Tm.toggleHide = function() { Sm = !Sm, Af.each(Em, function(t) { t.domElement.style.display = Sm ? "none" : "" }) }, Tm.CLASS_AUTO_PLACE = "a", Tm.CLASS_AUTO_PLACE_CONTAINER = "ac", Tm.CLASS_MAIN = "main", Tm.CLASS_CONTROLLER_ROW = "cr", Tm.CLASS_TOO_TALL = "taller-than-window", Tm.CLASS_CLOSED = "closed", Tm.CLASS_CLOSE_BUTTON = "close-button", Tm.CLASS_CLOSE_TOP = "close-top", Tm.CLASS_CLOSE_BOTTOM = "close-bottom", Tm.CLASS_DRAG = "drag", Tm.DEFAULT_WIDTH = 245, Tm.TEXT_CLOSED = "Close Controls", Tm.TEXT_OPEN = "Open Controls", Tm._keydownHandler = function(t) { "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || Tm.toggleHide() }, Zf.bind(window, "keydown", Tm._keydownHandler, !1), Af.extend(Tm.prototype, {
        add: function(t, e) { return Pm(this, t, e, { factoryArgs: Array.prototype.slice.call(arguments, 2) }) },
        addColor: function(t, e) { return Pm(this, t, e, { color: !0 }) },
        remove: function(t) {
            this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
            var e = this;
            Af.defer(function() { e.onResize() })
        },
        destroy: function() {
            if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
            this.autoPlace && Mm.removeChild(this.domElement);
            var e = this;
            Af.each(this.__folders, function(t) { e.removeFolder(t) }), Zf.unbind(window, "keydown", Tm._keydownHandler, !1), Lm(this)
        },
        addFolder: function(t) {
            if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
            var e = { name: t, parent: this };
            e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
            e = new Tm(e);
            this.__folders[t] = e;
            t = Am(this, e.domElement);
            return Zf.addClass(t, "folder"), e
        },
        removeFolder: function(e) {
            this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], Lm(e);
            var t = this;
            Af.each(e.__folders, function(t) { e.removeFolder(t) }), Af.defer(function() { t.onResize() })
        },
        open: function() { this.closed = !1 },
        close: function() { this.closed = !0 },
        hide: function() { this.domElement.style.display = "none" },
        show: function() { this.domElement.style.display = "" },
        onResize: function() {
            var t, e, n = this.getRoot();
            n.scrollable && (t = Zf.getOffset(n.__ul).top, e = 0, Af.each(n.__ul.childNodes, function(t) { n.autoPlace && t === n.__save_row || (e += Zf.getHeight(t)) }), window.innerHeight - t - 20 < e ? (Zf.addClass(n.domElement, Tm.CLASS_TOO_TALL), n.__ul.style.height = window.innerHeight - t - 20 + "px") : (Zf.removeClass(n.domElement, Tm.CLASS_TOO_TALL), n.__ul.style.height = "auto")), n.__resize_handle && Af.defer(function() { n.__resize_handle.style.height = n.__ul.offsetHeight + "px" }), n.__closeButton && (n.__closeButton.style.width = n.width + "px")
        },
        onResizeDebounced: Af.debounce(function() { this.onResize() }, 50),
        remember: function() {
            if (Af.isUndefined(bm) && ((bm = new vm).domElement.innerHTML = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'), this.parent) throw new Error("You can only call remember on a top level GUI.");
            var e = this;
            Af.each(Array.prototype.slice.call(arguments), function(t) {
                0 === e.__rememberedObjects.length && function(n) {
                    var t = n.__save_row = document.createElement("li");
                    Zf.addClass(n.domElement, "has-save"), n.__ul.insertBefore(t, n.__ul.firstChild), Zf.addClass(t, "save-row");
                    var e = document.createElement("span");
                    e.innerHTML = "&nbsp;", Zf.addClass(e, "button gears");
                    var r = document.createElement("span");
                    r.innerHTML = "Save", Zf.addClass(r, "button"), Zf.addClass(r, "save");
                    var i = document.createElement("span");
                    i.innerHTML = "New", Zf.addClass(i, "button"), Zf.addClass(i, "save-as");
                    var o = document.createElement("span");
                    o.innerHTML = "Revert", Zf.addClass(o, "button"), Zf.addClass(o, "revert");
                    var a = n.__preset_select = document.createElement("select");
                    n.load && n.load.remembered ? Af.each(n.load.remembered, function(t, e) { Im(n, e, e === n.preset) }) : Im(n, _m, !1); {
                        var s;
                        Zf.bind(a, "change", function() {
                            for (var t = 0; t < n.__preset_select.length; t++) n.__preset_select[t].innerHTML = n.__preset_select[t].value;
                            n.preset = this.value
                        }), t.appendChild(a), t.appendChild(e), t.appendChild(r), t.appendChild(i), t.appendChild(o), xm && (s = document.getElementById("dg-local-explain"), t = document.getElementById("dg-local-storage"), document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(Om(0, "isLocal")) && t.setAttribute("checked", "checked"), Dm(n, s), Zf.bind(t, "change", function() { n.useLocalStorage = !n.useLocalStorage, Dm(n, s) }))
                    }
                    var c = document.getElementById("dg-new-constructor");
                    Zf.bind(c, "keydown", function(t) {!t.metaKey || 67 !== t.which && 67 !== t.keyCode || bm.hide() }), Zf.bind(e, "click", function() { c.innerHTML = JSON.stringify(n.getSaveObject(), void 0, 2), bm.show(), c.focus(), c.select() }), Zf.bind(r, "click", function() { n.save() }), Zf.bind(i, "click", function() {
                        var t = prompt("Enter a new preset name.");
                        t && n.saveAs(t)
                    }), Zf.bind(o, "click", function() { n.revert() })
                }(e), -1 === e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t)
            }), this.autoPlace && Nm(this, this.width)
        },
        getRoot: function() { for (var t = this; t.parent;) t = t.parent; return t },
        getSaveObject: function() { var n = this.load; return n.closed = this.closed, 0 < this.__rememberedObjects.length && (n.preset = this.preset, n.remembered || (n.remembered = {}), n.remembered[this.preset] = Bm(this)), n.folders = {}, Af.each(this.__folders, function(t, e) { n.folders[e] = t.getSaveObject() }), n },
        save: function() { this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = Bm(this), Rm(this, !1), this.saveToLocalStorageIfPossible() },
        saveAs: function(t) { this.load.remembered || (this.load.remembered = {}, this.load.remembered[_m] = Bm(this, !0)), this.load.remembered[t] = Bm(this), this.preset = t, Im(this, t, !0), this.saveToLocalStorageIfPossible() },
        revert: function(e) { Af.each(this.__controllers, function(t) { this.getRoot().load.remembered ? Cm(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue()) }, this), Af.each(this.__folders, function(t) { t.revert(t) }), e || Rm(this.getRoot(), !1) },
        listen: function(t) {
            var e = 0 === this.__listening.length;
            this.__listening.push(t), e && function t(e) {
                0 !== e.length && gm.call(window, function() { t(e) });
                Af.each(e, function(t) { t.updateDisplay() })
            }(this.__listening)
        },
        updateDisplay: function() { Af.each(this.__controllers, function(t) { t.updateDisplay() }), Af.each(this.__folders, function(t) { t.updateDisplay() }) }
    });
    var nl = Tm,
        Fm = (document.querySelector(".log"), new nl({ name: "gui" }));
    Fm.domElement.parentNode.id = "gui";

    function Um(t) { Su.call(this, t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } }
    var zm = { canRender: !0, fps: 60 },
        Hm = document.querySelector(".scroll-area"),
        tl = document.querySelector(".menu"),
        km = document.querySelector(".pages"),
        Gm = document.querySelector(".logo"),
        Vm = (document.querySelectorAll(".logo"), document.querySelector(".arrow-intro")),
        jm = document.getElementById("toggleMenu"),
        Wm = document.querySelector(".menu-overlay"),
        qm = document.getElementById("closeActivePageButton"),
        Xm = document.getElementById("campagneVideo"),
        Ym = document.getElementById("entretienVideo"),
        Zm = document.querySelector(".loading"),
        Jm = document.querySelector(".loading-progress-bar"),
        Km = document.querySelector(".loading-progress-count"),
        Qm = document.getElementById("downloadLink"),
        $m = function() {
            function t(t) { Su.call(this, t), this.dracoLoader = null, this.ddsLoader = null }

            function r() { var n = {}; return { get: function(t) { return n[t] }, add: function(t, e) { n[t] = e }, remove: function(t) { delete n[t] }, removeAll: function() { n = {} } } }
            t.prototype = Object.assign(Object.create(Su.prototype), {
                constructor: t,
                load: function(e, n, t, r) {
                    var i = this,
                        o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : vh.extractUrlBase(e);
                    i.manager.itemStart(e);

                    function a(t) { r ? r(t) : console.error(t), i.manager.itemError(e), i.manager.itemEnd(e) }
                    var s = new Tu(i.manager);
                    s.setPath(this.path), s.setResponseType("arraybuffer"), "use-credentials" === i.crossOrigin && s.setWithCredentials(!0), s.load(e, function(t) { try { i.parse(t, o, function(t) { n(t), i.manager.itemEnd(e) }, a) } catch (t) { a(t) } }, t, a)
                },
                setDRACOLoader: function(t) { return this.dracoLoader = t, this },
                setDDSLoader: function(t) { return this.ddsLoader = t, this },
                parse: function(t, e, n, r) {
                    var i, o = {};
                    if ("string" == typeof t) i = t;
                    else if (vh.decodeText(new Uint8Array(t, 0, 4)) === m) {
                        try { o[h.KHR_BINARY_GLTF] = new g(t) } catch (t) { return void(r && r(t)) }
                        i = o[h.KHR_BINARY_GLTF].content
                    } else i = vh.decodeText(new Uint8Array(t));
                    var a = JSON.parse(i);
                    if (void 0 === a.asset || a.asset.version[0] < 2) r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    else {
                        if (a.extensionsUsed)
                            for (var s = 0; s < a.extensionsUsed.length; ++s) {
                                var c = a.extensionsUsed[s],
                                    l = a.extensionsRequired || [];
                                switch (c) {
                                    case h.KHR_LIGHTS_PUNCTUAL:
                                        o[c] = new p(a);
                                        break;
                                    case h.KHR_MATERIALS_CLEARCOAT:
                                        o[c] = new f;
                                        break;
                                    case h.KHR_MATERIALS_UNLIT:
                                        o[c] = new d;
                                        break;
                                    case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        o[c] = new _;
                                        break;
                                    case h.KHR_DRACO_MESH_COMPRESSION:
                                        o[c] = new v(a, this.dracoLoader);
                                        break;
                                    case h.MSFT_TEXTURE_DDS:
                                        o[c] = new u(this.ddsLoader);
                                        break;
                                    case h.KHR_TEXTURE_TRANSFORM:
                                        o[c] = new y;
                                        break;
                                    case h.KHR_MESH_QUANTIZATION:
                                        o[c] = new x;
                                        break;
                                    default:
                                        0 <= l.indexOf(c) && console.warn('THREE.GLTFLoader: Unknown extension "' + c + '".')
                                }
                            }
                        new j(a, o, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, manager: this.manager }).parse(n, r)
                    }
                }
            });
            var h = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", MSFT_TEXTURE_DDS: "MSFT_texture_dds" };

            function u(t) {
                if (!t) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
                this.name = h.MSFT_TEXTURE_DDS, this.ddsLoader = t
            }

            function p(t) {
                this.name = h.KHR_LIGHTS_PUNCTUAL;
                t = t.extensions && t.extensions[h.KHR_LIGHTS_PUNCTUAL] || {};
                this.lightDefs = t.lights || []
            }

            function d() { this.name = h.KHR_MATERIALS_UNLIT }

            function f() { this.name = h.KHR_MATERIALS_CLEARCOAT }
            p.prototype.loadLight = function(t) {
                var e, n = this.lightDefs[t],
                    r = new li(16777215);
                void 0 !== n.color && r.fromArray(n.color);
                var i = void 0 !== n.range ? n.range : 0;
                switch (n.type) {
                    case "directional":
                        (e = new hh(r)).target.position.set(0, 0, -1), e.add(e.target);
                        break;
                    case "point":
                        (e = new ch(r)).distance = i;
                        break;
                    case "spot":
                        (e = new ah(r)).distance = i, n.spot = n.spot || {}, n.spot.innerConeAngle = void 0 !== n.spot.innerConeAngle ? n.spot.innerConeAngle : 0, n.spot.outerConeAngle = void 0 !== n.spot.outerConeAngle ? n.spot.outerConeAngle : Math.PI / 4, e.angle = n.spot.outerConeAngle, e.penumbra = 1 - n.spot.innerConeAngle / n.spot.outerConeAngle, e.target.position.set(0, 0, -1), e.add(e.target);
                        break;
                    default:
                        throw new Error('THREE.GLTFLoader: Unexpected light type, "' + n.type + '".')
                }
                return e.position.set(0, 0, 0), e.decay = 2, void 0 !== n.intensity && (e.intensity = n.intensity), e.name = n.name || "light_" + t, Promise.resolve(e)
            }, d.prototype.getMaterialType = function() { return di }, d.prototype.extendParams = function(t, e, n) {
                var r = [];
                t.color = new li(1, 1, 1), t.opacity = 1;
                var i = e.pbrMetallicRoughness;
                return i && (Array.isArray(i.baseColorFactor) && (e = i.baseColorFactor, t.color.fromArray(e), t.opacity = e[3]), void 0 !== i.baseColorTexture && r.push(n.assignTexture(t, "map", i.baseColorTexture))), Promise.all(r)
            }, f.prototype.getMaterialType = function() { return Ql }, f.prototype.extendParams = function(t, e, n) {
                var r = [],
                    e = e.extensions[this.name];
                return void 0 !== e.clearcoatFactor && (t.clearcoat = e.clearcoatFactor), void 0 !== e.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", e.clearcoatTexture)), void 0 !== e.clearcoatRoughnessFactor && (t.clearcoatRoughness = e.clearcoatRoughnessFactor), void 0 !== e.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", e.clearcoatRoughnessTexture)), void 0 !== e.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", e.clearcoatNormalTexture)), void 0 !== e.clearcoatNormalTexture.scale && (e = e.clearcoatNormalTexture.scale, t.clearcoatNormalScale = new Ln(e, e))), Promise.all(r)
            };
            var m = "glTF",
                s = 12,
                c = { JSON: 1313821514, BIN: 5130562 };

            function g(t) {
                this.name = h.KHR_BINARY_GLTF, this.content = null, this.body = null;
                var e = new DataView(t, 0, s);
                if (this.header = { magic: vh.decodeText(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, !0), length: e.getUint32(8, !0) }, this.header.magic !== m) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                for (var n = new DataView(t, s), r = 0; r < n.byteLength;) {
                    var i = n.getUint32(r, !0);
                    r += 4;
                    var o, a = n.getUint32(r, !0);
                    r += 4, a === c.JSON ? (o = new Uint8Array(t, s + r, i), this.content = vh.decodeText(o)) : a === c.BIN && (a = s + r, this.body = t.slice(a, a + i)), r += i
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }

            function v(t, e) {
                if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = h.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
            }

            function y() { this.name = h.KHR_TEXTURE_TRANSFORM }

            function l(t) {
                Kl.call(this), this.isGLTFSpecularGlossinessMaterial = !0;
                var n = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                    r = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                    i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                    o = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                    a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"),
                    s = { specular: { value: (new li).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
                this._extraUniforms = s, this.onBeforeCompile = function(t) {
                    for (var e in s) t.uniforms[e] = s[e];
                    t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;"), t.fragmentShader = t.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;"), t.fragmentShader = t.fragmentShader.replace("#include <roughnessmap_pars_fragment>", n), t.fragmentShader = t.fragmentShader.replace("#include <metalnessmap_pars_fragment>", r), t.fragmentShader = t.fragmentShader.replace("#include <roughnessmap_fragment>", i), t.fragmentShader = t.fragmentShader.replace("#include <metalnessmap_fragment>", o), t.fragmentShader = t.fragmentShader.replace("#include <lights_physical_fragment>", a)
                }, Object.defineProperties(this, {
                    specular: { get: function() { return s.specular.value }, set: function(t) { s.specular.value = t } },
                    specularMap: { get: function() { return s.specularMap.value }, set: function(t) { s.specularMap.value = t } },
                    glossiness: { get: function() { return s.glossiness.value }, set: function(t) { s.glossiness.value = t } },
                    glossinessMap: {
                        get: function() { return s.glossinessMap.value },
                        set: function(t) {
                            (s.glossinessMap.value = t) ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_ROUGHNESSMAP = "") : (delete this.defines.USE_ROUGHNESSMAP, delete this.defines.USE_GLOSSINESSMAP)
                        }
                    }
                }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
            }

            function _() {
                return {
                    name: h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                    specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                    getMaterialType: function() { return l },
                    extendParams: function(t, e, n) {
                        var r = e.extensions[this.name];
                        t.color = new li(1, 1, 1), t.opacity = 1;
                        var i = [];
                        return Array.isArray(r.diffuseFactor) && (e = r.diffuseFactor, t.color.fromArray(e), t.opacity = e[3]), void 0 !== r.diffuseTexture && i.push(n.assignTexture(t, "map", r.diffuseTexture)), t.emissive = new li(0, 0, 0), t.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, t.specular = new li(1, 1, 1), Array.isArray(r.specularFactor) && t.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture && (r = r.specularGlossinessTexture, i.push(n.assignTexture(t, "glossinessMap", r)), i.push(n.assignTexture(t, "specularMap", r))), Promise.all(i)
                    },
                    createMaterial: function(t) { var e = new l(t); return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = gn, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e }
                }
            }

            function x() { this.name = h.KHR_MESH_QUANTIZATION }

            function T(t, e, n, r) { su.call(this, t, e, n, r) }
            v.prototype.decodePrimitive = function(t, e) {
                var n, r = this.json,
                    o = this.dracoLoader,
                    i = t.extensions[this.name].bufferView,
                    a = t.extensions[this.name].attributes,
                    s = {},
                    c = {},
                    l = {};
                for (n in a) {
                    var u = I[n] || n.toLowerCase();
                    s[u] = a[n]
                }
                for (n in t.attributes) {
                    var h, p, u = I[n] || n.toLowerCase();
                    void 0 !== a[n] && (h = r.accessors[t.attributes[n]], p = R[h.componentType], l[u] = p, c[u] = !0 === h.normalized)
                }
                return e.getDependency("bufferView", i).then(function(t) {
                    return new Promise(function(i) {
                        o.decodeDracoFile(t, function(t) {
                            for (var e in t.attributes) {
                                var n = t.attributes[e],
                                    r = c[e];
                                void 0 !== r && (n.normalized = r)
                            }
                            i(t)
                        }, s, l)
                    })
                })
            }, y.prototype.extendTexture = function(t, e) { return t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.needsUpdate = !0, t }, ((l.prototype = Object.create(Kl.prototype)).constructor = l).prototype.copy = function(t) { return Kl.prototype.copy.call(this, t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, ((T.prototype = Object.create(su.prototype)).constructor = T).prototype.beforeStart_ = T.prototype.copySampleValue_ = function(t) { for (var e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r * 3 + r, o = 0; o !== r; o++) e[o] = n[i + o]; return e }, T.prototype.afterEnd_ = T.prototype.copySampleValue_, T.prototype.interpolate_ = function(t, e, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = 2 * a, c = 3 * a, l = r - e, r = (n - e) / l, n = r * r, e = n * r, u = t * c, h = u - c, p = -2 * e + 3 * n, d = e - n, f = 1 - p, m = d - n + r, g = 0; g !== a; g++) {
                    var v = o[h + g + a],
                        y = o[h + g + s] * l,
                        _ = o[u + g + a],
                        x = o[u + g] * l;
                    i[g] = f * v + m * y + p * _ + d * x
                }
                return i
            };
            var b = 0,
                w = 1,
                M = 2,
                S = 3,
                E = 4,
                A = 5,
                L = 6,
                R = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array },
                C = { 9728: Nt, 9729: Ut, 9984: Bt, 9985: zt, 9986: Ft, 9987: Ht },
                P = { 33071: It, 33648: Dt, 10497: Ot },
                O = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
                I = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" },
                D = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" },
                N = { CUBICSPLINE: void 0, LINEAR: tn, STEP: $e },
                B = "OPAQUE",
                F = "MASK",
                U = "BLEND",
                z = { "image/png": ee, "image/jpeg": te };

            function H(t, e) { return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t) }

            function k(t, e, n) { for (var r in n.extensions) void 0 === t[r] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = n.extensions[r]) }

            function G(t, e) { void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) }

            function V(t) { for (var e = "", n = Object.keys(t).sort(), r = 0, i = n.length; r < i; r++) e += n[r] + ":" + t[n[r]] + ";"; return e }

            function j(t, e, n) { this.json = t || {}, this.extensions = e || {}, this.options = n || {}, this.cache = new r, this.primitiveCache = {}, this.textureLoader = new Ou(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new Tu(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) }

            function W(n, t, r) {
                var e, i, o = t.attributes,
                    a = [];
                for (e in o) {
                    var s = I[e] || e.toLowerCase();
                    s in n.attributes || a.push(function(t, e) { return r.getDependency("accessor", t).then(function(t) { n.setAttribute(e, t) }) }(o[e], s))
                }
                return void 0 === t.indices || n.index || (i = r.getDependency("accessor", t.indices).then(function(t) { n.setIndex(t) }), a.push(i)), G(n, t),
                    function(t, e, n) {
                        var r = e.attributes,
                            i = new jn;
                        if (void 0 !== r.POSITION) {
                            var o = (p = n.json.accessors[r.POSITION]).min,
                                a = p.max;
                            if (void 0 !== o && void 0 !== a) {
                                i.set(new kn(o[0], o[1], o[2]), new kn(a[0], a[1], a[2]));
                                var s = e.targets;
                                if (void 0 !== s) {
                                    for (var c = new kn, l = new kn, u = 0, h = s.length; u < h; u++) {
                                        var p, d = s[u];
                                        void 0 !== d.POSITION && (o = (p = n.json.accessors[d.POSITION]).min, a = p.max, void 0 !== o && void 0 !== a ? (l.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))), l.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))), l.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))), c.max(l)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."))
                                    }
                                    i.expandByVector(c)
                                }
                                t.boundingBox = i;
                                e = new ar;
                                i.getCenter(e.center), e.radius = i.min.distanceTo(i.max) / 2, t.boundingSphere = e
                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }(n, t, r), Promise.all(a).then(function() {
                        return void 0 !== t.targets ? function(n, t, e) {
                            for (var r = !1, i = !1, o = 0, a = t.length; o < a; o++)
                                if (void 0 !== (u = t[o]).POSITION && (r = !0), void 0 !== u.NORMAL && (i = !0), r && i) break;
                            if (!r && !i) return Promise.resolve(n);
                            for (var s = [], c = [], o = 0, a = t.length; o < a; o++) {
                                var l, u = t[o];
                                r && (l = void 0 !== u.POSITION ? e.getDependency("accessor", u.POSITION) : n.attributes.position, s.push(l)), i && (l = void 0 !== u.NORMAL ? e.getDependency("accessor", u.NORMAL) : n.attributes.normal, c.push(l))
                            }
                            return Promise.all([Promise.all(s), Promise.all(c)]).then(function(t) {
                                var e = t[0],
                                    t = t[1];
                                return r && (n.morphAttributes.position = e), i && (n.morphAttributes.normal = t), n.morphTargetsRelative = !0, n
                            })
                        }(n, t.targets, r) : n
                    })
            }

            function q(t, e) {
                var n = t.getIndex();
                if (null === n) {
                    var r = [],
                        i = t.getAttribute("position");
                    if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                    for (var o = 0; o < i.count; o++) r.push(o);
                    t.setIndex(r), n = t.getIndex()
                }
                var a = n.count - 2,
                    s = [];
                if (e === on)
                    for (o = 1; o <= a; o++) s.push(n.getX(0)), s.push(n.getX(o)), s.push(n.getX(o + 1));
                else
                    for (o = 0; o < a; o++) o % 2 == 0 ? (s.push(n.getX(o)), s.push(n.getX(o + 1)), s.push(n.getX(o + 2))) : (s.push(n.getX(o + 2)), s.push(n.getX(o + 1)), s.push(n.getX(o)));
                s.length / 3 != a && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                t = t.clone();
                return t.setIndex(s), t
            }
            return j.prototype.parse = function(e, t) {
                var n = this,
                    r = this.json,
                    i = this.extensions;
                this.cache.removeAll(), this.markDefs(), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then(function(t) {
                    t = { scene: t[0][r.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: r.asset, parser: n, userData: {} };
                    k(i, t, r), G(t, r), e(t)
                }).catch(t)
            }, j.prototype.markDefs = function() {
                for (var t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [], r = {}, i = {}, o = 0, a = e.length; o < a; o++)
                    for (var s = e[o].joints, c = 0, l = s.length; c < l; c++) t[s[c]].isBone = !0;
                for (var u = 0, h = t.length; u < h; u++) {
                    var p = t[u];
                    void 0 !== p.mesh && (void 0 === r[p.mesh] && (r[p.mesh] = i[p.mesh] = 0), r[p.mesh]++, void 0 !== p.skin && (n[p.mesh].isSkinnedMesh = !0))
                }
                this.json.meshReferences = r, this.json.meshUses = i
            }, j.prototype.getDependency = function(t, e) {
                var n = t + ":" + e,
                    r = this.cache.get(n);
                if (!r) {
                    switch (t) {
                        case "scene":
                            r = this.loadScene(e);
                            break;
                        case "node":
                            r = this.loadNode(e);
                            break;
                        case "mesh":
                            r = this.loadMesh(e);
                            break;
                        case "accessor":
                            r = this.loadAccessor(e);
                            break;
                        case "bufferView":
                            r = this.loadBufferView(e);
                            break;
                        case "buffer":
                            r = this.loadBuffer(e);
                            break;
                        case "material":
                            r = this.loadMaterial(e);
                            break;
                        case "texture":
                            r = this.loadTexture(e);
                            break;
                        case "skin":
                            r = this.loadSkin(e);
                            break;
                        case "animation":
                            r = this.loadAnimation(e);
                            break;
                        case "camera":
                            r = this.loadCamera(e);
                            break;
                        case "light":
                            r = this.extensions[h.KHR_LIGHTS_PUNCTUAL].loadLight(e);
                            break;
                        default:
                            throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(n, r)
                }
                return r
            }, j.prototype.getDependencies = function(n) { var r, t, e = this.cache.get(n); return e || (t = (r = this).json[n + ("mesh" === n ? "es" : "s")] || [], e = Promise.all(t.map(function(t, e) { return r.getDependency(n, e) })), this.cache.add(n, e)), e }, j.prototype.loadBuffer = function(t) {
                var n = this.json.buffers[t],
                    r = this.fileLoader;
                if (n.type && "arraybuffer" !== n.type) throw new Error("THREE.GLTFLoader: " + n.type + " buffer type is not supported.");
                if (void 0 === n.uri && 0 === t) return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body);
                var i = this.options;
                return new Promise(function(t, e) { r.load(H(n.uri, i.path), t, void 0, function() { e(new Error('THREE.GLTFLoader: Failed to load buffer "' + n.uri + '".')) }) })
            }, j.prototype.loadBufferView = function(t) {
                var r = this.json.bufferViews[t];
                return this.getDependency("buffer", r.buffer).then(function(t) {
                    var e = r.byteLength || 0,
                        n = r.byteOffset || 0;
                    return t.slice(n, n + e)
                })
            }, j.prototype.loadAccessor = function(t) {
                var v = this,
                    y = this.json,
                    _ = this.json.accessors[t];
                if (void 0 === _.bufferView && void 0 === _.sparse) return Promise.resolve(null);
                t = [];
                return void 0 !== _.bufferView ? t.push(this.getDependency("bufferView", _.bufferView)) : t.push(null), void 0 !== _.sparse && (t.push(this.getDependency("bufferView", _.sparse.indices.bufferView)), t.push(this.getDependency("bufferView", _.sparse.values.bufferView))), Promise.all(t).then(function(t) {
                    var e, n, r = t[0],
                        i = O[_.type],
                        o = R[_.componentType],
                        a = o.BYTES_PER_ELEMENT,
                        s = a * i,
                        c = _.byteOffset || 0,
                        l = void 0 !== _.bufferView ? y.bufferViews[_.bufferView].byteStride : void 0,
                        u = !0 === _.normalized,
                        h = l && l !== s ? (e = Math.floor(c / l), n = "InterleavedBuffer:" + _.bufferView + ":" + _.componentType + ":" + e + ":" + _.count, (s = v.cache.get(n)) || (s = new Bs(new o(r, e * l, _.count * l / a), l / a), v.cache.add(n, s)), new zs(s, i, c % l / a, u)) : new gi(null === r ? new o(_.count * i) : new o(r, c, _.count * i), i, u);
                    if (void 0 !== _.sparse) {
                        var l = O.SCALAR,
                            a = R[_.sparse.indices.componentType],
                            c = _.sparse.indices.byteOffset || 0,
                            u = _.sparse.values.byteOffset || 0,
                            p = new a(t[1], c, _.sparse.count * l),
                            d = new o(t[2], u, _.sparse.count * i);
                        null !== r && (h = new gi(h.array.slice(), h.itemSize, h.normalized));
                        for (var f = 0, m = p.length; f < m; f++) { var g = p[f]; if (h.setX(g, d[f * i]), 2 <= i && h.setY(g, d[f * i + 1]), 3 <= i && h.setZ(g, d[f * i + 2]), 4 <= i && h.setW(g, d[f * i + 3]), 5 <= i) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") }
                    }
                    return h
                })
            }, j.prototype.loadTexture = function(t) {
                var e = this,
                    n = this.json,
                    i = this.options,
                    o = this.textureLoader,
                    r = self.URL || self.webkitURL,
                    a = n.textures[t],
                    s = a.extensions || {},
                    c = s[h.MSFT_TEXTURE_DDS] ? n.images[s[h.MSFT_TEXTURE_DDS].source] : n.images[a.source],
                    l = c.uri,
                    u = !1;
                return void 0 !== c.bufferView && (l = e.getDependency("bufferView", c.bufferView).then(function(t) {
                    u = !0;
                    t = new Blob([t], { type: c.mimeType });
                    return l = r.createObjectURL(t)
                })), Promise.resolve(l).then(function(n) { var r = (r = i.manager.getHandler(n)) || (s[h.MSFT_TEXTURE_DDS] ? e.extensions[h.MSFT_TEXTURE_DDS].ddsLoader : o); return new Promise(function(t, e) { r.load(H(n, i.path), t, void 0, e) }) }).then(function(t) {!0 === u && r.revokeObjectURL(l), t.flipY = !1, a.name && (t.name = a.name), c.mimeType in z && (t.format = z[c.mimeType]); var e = (n.samplers || {})[a.sampler] || {}; return t.magFilter = C[e.magFilter] || Ut, t.minFilter = C[e.minFilter] || Ht, t.wrapS = P[e.wrapS] || Ot, t.wrapT = P[e.wrapT] || Ot, t })
            }, j.prototype.assignTexture = function(n, r, i) {
                var o = this;
                return this.getDependency("texture", i.index).then(function(t) {
                    if (!t.isCompressedTexture) switch (r) {
                        case "aoMap":
                        case "emissiveMap":
                        case "metalnessMap":
                        case "normalMap":
                        case "roughnessMap":
                            t.format = te
                    }
                    var e;
                    void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === r && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + r + " not yet supported."), !o.extensions[h.KHR_TEXTURE_TRANSFORM] || (e = void 0 !== i.extensions ? i.extensions[h.KHR_TEXTURE_TRANSFORM] : void 0) && (t = o.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(t, e)), n[r] = t
                })
            }, j.prototype.assignFinalMaterial = function(t) {
                var e, n, r, i = t.geometry,
                    o = t.material,
                    a = void 0 !== i.attributes.tangent,
                    s = void 0 !== i.attributes.color,
                    c = void 0 === i.attributes.normal,
                    l = !0 === t.isSkinnedMesh,
                    u = 0 < Object.keys(i.morphAttributes).length,
                    h = u && void 0 !== i.morphAttributes.normal;
                t.isPoints ? (n = "PointsMaterial:" + o.uuid, (e = this.cache.get(n)) || (e = new Cc, pi.prototype.copy.call(e, o), e.color.copy(o.color), e.map = o.map, e.sizeAttenuation = !1, this.cache.add(n, e)), o = e) : t.isLine && (n = "LineBasicMaterial:" + o.uuid, (r = this.cache.get(n)) || (r = new _c, pi.prototype.copy.call(r, o), r.color.copy(o.color), this.cache.add(n, r)), o = r), (a || s || c || l || u) && (n = "ClonedMaterial:" + o.uuid + ":", o.isGLTFSpecularGlossinessMaterial && (n += "specular-glossiness:"), l && (n += "skinning:"), a && (n += "vertex-tangents:"), s && (n += "vertex-colors:"), c && (n += "flat-shading:"), u && (n += "morph-targets:"), h && (n += "morph-normals:"), (r = this.cache.get(n)) || (r = o.clone(), l && (r.skinning = !0), a && (r.vertexTangents = !0), s && (r.vertexColors = !0), c && (r.flatShading = !0), u && (r.morphTargets = !0), h && (r.morphNormals = !0), this.cache.add(n, r)), o = r), o.aoMap && void 0 === i.attributes.uv2 && void 0 !== i.attributes.uv && i.setAttribute("uv2", i.attributes.uv), o.normalScale && !a && (o.normalScale.y = -o.normalScale.y), o.clearcoatNormalScale && !a && (o.clearcoatNormalScale.y = -o.clearcoatNormalScale.y), t.material = o
            }, j.prototype.loadMaterial = function(t) {
                var e, n, r = this.json,
                    i = this.extensions,
                    o = r.materials[t],
                    a = {},
                    s = o.extensions || {},
                    r = [];
                s[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] ? (t = i[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS], e = t.getMaterialType(), r.push(t.extendParams(a, o, this))) : s[h.KHR_MATERIALS_UNLIT] ? (n = i[h.KHR_MATERIALS_UNLIT], e = n.getMaterialType(), r.push(n.extendParams(a, o, this))) : (e = Kl, c = o.pbrMetallicRoughness || {}, a.color = new li(1, 1, 1), a.opacity = 1, Array.isArray(c.baseColorFactor) && (n = c.baseColorFactor, a.color.fromArray(n), a.opacity = n[3]), void 0 !== c.baseColorTexture && r.push(this.assignTexture(a, "map", c.baseColorTexture)), a.metalness = void 0 !== c.metallicFactor ? c.metallicFactor : 1, a.roughness = void 0 !== c.roughnessFactor ? c.roughnessFactor : 1, void 0 !== c.metallicRoughnessTexture && (r.push(this.assignTexture(a, "metalnessMap", c.metallicRoughnessTexture)), r.push(this.assignTexture(a, "roughnessMap", c.metallicRoughnessTexture)))), !0 === o.doubleSided && (a.side = Y);
                var c = o.alphaMode || B;
                return c === U ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, c === F && (a.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && e !== di && (r.push(this.assignTexture(a, "normalMap", o.normalTexture)), a.normalScale = new Ln(1, 1), void 0 !== o.normalTexture.scale && a.normalScale.set(o.normalTexture.scale, o.normalTexture.scale)), void 0 !== o.occlusionTexture && e !== di && (r.push(this.assignTexture(a, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (a.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && e !== di && (a.emissive = (new li).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && e !== di && r.push(this.assignTexture(a, "emissiveMap", o.emissiveTexture)), s[h.KHR_MATERIALS_CLEARCOAT] && (c = i[h.KHR_MATERIALS_CLEARCOAT], e = c.getMaterialType(), r.push(c.extendParams(a, { extensions: s }, this))), Promise.all(r).then(function() { var t = e === l ? i[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new e(a); return o.name && (t.name = o.name), t.map && (t.map.encoding = sn), t.emissiveMap && (t.emissiveMap.encoding = sn), G(t, o), o.extensions && k(i, t, o), t })
            }, j.prototype.loadGeometries = function(t) {
                var n = this,
                    r = this.extensions,
                    e = this.primitiveCache;
                for (var i = [], o = 0, a = t.length; o < a; o++) {
                    var s = t[o],
                        c = (c = void 0, l = (c = (l = s).extensions && l.extensions[h.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + c.bufferView + ":" + c.indices + ":" + V(c.attributes) : l.indices + ":" + V(l.attributes) + ":" + l.mode),
                        l = e[c];
                    l ? i.push(l.promise) : (l = s.extensions && s.extensions[h.KHR_DRACO_MESH_COMPRESSION] ? function(e) { return r[h.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, n).then(function(t) { return W(t, e, n) }) }(s) : W(new Ni, s, n), e[c] = { primitive: s, promise: l }, i.push(l))
                }
                return Promise.all(i)
            }, j.prototype.loadMesh = function(h) {
                for (var p = this, d = this.json.meshes[h], f = d.primitives, t = [], e = 0, n = f.length; e < n; e++) {
                    var r = void 0 === f[e].material ? (void 0 === (r = this.cache).DefaultMaterial && (r.DefaultMaterial = new Kl({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: X })), r.DefaultMaterial) : this.getDependency("material", f[e].material);
                    t.push(r)
                }
                return t.push(p.loadGeometries(f)), Promise.all(t).then(function(t) {
                    for (var e = t.slice(0, t.length - 1), n = t[t.length - 1], r = [], i = 0, o = n.length; i < o; i++) {
                        var a, s = n[i],
                            c = f[i],
                            l = e[i];
                        if (c.mode === E || c.mode === A || c.mode === L || void 0 === c.mode) !0 !== (a = new(!0 === d.isSkinnedMesh ? lc : $i)(s, l)).isSkinnedMesh || a.geometry.attributes.skinWeight.normalized || a.normalizeSkinWeights(), c.mode === A ? a.geometry = q(a.geometry, 1) : c.mode === L && (a.geometry = q(a.geometry, on));
                        else if (c.mode === w) a = new Lc(s, l);
                        else if (c.mode === S) a = new Ec(s, l);
                        else if (c.mode === M) a = new Rc(s, l);
                        else {
                            if (c.mode !== b) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
                            a = new Nc(s, l)
                        }
                        0 < Object.keys(a.geometry.morphAttributes).length && function(t, e) {
                            if (t.updateMorphTargets(), void 0 !== e.weights)
                                for (var n = 0, r = e.weights.length; n < r; n++) t.morphTargetInfluences[n] = e.weights[n];
                            if (e.extras && Array.isArray(e.extras.targetNames)) { var i = e.extras.targetNames; if (t.morphTargetInfluences.length === i.length) { t.morphTargetDictionary = {}; for (n = 0, r = i.length; n < r; n++) t.morphTargetDictionary[i[n]] = n } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") }
                        }(a, d), a.name = d.name || "mesh_" + h, 1 < n.length && (a.name += "_" + i), G(a, d), p.assignFinalMaterial(a), r.push(a)
                    }
                    if (1 === r.length) return r[0];
                    for (var u = new As, i = 0, o = r.length; i < o; i++) u.add(r[i]);
                    return u
                })
            }, j.prototype.loadCamera = function(t) {
                var e, n = this.json.cameras[t],
                    t = n[n.type];
                if (t) return "perspective" === n.type ? e = new vo(An.radToDeg(t.yfov), t.aspectRatio || 1, t.znear || 1, t.zfar || 2e6) : "orthographic" === n.type && (e = new lh(-t.xmag, t.xmag, t.ymag, -t.ymag, t.znear, t.zfar)), n.name && (e.name = n.name), G(e, n), Promise.resolve(e);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }, j.prototype.loadSkin = function(t) {
                var t = this.json.skins[t],
                    e = { joints: t.joints };
                return void 0 === t.inverseBindMatrices ? Promise.resolve(e) : this.getDependency("accessor", t.inverseBindMatrices).then(function(t) { return e.inverseBindMatrices = t, e })
            }, j.prototype.loadAnimation = function(S) {
                for (var E = this.json.animations[S], t = [], e = [], n = [], r = [], i = [], o = 0, a = E.channels.length; o < a; o++) {
                    var s = E.channels[o],
                        c = E.samplers[s.sampler],
                        l = s.target,
                        u = void 0 !== l.node ? l.node : l.id,
                        h = void 0 !== E.parameters ? E.parameters[c.input] : c.input,
                        s = void 0 !== E.parameters ? E.parameters[c.output] : c.output;
                    t.push(this.getDependency("node", u)), e.push(this.getDependency("accessor", h)), n.push(this.getDependency("accessor", s)), r.push(c), i.push(l)
                }
                return Promise.all([Promise.all(t), Promise.all(e), Promise.all(n), Promise.all(r), Promise.all(i)]).then(function(t) {
                    for (var e = t[0], n = t[1], r = t[2], i = t[3], o = t[4], a = [], s = 0, c = e.length; s < c; s++) {
                        var l, u = e[s],
                            h = n[s],
                            p = r[s],
                            d = i[s],
                            f = o[s];
                        if (void 0 !== u) {
                            switch (u.updateMatrix(), u.matrixAutoUpdate = !0, D[f.path]) {
                                case D.weights:
                                    l = fu;
                                    break;
                                case D.rotation:
                                    l = gu;
                                    break;
                                case D.position:
                                case D.scale:
                                default:
                                    l = yu
                            }
                            var m = u.name || u.uuid,
                                g = void 0 !== d.interpolation ? N[d.interpolation] : tn,
                                v = [];
                            D[f.path] === D.weights ? u.traverse(function(t) {!0 === t.isMesh && t.morphTargetInfluences && v.push(t.name || t.uuid) }) : v.push(m);
                            var y, _ = p.array;
                            if (p.normalized) {
                                if (_.constructor === Int8Array) y = 1 / 127;
                                else if (_.constructor === Uint8Array) y = 1 / 255;
                                else if (_.constructor == Int16Array) y = 1 / 32767;
                                else {
                                    if (_.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                    y = 1 / 65535
                                }
                                for (var x = new Float32Array(_.length), b = 0, w = _.length; b < w; b++) x[b] = _[b] * y;
                                _ = x
                            }
                            for (b = 0, w = v.length; b < w; b++) { var M = new l(v[b] + "." + D[f.path], h.array, _, g); "CUBICSPLINE" === d.interpolation && (M.createInterpolant = function(t) { return new T(this.times, this.values, this.getValueSize() / 3, t) }, M.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), a.push(M) }
                        }
                    }
                    return new _u(E.name || "animation_" + S, void 0, a)
                })
            }, j.prototype.loadNode = function(t) {
                var e = this.json,
                    o = this.extensions,
                    n = this,
                    r = e.meshReferences,
                    i = e.meshUses,
                    a = e.nodes[t];
                return t = [], void 0 !== a.mesh && t.push(n.getDependency("mesh", a.mesh).then(function(t) {
                    var e, n;
                    return 1 < r[a.mesh] ? (e = i[a.mesh]++, (n = t.clone()).name += "_instance_" + e) : n = t, void 0 !== a.weights && n.traverse(function(t) {
                        if (t.isMesh)
                            for (var e = 0, n = a.weights.length; e < n; e++) t.morphTargetInfluences[e] = a.weights[e]
                    }), n
                })), void 0 !== a.camera && t.push(n.getDependency("camera", a.camera)), a.extensions && a.extensions[h.KHR_LIGHTS_PUNCTUAL] && void 0 !== a.extensions[h.KHR_LIGHTS_PUNCTUAL].light && t.push(n.getDependency("light", a.extensions[h.KHR_LIGHTS_PUNCTUAL].light)), Promise.all(t).then(function(t) {
                    var e, n = !0 === a.isBone ? new dc : 1 < t.length ? new As : 1 === t.length ? t[0] : new kr;
                    if (n !== t[0])
                        for (var r = 0, i = t.length; r < i; r++) n.add(t[r]);
                    return a.name && (n.userData.name = a.name, n.name = lp.sanitizeNodeName(a.name)), G(n, a), a.extensions && k(o, n, a), void 0 !== a.matrix ? ((e = new mr).fromArray(a.matrix), n.applyMatrix4(e)) : (void 0 !== a.translation && n.position.fromArray(a.translation), void 0 !== a.rotation && n.quaternion.fromArray(a.rotation), void 0 !== a.scale && n.scale.fromArray(a.scale)), n
                })
            }, j.prototype.loadScene = function(t) {
                var e = this.json,
                    n = this.extensions,
                    t = this.json.scenes[t],
                    r = new As;
                t.name && (r.name = t.name), G(r, t), t.extensions && k(n, r, t);
                for (var i = t.nodes || [], o = [], a = 0, s = i.length; a < s; a++) o.push(function a(t, s, c, l) {
                    var u = c.nodes[t];
                    return l.getDependency("node", t).then(function(t) {
                        return void 0 === u.skin ? t : l.getDependency("skin", u.skin).then(function(t) { for (var e = [], n = 0, r = (s = t).joints.length; n < r; n++) e.push(l.getDependency("node", s.joints[n])); return Promise.all(e) }).then(function(a) {
                            return t.traverse(function(t) {
                                if (t.isMesh) {
                                    for (var e = [], n = [], r = 0, i = a.length; r < i; r++) {
                                        var o = a[r];
                                        o ? (e.push(o), o = new mr, void 0 !== s.inverseBindMatrices && o.fromArray(s.inverseBindMatrices.array, 16 * r), n.push(o)) : console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', s.joints[r])
                                    }
                                    t.bind(new pc(e, n), t.matrixWorld)
                                }
                            }), t
                        });
                        var s
                    }).then(function(t) {
                        s.add(t);
                        var e = [];
                        if (u.children)
                            for (var n = u.children, r = 0, i = n.length; r < i; r++) {
                                var o = n[r];
                                e.push(a(o, t, c, l))
                            }
                        return Promise.all(e)
                    })
                }(i[a], r, e, this));
                return Promise.all(o).then(function() { return r })
            }, t
        }();
    Um.prototype = Object.assign(Object.create(Su.prototype), {
        constructor: Um,
        setDecoderPath: function(t) { return this.decoderPath = t, this },
        setDecoderConfig: function(t) { return this.decoderConfig = t, this },
        setWorkerLimit: function(t) { return this.workerLimit = t, this },
        setVerbosity: function() { console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.") },
        setDrawMode: function() { console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.") },
        setSkipDequantization: function() { console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.") },
        load: function(t, n, e, r) {
            var i = this,
                o = new Tu(this.manager);
            o.setPath(this.path), o.setResponseType("arraybuffer"), "use-credentials" === this.crossOrigin && o.setWithCredentials(!0), o.load(t, function(t) {
                var e = { attributeIDs: i.defaultAttributeIDs, attributeTypes: i.defaultAttributeTypes, useUniqueIDs: !1 };
                i.decodeGeometry(t, e).then(n).catch(r)
            }, e, r)
        },
        decodeDracoFile: function(t, e, n, r) {
            n = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n };
            this.decodeGeometry(t, n).then(e)
        },
        decodeGeometry: function(n, r) {
            var t, e = this;
            for (t in r.attributeTypes) {
                var i = r.attributeTypes[t];
                void 0 !== i.BYTES_PER_ELEMENT && (r.attributeTypes[t] = i.name)
            }
            var o, a = JSON.stringify(r);
            if (Um.taskCache.has(n)) { var s = Um.taskCache.get(n); if (s.key === a) return s.promise; if (0 === n.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") }
            var c = this.workerNextTaskID++,
                s = n.byteLength,
                s = this._getWorker(c, s).then(function(t) { return o = t, new Promise(function(t, e) { o._callbacks[c] = { resolve: t, reject: e }, o.postMessage({ type: "decode", id: c, taskConfig: r, buffer: n }, [n]) }) }).then(function(t) { return e._createGeometry(t.geometry) });
            return s.finally(function() { o && c && e._releaseTask(o, c) }), Um.taskCache.set(n, { key: a, promise: s }), s
        },
        _createGeometry: function(t) {
            var e = new Ni;
            t.index && e.setIndex(new gi(t.index.array, 1));
            for (var n = 0; n < t.attributes.length; n++) {
                var r = t.attributes[n],
                    i = r.name,
                    o = r.array,
                    r = r.itemSize;
                e.setAttribute(i, new gi(o, r))
            }
            return e
        },
        _loadLibrary: function(n, t) { var r = new Tu(this.manager); return r.setPath(this.decoderPath), r.setResponseType(t), new Promise(function(t, e) { r.load(n, t, void 0, e) }) },
        preload: function() { return this._initDecoder(), this },
        _initDecoder: function() {
            var n = this;
            if (this.decoderPending) return this.decoderPending;
            var r = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                t = [];
            return r ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(function(t) {
                var e = t[0];
                r || (n.decoderConfig.wasmBinary = t[1]);
                t = Um.DRACOWorker.toString(), t = ["/* draco decoder */", e, "", "/* worker */", t.substring(t.indexOf("{") + 1, t.lastIndexOf("}"))].join("\n");
                n.workerSourceURL = URL.createObjectURL(new Blob([t]))
            }), this.decoderPending
        },
        _getWorker: function(t, e) {
            var r = this;
            return this._initDecoder().then(function() {
                var n;
                return r.workerPool.length < r.workerLimit ? ((n = new Worker(r.workerSourceURL))._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: r.decoderConfig }), n.onmessage = function(t) {
                    var e = t.data;
                    switch (e.type) {
                        case "decode":
                            n._callbacks[e.id].resolve(e);
                            break;
                        case "error":
                            n._callbacks[e.id].reject(e);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + e.type + '"')
                    }
                }, r.workerPool.push(n)) : r.workerPool.sort(function(t, e) { return t._taskLoad > e._taskLoad ? -1 : 1 }), (n = r.workerPool[r.workerPool.length - 1])._taskCosts[t] = e, n._taskLoad += e, n
            })
        },
        _releaseTask: function(t, e) { t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e] },
        debug: function() { console.log("Task load: ", this.workerPool.map(function(t) { return t._taskLoad })) },
        dispose: function() { for (var t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate(); return this.workerPool.length = 0, this }
    }), Um.DRACOWorker = function() {
        var n, e;
        onmessage = function(t) {
            var a = t.data;
            switch (a.type) {
                case "init":
                    n = a.decoderConfig, e = new Promise(function(e) { n.onModuleLoaded = function(t) { e({ draco: t }) }, DracoDecoderModule(n) });
                    break;
                case "decode":
                    var s = a.buffer,
                        c = a.taskConfig;
                    e.then(function(t) {
                        var e = t.draco,
                            n = new e.Decoder,
                            r = new e.DecoderBuffer;
                        r.Init(new Int8Array(s), s.byteLength);
                        try {
                            var i = function(t, e, n, r) {
                                    var i, o, a = r.attributeIDs,
                                        s = r.attributeTypes,
                                        c = e.GetEncodedGeometryType(n);
                                    if (c === t.TRIANGULAR_MESH) i = new t.Mesh, o = e.DecodeBufferToMesh(n, i);
                                    else {
                                        if (c !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                        i = new t.PointCloud, o = e.DecodeBufferToPointCloud(n, i)
                                    }
                                    if (!o.ok() || 0 === i.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + o.error_msg());
                                    var l, u, h, p = { index: null, attributes: [] };
                                    for (l in a) {
                                        var d = self[s[l]];
                                        if (r.useUniqueIDs) h = a[l], u = e.GetAttributeByUniqueId(i, h);
                                        else {
                                            if (-1 === (h = e.GetAttributeId(i, t[a[l]]))) continue;
                                            u = e.GetAttribute(i, h)
                                        }
                                        p.attributes.push(function(t, e, n, r, i, o) {
                                            var a, s, c = o.num_components(),
                                                l = n.num_points() * c;
                                            switch (i) {
                                                case Float32Array:
                                                    a = new t.DracoFloat32Array, e.GetAttributeFloatForAllPoints(n, o, a), s = new Float32Array(l);
                                                    break;
                                                case Int8Array:
                                                    a = new t.DracoInt8Array, e.GetAttributeInt8ForAllPoints(n, o, a), s = new Int8Array(l);
                                                    break;
                                                case Int16Array:
                                                    a = new t.DracoInt16Array, e.GetAttributeInt16ForAllPoints(n, o, a), s = new Int16Array(l);
                                                    break;
                                                case Int32Array:
                                                    a = new t.DracoInt32Array, e.GetAttributeInt32ForAllPoints(n, o, a), s = new Int32Array(l);
                                                    break;
                                                case Uint8Array:
                                                    a = new t.DracoUInt8Array, e.GetAttributeUInt8ForAllPoints(n, o, a), s = new Uint8Array(l);
                                                    break;
                                                case Uint16Array:
                                                    a = new t.DracoUInt16Array, e.GetAttributeUInt16ForAllPoints(n, o, a), s = new Uint16Array(l);
                                                    break;
                                                case Uint32Array:
                                                    a = new t.DracoUInt32Array, e.GetAttributeUInt32ForAllPoints(n, o, a), s = new Uint32Array(l);
                                                    break;
                                                default:
                                                    throw new Error("THREE.DRACOLoader: Unexpected attribute type.")
                                            }
                                            for (var u = 0; u < l; u++) s[u] = a.GetValue(u);
                                            return t.destroy(a), { name: r, array: s, itemSize: c }
                                        }(t, e, i, l, d, u))
                                    }
                                    if (c === t.TRIANGULAR_MESH) {
                                        for (var f = i.num_faces(), m = new Uint32Array(3 * f), g = new t.DracoInt32Array, v = 0; v < f; ++v) { e.GetFaceFromMesh(i, v, g); for (var y = 0; y < 3; ++y) m[3 * v + y] = g.GetValue(y) }
                                        p.index = { array: m, itemSize: 1 }, t.destroy(g)
                                    }
                                    return t.destroy(i), p
                                }(e, n, r, c),
                                o = i.attributes.map(function(t) { return t.array.buffer });
                            i.index && o.push(i.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: i }, o)
                        } catch (t) { console.error(t), self.postMessage({ type: "error", id: a.id, error: t.message }) } finally { e.destroy(r), e.destroy(n) }
                    })
            }
        }
    }, Um.taskCache = new WeakMap, Um.setDecoderPath = function() { console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.") }, Um.setDecoderConfig = function() { console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.") }, Um.releaseDecoderModule = function() { console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.") }, Um.getDecoderModule = function() { console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.") };

    function tg(t, e, n) {
        n.wrapS = n.wrapT = Ot;
        n = { uIsAnimated: { value: 0 }, uTime: { value: 0 }, uAlpha: { value: 1 }, uTxtBase: { value: t }, uTxtShape: { value: e }, uTxtCloudNoise: { value: n } };
        return new mo({ uniforms: Object.assign({}, ho.clone(Co.sprite.uniforms), n), vertexShader: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvarying vec2 vUv;\n\nvoid main() {\n\t// #include <uv_vertex>\n  vUv = uv;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n", fragmentShader: "\nuniform sampler2D uTxtBase;\nuniform sampler2D uTxtShape;\nuniform sampler2D uTxtCloudNoise;\n\nuniform float uAlpha;\nuniform float uTime;\n\nvarying vec2 vUv;\n\nvec4 gammaCorrect(vec4 color, float gamma){\n  return pow(color, vec4(1.0 / gamma));\n}\n\nvec4 levelRange(vec4 color, float minInput, float maxInput){\n  return min(max(color - vec4(minInput), vec4(0.0)) / (vec4(maxInput) - vec4(minInput)), vec4(1.0));\n}\n\nvec4 levels(vec4 color, float minInput, float gamma, float maxInput){\n  return gammaCorrect(levelRange(color, minInput, maxInput), gamma);\n}\n\nvoid main() {\n  vec2 newUv = vUv;\n\n  vec4 txtNoise1 = texture2D(uTxtCloudNoise, vec2(vUv.x + uTime * 0.001, vUv.y - uTime * 0.0014));\n  vec4 txtNoise2 = texture2D(uTxtCloudNoise, vec2(vUv.x - uTime * 0.0002, vUv.y + uTime * 0.00017 + 0.2));\n\n  vec4 txtShape = texture2D(uTxtShape, newUv);\n  vec4 txtBase = texture2D(uTxtBase, newUv);\n\n  float alpha = levels((txtNoise1 + txtNoise2) * 0.6, 0.2, 0.4, 0.7).r;\n  alpha *= txtShape.r;\n\n  gl_FragColor = mix(mix(txtBase, vec4(vec3(1.0,1.0,1.0), alpha), .5), vec4(1.0,1.0,1.0,0.0), 1. - uAlpha);\n}\n", transparent: !0 })
    }
    nl = function() {
        this.loadingManager = new wu, this.textureLoader = new Ou(this.loadingManager), this.textureLoader.path = "../assets/img/", this.imagesUrl = { textIntro: "text-intro.png", textParagraph01: "text-paragraph-01.png", textParagraph02: "text-paragraph-02.png", textParagraph01S: "text-paragraph-01-s.png", textParagraph02S: "text-paragraph-02-s.png", sectionCollection: "section-collection.png", sectionInnovations: "section-innovations.png", sectionEntretien: "section-entretien.png", sectionEntretienS: "section-entretien-s.png", sectionOutro: "section-outro.png", playIcon: "play-icon.png", cloudBase01: "cloud-base-01.png", cloudMask01: "cloud-mask-01.png", cloudBase02: "cloud-base-02.png", cloudMask02: "cloud-mask-02.png", cloudBase03: "cloud-base-04.png", cloudMask03: "cloud-mask-04.png", cloudBase04: "cloud-base-04.png", cloudMask04: "cloud-mask-04.png", cloudBase05: "cloud-base-05.png", cloudMask05: "cloud-mask-05.png", cloudNoise: "cloud-noise.jpg" }, this.imageTextures = {}, this.gltfLoader = new $m(this.loadingManager), this.gltfLoader.path = "./assets/models/";
        var t = new Um;
        t.setDecoderPath("./assets/plugins/draco/"), this.gltfLoader.setDRACOLoader(t), this.gltfUrl = { jacket: "jacket___master_draco.gltf" }, this.gltfModels = {}, this.materials = {}, this.onProgress = function() {}, this.onComplete = function() {}, this.loadingManager.onLoad = function() { this._createMaterials(), this.onComplete() }.bind(this), this.loadingManager.onProgress = function(t, e, n) { this.onProgress(e / n) }.bind(this)
    };
    nl.prototype._createMaterials = function() {
        var t = this.imageTextures;
        this.materials.cloud01 = tg(t.cloudBase01, t.cloudMask01, t.cloudNoise), this.materials.cloud02 = tg(t.cloudBase02, t.cloudMask02, t.cloudNoise), this.materials.cloud03 = tg(t.cloudBase03, t.cloudMask03, t.cloudNoise), this.materials.cloud04 = tg(t.cloudBase04, t.cloudMask04, t.cloudNoise), this.materials.cloud05 = tg(t.cloudBase05, t.cloudMask05, t.cloudNoise), this.materials.cloudSectionStart = tg(t.cloudBase03, t.cloudMask01, t.cloudNoise), this.materials.cloudSection01 = tg(t.cloudBase01, t.cloudMask01, t.cloudNoise), this.materials.cloudSection02 = tg(t.cloudBase02, t.cloudMask02, t.cloudNoise), this.materials.cloudSection03 = tg(t.cloudBase03, t.cloudMask03, t.cloudNoise), this.materials.cloudSection04 = tg(t.cloudBase04, t.cloudMask04, t.cloudNoise), this.materials.cloudSection05 = tg(t.cloudBase01, t.cloudMask01, t.cloudNoise), this.materials.cloudSection06 = tg(t.cloudBase01, t.cloudMask01, t.cloudNoise), this.materials.cloudSection07 = tg(t.cloudBase05, t.cloudMask05, t.cloudNoise), this.materials.cloudSection42 = tg(t.cloudBase01, t.cloudMask01, t.cloudNoise)
    }, nl.prototype._loadImage = function(e, t) { this.textureLoader.load(t, function(t) { this.imageTextures[e] = t, this.imageTextures[e].encoding = sn }.bind(this)) }, nl.prototype._loadGltf = function(e, t) {
        this.gltfLoader.load(t, function(t) {
            t = t.scene;
            this.gltfModels[e] = t
        }.bind(this))
    }, nl.prototype.init = function() { for (var t in this.imagesUrl) this._loadImage(t, this.imagesUrl[t]); for (var e in this.gltfUrl) this._loadGltf(e, this.gltfUrl[e]) };
    var eg = new nl,
        ng = new Ns,
        rg = new vo(60, wf.width / wf.height, .1, 75e3);
    rg.position.set(0, 0, 100);
    var ig = new Ps;
    ig.setPixelRatio(window.devicePixelRatio), ig.setSize(wf.width, wf.height), ig.outputEncoding = sn, ig.toneMappingExposure = .1, wf.bodyEl.appendChild(ig.domElement);
    nl = new ph(8421504, 1.9);
    ng.add(nl);
    nl = new hh(16777215, 1.2);

    function og() { rg.aspect = wf.width / wf.height, rg.updateProjectionMatrix(), ig.setSize(wf.width, wf.height), ig.render(ng, rg) }
    ng.add(nl);
    var ag, sg = function(t, e) {
        return (sg = Object.setPrototypeOf || { __proto__: [] }
            instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]) })(t, e)
    };
    (nl = ag = ag || {})[nl.NONE = 0] = "NONE", nl[nl.ROTATE = 1] = "ROTATE", nl[nl.TRUCK = 2] = "TRUCK", nl[nl.OFFSET = 3] = "OFFSET", nl[nl.DOLLY = 4] = "DOLLY", nl[nl.ZOOM = 5] = "ZOOM", nl[nl.TOUCH_ROTATE = 6] = "TOUCH_ROTATE", nl[nl.TOUCH_TRUCK = 7] = "TOUCH_TRUCK", nl[nl.TOUCH_OFFSET = 8] = "TOUCH_OFFSET", nl[nl.TOUCH_DOLLY = 9] = "TOUCH_DOLLY", nl[nl.TOUCH_ZOOM = 10] = "TOUCH_ZOOM", nl[nl.TOUCH_DOLLY_TRUCK = 11] = "TOUCH_DOLLY_TRUCK", nl[nl.TOUCH_DOLLY_OFFSET = 12] = "TOUCH_DOLLY_OFFSET", nl[nl.TOUCH_ZOOM_TRUCK = 13] = "TOUCH_ZOOM_TRUCK", nl[nl.TOUCH_ZOOM_OFFSET = 14] = "TOUCH_ZOOM_OFFSET";
    var cg = 2 * Math.PI,
        lg = Math.PI / 2,
        ug = 1e-5;

    function hg(t) { return Math.abs(t) < ug }

    function pg(t, e) { return Math.round(t / e) * e }

    function dg(t) { return isFinite(t) ? t : t < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE }

    function fg(t) { return Math.abs(t) < Number.MAX_VALUE ? t : t * (1 / 0) }

    function mg(t) { return "TouchEvent" in window && t instanceof TouchEvent }

    function gg(t, e) { if (e.set(0, 0), mg(t)) { for (var n = t, r = 0; r < n.touches.length; r++) e.x += n.touches[r].clientX, e.y += n.touches[r].clientY; return e.x /= n.touches.length, e.y /= n.touches.length, e } return e.set(t.clientX, t.clientY), e }

    function vg(t, e) { return !t.isPerspectiveCamera && (console.warn(e + " is not supported in OrthographicCamera"), 1) }
    var yg = (_g.prototype.addEventListener = function(t, e) {
        var n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
    }, _g.prototype.removeEventListener = function(t, e) {
        t = this._listeners[t];
        void 0 === t || -1 !== (e = t.indexOf(e)) && t.splice(e, 1)
    }, _g.prototype.removeAllEventListeners = function(t) { t ? Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0) : this._listeners = {} }, _g.prototype.dispatchEvent = function(t) { var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; for (var n = e.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, t) } }, _g);

    function _g() { this._listeners = {} }
    var xg, bg, wg, Mg, Sg, Eg, Tg, Ag, Lg, Rg, Cg, Pg, Og, Ig, Dg, Ng, Bg, Fg, Ug, zg, Hg, kg, Gg, Vg = "undefined" != typeof window && /Mac/.test(navigator.platform),
        jg = Object.freeze(ag),
        nl = (sg(kg = qg, Gg = Hg = yg), kg.prototype = null === Gg ? Object.create(Gg) : (Wg.prototype = Gg.prototype, new Wg), qg.install = function(t) { xg = t.THREE, bg = Object.freeze(new xg.Vector3(0, 0, 0)), wg = Object.freeze(new xg.Vector3(0, 1, 0)), Mg = Object.freeze(new xg.Vector3(0, 0, 1)), Sg = new xg.Vector2, Eg = new xg.Vector3, Tg = new xg.Vector3, Ag = new xg.Vector3, Lg = new xg.Vector3, Rg = new xg.Vector3, Cg = new xg.Vector3, Pg = new xg.Spherical, Og = new xg.Spherical, Ig = new xg.Box3, Dg = new xg.Box3, Ng = new xg.Sphere, Bg = new xg.Quaternion, Fg = new xg.Quaternion, Ug = new xg.Matrix4, zg = new xg.Raycaster }, Object.defineProperty(qg, "ACTION", { get: function() { return jg }, enumerable: !1, configurable: !0 }), Object.defineProperty(qg.prototype, "enabled", {
            get: function() { return this._enabled },
            set: function(t) {
                (this._enabled = t) || this.cancel()
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(qg.prototype, "currentAction", { get: function() { return this._state }, enumerable: !1, configurable: !0 }), Object.defineProperty(qg.prototype, "distance", { get: function() { return this._spherical.radius }, set: function(t) { this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(qg.prototype, "azimuthAngle", { get: function() { return this._spherical.theta }, set: function(t) { this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(qg.prototype, "polarAngle", { get: function() { return this._spherical.phi }, set: function(t) { this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(qg.prototype, "phiSpeed", { set: function(t) { console.warn("phiSpeed was renamed. use azimuthRotateSpeed instead"), this.azimuthRotateSpeed = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(qg.prototype, "thetaSpeed", { set: function(t) { console.warn("thetaSpeed was renamed. use polarRotateSpeed instead"), this.polarRotateSpeed = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(qg.prototype, "boundaryEnclosesCamera", { get: function() { return this._boundaryEnclosesCamera }, set: function(t) { this._boundaryEnclosesCamera = t, this._needsUpdate = !0 }, enumerable: !1, configurable: !0 }), qg.prototype.addEventListener = function(t, e) { Hg.prototype.addEventListener.call(this, t, e) }, qg.prototype.removeEventListener = function(t, e) { Hg.prototype.removeEventListener.call(this, t, e) }, qg.prototype.rotate = function(t, e, n) { void 0 === n && (n = !1), this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, n) }, qg.prototype.rotateTo = function(t, e, n) {
            void 0 === n && (n = !1);
            t = xg.MathUtils.clamp(t, this.minAzimuthAngle, this.maxAzimuthAngle), e = xg.MathUtils.clamp(e, this.minPolarAngle, this.maxPolarAngle);
            this._sphericalEnd.theta = t, this._sphericalEnd.phi = e, this._sphericalEnd.makeSafe(), n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi), this._needsUpdate = !0
        }, qg.prototype.dolly = function(t, e) { void 0 === e && (e = !1), this.dollyTo(this._sphericalEnd.radius - t, e) }, qg.prototype.dollyTo = function(t, e) { void 0 === e && (e = !1), vg(this._camera, "dolly") || (this._sphericalEnd.radius = xg.MathUtils.clamp(t, this.minDistance, this.maxDistance), e || (this._spherical.radius = this._sphericalEnd.radius), this._needsUpdate = !0) }, qg.prototype.zoom = function(t, e) { void 0 === e && (e = !1), this.zoomTo(this._zoomEnd + t, e) }, qg.prototype.zoomTo = function(t, e) { void 0 === e && (e = !1), this._zoomEnd = xg.MathUtils.clamp(t, this.minZoom, this.maxZoom), e || (this._zoom = this._zoomEnd), this._needsUpdate = !0 }, qg.prototype.pan = function(t, e, n) { void 0 === n && (n = !1), console.log("`pan` has been renamed to `truck`"), this.truck(t, e, n) }, qg.prototype.truck = function(t, e, n) {
            void 0 === n && (n = !1), this._camera.updateMatrix(), Lg.setFromMatrixColumn(this._camera.matrix, 0), Rg.setFromMatrixColumn(this._camera.matrix, 1), Lg.multiplyScalar(t), Rg.multiplyScalar(-e);
            e = Eg.copy(Lg).add(Rg);
            this._encloseToBoundary(this._targetEnd, e, this.boundaryFriction), n || this._target.copy(this._targetEnd), this._needsUpdate = !0
        }, qg.prototype.forward = function(t, e) { void 0 === e && (e = !1), Eg.setFromMatrixColumn(this._camera.matrix, 0), Eg.crossVectors(this._camera.up, Eg), Eg.multiplyScalar(t), this._encloseToBoundary(this._targetEnd, Eg, this.boundaryFriction), e || this._target.copy(this._targetEnd), this._needsUpdate = !0 }, qg.prototype.moveTo = function(t, e, n, r) { void 0 === r && (r = !1), this._targetEnd.set(t, e, n), r || this._target.copy(this._targetEnd), this._needsUpdate = !0 }, qg.prototype.fitToBox = function(t, e, n) {
            var r, i = void 0 === n ? {} : n,
                o = i.paddingLeft,
                a = void 0 === o ? 0 : o,
                s = i.paddingRight,
                c = void 0 === s ? 0 : s,
                l = i.paddingBottom,
                n = void 0 === l ? 0 : l,
                o = i.paddingTop,
                s = void 0 === o ? 0 : o,
                l = t.isBox3 ? Ig.copy(t) : Ig.setFromObject(t);
            l.isEmpty() ? console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting") : (i = pg(this._sphericalEnd.theta, lg), o = pg(this._sphericalEnd.phi, lg), this.rotateTo(i, o, e), t = Eg.setFromSpherical(this._sphericalEnd).normalize(), o = Bg.setFromUnitVectors(t, Mg), hg(Math.abs(t.y) - 1) && o.multiply(Fg.setFromAxisAngle(wg, i)), i = Dg.makeEmpty(), Tg.copy(l.min).applyQuaternion(o), i.expandByPoint(Tg), Tg.copy(l.min).setX(l.max.x).applyQuaternion(o), i.expandByPoint(Tg), Tg.copy(l.min).setY(l.max.y).applyQuaternion(o), i.expandByPoint(Tg), Tg.copy(l.max).setZ(l.min.z).applyQuaternion(o), i.expandByPoint(Tg), Tg.copy(l.min).setZ(l.max.z).applyQuaternion(o), i.expandByPoint(Tg), Tg.copy(l.max).setY(l.min.y).applyQuaternion(o), i.expandByPoint(Tg), Tg.copy(l.max).setX(l.min.x).applyQuaternion(o), i.expandByPoint(Tg), Tg.copy(l.max).applyQuaternion(o), i.expandByPoint(Tg), o.setFromUnitVectors(Mg, t), i.min.x -= a, i.min.y -= n, i.max.x += c, i.max.y += s, c = i.getSize(Eg), s = i.getCenter(Tg).applyQuaternion(o), i = this._camera.isPerspectiveCamera, o = this._camera.isOrthographicCamera, i ? (r = this.getDistanceToFitBox(c.x, c.y, c.z), this.moveTo(s.x, s.y, s.z, e), this.dollyTo(r, e), this.setFocalOffset(0, 0, 0, e)) : o && (o = (r = this._camera).right - r.left, r = r.top - r.bottom, c = Math.min(o / c.x, r / c.y), this.moveTo(s.x, s.y, s.z, e), this.zoomTo(c, e), this.setFocalOffset(0, 0, 0, e)))
        }, qg.prototype.fitTo = function(t, e, n) { void 0 === n && (n = {}), console.warn("camera-controls: fitTo() has been renamed to fitToBox()"), this.fitToBox(t, e, n) }, qg.prototype.fitToSphere = function(t, e) {
            var n = t instanceof xg.Sphere ? Ng.copy(t) : function(t, e) {
                    var e = e,
                        a = e.center;
                    t.traverse(function(t) { t.isMesh && Ig.expandByObject(t) }), Ig.getCenter(a);
                    var s = 0;
                    return t.traverse(function(t) {
                        if (t.isMesh) {
                            var e = t,
                                t = e.geometry.clone();
                            if (t.applyMatrix4(e.matrixWorld), e.geometry.isBufferGeometry)
                                for (var n = t.attributes.position, r = 0, i = n.count; r < i; r++) Eg.fromBufferAttribute(n, r), s = Math.max(s, a.distanceToSquared(Eg));
                            else
                                for (var o = t.vertices, r = 0, i = o.length; r < i; r++) s = Math.max(s, a.distanceToSquared(o[r]))
                        }
                    }), e.radius = Math.sqrt(s), e
                }(t, Ng),
                t = this.getDistanceToFitSphere(n.radius);
            this.moveTo(n.center.x, n.center.y, n.center.z, e), this.dollyTo(t, e), this.setFocalOffset(0, 0, 0, e)
        }, qg.prototype.setLookAt = function(t, e, n, r, i, o, a) {
            void 0 === a && (a = !1);
            n = Eg.set(t, e, n), o = Tg.set(r, i, o);
            this._targetEnd.copy(o), this._sphericalEnd.setFromVector3(n.sub(o).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd)), this._needsUpdate = !0
        }, qg.prototype.lerpLookAt = function(t, e, n, r, i, o, a, s, c, l, u, h, p, d) {
            void 0 === d && (d = !1);
            n = Eg.set(t, e, n), o = Tg.set(r, i, o);
            Pg.setFromVector3(n.sub(o).applyQuaternion(this._yAxisUpSpace));
            h = Eg.set(l, u, h);
            this._targetEnd.copy(o).lerp(h, p);
            s = Tg.set(a, s, c);
            Og.setFromVector3(s.sub(h).applyQuaternion(this._yAxisUpSpace));
            c = Og.theta - Pg.theta, s = Og.phi - Pg.phi, h = Og.radius - Pg.radius;
            this._sphericalEnd.set(Pg.radius + h * p, Pg.phi + s * p, Pg.theta + c * p), this.normalizeRotations(), d || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd)), this._needsUpdate = !0
        }, qg.prototype.setPosition = function(t, e, n, r) { void 0 === r && (r = !1), this.setLookAt(t, e, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, r) }, qg.prototype.setTarget = function(t, e, n, r) {
            void 0 === r && (r = !1);
            var i = this.getPosition(Eg);
            this.setLookAt(i.x, i.y, i.z, t, e, n, r)
        }, qg.prototype.setFocalOffset = function(t, e, n, r) { void 0 === r && (r = !1), this._focalOffsetEnd.set(t, e, n), r || this._focalOffset.copy(this._focalOffsetEnd), this._needsUpdate = !0 }, qg.prototype.setBoundary = function(t) {
            if (!t) return this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), void(this._needsUpdate = !0);
            this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0
        }, qg.prototype.setViewport = function(t, e, n, r) { null !== t ? (this._viewport = this._viewport || new xg.Vector4, "number" == typeof t ? this._viewport.set(t, e, n, r) : this._viewport.copy(t)) : this._viewport = null }, qg.prototype.getDistanceToFitBox = function(t, e, n) {
            if (vg(this._camera, "getDistanceToFit")) return this._spherical.radius;
            var r = this._camera,
                i = t / e,
                o = r.getEffectiveFOV() * xg.MathUtils.DEG2RAD,
                r = r.aspect;
            return .5 * (i < r ? e : t / r) / Math.tan(.5 * o) + .5 * n
        }, qg.prototype.getDistanceToFit = function(t, e, n) { return console.warn("camera-controls: getDistanceToFit() has been renamed to getDistanceToFitBox()"), this.getDistanceToFitBox(t, e, n) }, qg.prototype.getDistanceToFitSphere = function(t) {
            if (vg(this._camera, "getDistanceToFitSphere")) return this._spherical.radius;
            var e = this._camera,
                n = e.getEffectiveFOV() * xg.MathUtils.DEG2RAD,
                r = 2 * Math.atan(Math.tan(.5 * n) * e.aspect),
                r = 1 < e.aspect ? n : r;
            return t / Math.sin(.5 * r)
        }, qg.prototype.getTarget = function(t) { return (t && t.isVector3 ? t : new xg.Vector3).copy(this._targetEnd) }, qg.prototype.getPosition = function(t) { return (t && t.isVector3 ? t : new xg.Vector3).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd) }, qg.prototype.getFocalOffset = function(t) { return (t && t.isVector3 ? t : new xg.Vector3).copy(this._focalOffsetEnd) }, qg.prototype.normalizeRotations = function() { this._sphericalEnd.theta = this._sphericalEnd.theta % cg, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += cg), this._spherical.theta += cg * Math.round((this._sphericalEnd.theta - this._spherical.theta) / cg) }, qg.prototype.reset = function(t) { void 0 === t && (t = !1), this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t), this.zoomTo(this._zoom0, t) }, qg.prototype.saveState = function() { this._target0.copy(this._target), this._position0.copy(this._camera.position), this._zoom0 = this._zoom }, qg.prototype.updateCameraUp = function() { this._yAxisUpSpace.setFromUnitVectors(this._camera.up, wg), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).inverse() }, qg.prototype.update = function(t) {
            var e = this._state === ag.NONE ? this.dampingFactor : this.draggingDampingFactor,
                n = 1 - Math.exp(-e * t * 62.5),
                r = this._sphericalEnd.theta - this._spherical.theta,
                i = this._sphericalEnd.phi - this._spherical.phi,
                o = this._sphericalEnd.radius - this._spherical.radius,
                e = Eg.subVectors(this._targetEnd, this._target),
                t = Tg.subVectors(this._focalOffsetEnd, this._focalOffset);
            hg(r) && hg(i) && hg(o) && hg(e.x) && hg(e.y) && hg(e.z) && hg(t.x) && hg(t.y) && hg(t.z) ? (this._spherical.copy(this._sphericalEnd), this._target.copy(this._targetEnd), this._focalOffset.copy(this._focalOffsetEnd)) : (this._spherical.set(this._spherical.radius + o * n, this._spherical.phi + i * n, this._spherical.theta + r * n), this._target.add(e.multiplyScalar(n)), this._focalOffset.add(t.multiplyScalar(n)), this._needsUpdate = !0), 0 !== this._dollyControlAmount && (this._camera.isPerspectiveCamera && (i = this._camera, a = Eg.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), 0 === (r = Tg.copy(a).cross(i.up).normalize()).lengthSq() && (r.x = 1), e = Ag.crossVectors(r, a), t = this._sphericalEnd.radius * Math.tan(i.getEffectiveFOV() * xg.MathUtils.DEG2RAD * .5), a = (this._sphericalEnd.radius - this._dollyControlAmount - this._sphericalEnd.radius) / this._sphericalEnd.radius, t = Eg.copy(this._targetEnd).add(r.multiplyScalar(this._dollyControlCoord.x * t * i.aspect)).add(e.multiplyScalar(this._dollyControlCoord.y * t)), this._targetEnd.lerp(t, a), this._target.copy(this._targetEnd)), this._dollyControlAmount = 0);
            var a = this._collisionTest();
            this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), hg(this._focalOffset.x) && hg(this._focalOffset.y) && hg(this._focalOffset.z) || (this._camera.updateMatrix(), Lg.setFromMatrixColumn(this._camera.matrix, 0), Rg.setFromMatrixColumn(this._camera.matrix, 1), Cg.setFromMatrixColumn(this._camera.matrix, 2), Lg.multiplyScalar(this._focalOffset.x), Rg.multiplyScalar(-this._focalOffset.y), Cg.multiplyScalar(this._focalOffset.z), Eg.copy(Lg).add(Rg).add(Cg), this._camera.position.add(Eg)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Eg.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
            a = this._zoomEnd - this._zoom;
            this._zoom += a * n, this._camera.zoom !== this._zoom && (hg(a) && (this._zoom = this._zoomEnd), this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0);
            a = this._needsUpdate;
            return a && !this._updatedLastTime ? (this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : a ? this.dispatchEvent({ type: "update" }) : !a && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._updatedLastTime = a, this._needsUpdate = !1, a
        }, qg.prototype.toJSON = function() { return JSON.stringify({ enabled: this._enabled, minDistance: this.minDistance, maxDistance: dg(this.maxDistance), minZoom: this.minZoom, maxZoom: dg(this.maxZoom), minPolarAngle: this.minPolarAngle, maxPolarAngle: dg(this.maxPolarAngle), minAzimuthAngle: dg(this.minAzimuthAngle), maxAzimuthAngle: dg(this.maxAzimuthAngle), dampingFactor: this.dampingFactor, draggingDampingFactor: this.draggingDampingFactor, dollySpeed: this.dollySpeed, truckSpeed: this.truckSpeed, dollyToCursor: this.dollyToCursor, verticalDragToForward: this.verticalDragToForward, target: this._targetEnd.toArray(), position: Eg.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(), zoom: this._zoomEnd, focalOffset: this._focalOffsetEnd.toArray(), target0: this._target0.toArray(), position0: this._position0.toArray(), zoom0: this._zoom0, focalOffset0: this._focalOffset0.toArray() }) }, qg.prototype.fromJSON = function(t, e) {
            void 0 === e && (e = !1);
            var n = JSON.parse(t),
                t = Eg.fromArray(n.position);
            this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = fg(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = fg(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = fg(n.maxPolarAngle), this.minAzimuthAngle = fg(n.minAzimuthAngle), this.maxAzimuthAngle = fg(n.maxAzimuthAngle), this.dampingFactor = n.dampingFactor, this.draggingDampingFactor = n.draggingDampingFactor, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], e), Pg.setFromVector3(t.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Pg.theta, Pg.phi, e), this.zoomTo(n.zoom, e), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], e), this._needsUpdate = !0
        }, qg.prototype.dispose = function() { this._removeAllEventListeners() }, qg.prototype._encloseToBoundary = function(t, e, n) {
            var r = e.lengthSq();
            if (0 === r) return t;
            var i = Tg.copy(e).add(t),
                o = this._boundary.clampPoint(i, Ag).sub(i),
                i = o.lengthSq();
            if (0 === i) return t.add(e);
            if (i === r) return t;
            if (0 === n) return t.add(e).add(o);
            i = 1 + n * i / e.dot(o);
            return t.add(Tg.copy(e).multiplyScalar(i)).add(o.multiplyScalar(1 - n))
        }, qg.prototype._updateNearPlaneCorners = function() {
            var t, e, n, r, i;
            this._camera.isPerspectiveCamera ? (e = (t = this._camera).near, i = t.getEffectiveFOV() * xg.MathUtils.DEG2RAD, n = (r = Math.tan(.5 * i) * e) * t.aspect, this._nearPlaneCorners[0].set(-n, -r, 0), this._nearPlaneCorners[1].set(n, -r, 0), this._nearPlaneCorners[2].set(n, r, 0), this._nearPlaneCorners[3].set(-n, r, 0)) : this._camera.isOrthographicCamera && (i = 1 / (t = this._camera).zoom, e = t.left * i, n = t.right * i, r = t.top * i, i = t.bottom * i, this._nearPlaneCorners[0].set(e, r, 0), this._nearPlaneCorners[1].set(n, r, 0), this._nearPlaneCorners[2].set(n, i, 0), this._nearPlaneCorners[3].set(e, i, 0))
        }, qg.prototype._collisionTest = function() {
            var t = 1 / 0;
            if (!(1 <= this.colliderMeshes.length)) return t;
            if (vg(this._camera, "_collisionTest")) return t;
            t = this._spherical.radius;
            var e = Eg.setFromSpherical(this._spherical).divideScalar(t);
            Ug.lookAt(bg, e, this._camera.up);
            for (var n = 0; n < 4; n++) {
                var r = Tg.copy(this._nearPlaneCorners[n]);
                r.applyMatrix4(Ug);
                r = Ag.addVectors(this._target, r);
                zg.set(r, e), zg.far = t;
                r = zg.intersectObjects(this.colliderMeshes);
                0 !== r.length && r[0].distance < t && (t = r[0].distance)
            }
            return t
        }, qg.prototype._getClientRect = function(t) { var e = this._domElement.getBoundingClientRect(); return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.z = this._viewport.z, t.w = this._viewport.w) : (t.z = e.width, t.w = e.height), t }, qg.prototype._removeAllEventListeners = function() {}, qg);

    function Wg() { this.constructor = kg }

    function qg(t, e) {
        var s, c, l, u, h, p, d, f, n, r, i, o, a, m, g, v, y, _ = Hg.call(this) || this;
        return _.minPolarAngle = 0, _.maxPolarAngle = Math.PI, _.minAzimuthAngle = -1 / 0, _.maxAzimuthAngle = 1 / 0, _.minDistance = 0, _.maxDistance = 1 / 0, _.infinityDolly = !1, _.minZoom = .01, _.maxZoom = 1 / 0, _.dampingFactor = .05, _.draggingDampingFactor = .25, _.azimuthRotateSpeed = 1, _.polarRotateSpeed = 1, _.dollySpeed = 1, _.truckSpeed = 2, _.dollyToCursor = !1, _.dragToOffset = !1, _.verticalDragToForward = !1, _.boundaryFriction = 0, _.colliderMeshes = [], _.cancel = function() {}, _._enabled = !0, _._state = ag.NONE, _._viewport = null, _._dollyControlAmount = 0, _._boundaryEnclosesCamera = !1, _._needsUpdate = !0, _._updatedLastTime = !1, void 0 === xg && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), _._camera = t, _._yAxisUpSpace = (new xg.Quaternion).setFromUnitVectors(_._camera.up, wg), _._yAxisUpSpaceInverse = _._yAxisUpSpace.clone().inverse(), _._state = ag.NONE, _._domElement = e, _._target = new xg.Vector3, _._targetEnd = _._target.clone(), _._focalOffset = new xg.Vector3, _._focalOffsetEnd = _._focalOffset.clone(), _._spherical = (new xg.Spherical).setFromVector3(Eg.copy(_._camera.position).applyQuaternion(_._yAxisUpSpace)), _._sphericalEnd = _._spherical.clone(), _._zoom = _._camera.zoom, _._zoomEnd = _._zoom, _._nearPlaneCorners = [new xg.Vector3, new xg.Vector3, new xg.Vector3, new xg.Vector3], _._updateNearPlaneCorners(), _._boundary = new xg.Box3(new xg.Vector3(-1 / 0, -1 / 0, -1 / 0), new xg.Vector3(1 / 0, 1 / 0, 1 / 0)), _._target0 = _._target.clone(), _._position0 = _._camera.position.clone(), _._zoom0 = _._zoom, _._focalOffset0 = _._focalOffset.clone(), _._dollyControlAmount = 0, _._dollyControlCoord = new xg.Vector2, _.mouseButtons = { left: ag.ROTATE, middle: ag.DOLLY, right: ag.TRUCK, wheel: _._camera.isPerspectiveCamera ? ag.DOLLY : _._camera.isOrthographicCamera ? ag.ZOOM : ag.NONE }, _.touches = { one: ag.TOUCH_ROTATE, two: _._camera.isPerspectiveCamera ? ag.TOUCH_DOLLY_TRUCK : _._camera.isOrthographicCamera ? ag.TOUCH_ZOOM_TRUCK : ag.NONE, three: ag.TOUCH_TRUCK }, _._domElement && (s = new xg.Vector2, c = new xg.Vector2, l = new xg.Vector2, u = new xg.Vector4, h = function(t, e, n) {
            var r, i;
            _._camera.isPerspectiveCamera ? (r = _._camera, i = Eg.copy(r.position).sub(_._target), r = r.getEffectiveFOV() * xg.MathUtils.DEG2RAD, i = i.length() * Math.tan(.5 * r), r = _.truckSpeed * t * i / u.w, i = _.truckSpeed * e * i / u.w, _.verticalDragToForward ? (n ? _.setFocalOffset(_._focalOffsetEnd.x + r, _._focalOffsetEnd.y, _._focalOffsetEnd.z, !0) : _.truck(r, 0, !0), _.forward(-i, !0)) : n ? _.setFocalOffset(_._focalOffsetEnd.x + r, _._focalOffsetEnd.y + i, _._focalOffsetEnd.z, !0) : _.truck(r, i, !0)) : _._camera.isOrthographicCamera && (r = t * ((t = _._camera).right - t.left) / t.zoom / u.z, i = e * (t.top - t.bottom) / t.zoom / u.w, n ? _.setFocalOffset(_._focalOffsetEnd.x + r, _._focalOffsetEnd.y + i, _._focalOffsetEnd.z, !0) : _.truck(r, i, !0))
        }, p = function(t, e) {
            t = cg * _.azimuthRotateSpeed * t / u.w, e = cg * _.polarRotateSpeed * e / u.w;
            _.rotate(t, e, !0)
        }, d = function(t, e, n) {
            var r = Math.pow(.95, -t * _.dollySpeed),
                t = _._sphericalEnd.radius * r,
                r = _._sphericalEnd.radius;
            _.dollyTo(t), _.infinityDolly && t < _.minDistance && (_._camera.getWorldDirection(Eg), _._targetEnd.add(Eg.normalize().multiplyScalar(r)), _._target.add(Eg.normalize().multiplyScalar(r))), _.dollyToCursor && (_._dollyControlAmount += _._sphericalEnd.radius - r, _._dollyControlCoord.set(e, n))
        }, f = function(t) {
            t = Math.pow(.95, t * _.dollySpeed);
            _.zoomTo(_._zoom * t)
        }, n = function() { _._state = ag.NONE, document.removeEventListener("mousemove", v), document.removeEventListener("touchmove", v, { passive: !1 }), document.removeEventListener("mouseup", y), document.removeEventListener("touchend", y) }, r = function(t) {
            if (_._enabled) {
                switch (n(), t.button) {
                    case xg.MOUSE.LEFT:
                        _._state = _.mouseButtons.left;
                        break;
                    case xg.MOUSE.MIDDLE:
                        _._state = _.mouseButtons.middle;
                        break;
                    case xg.MOUSE.RIGHT:
                        _._state = _.mouseButtons.right
                }
                g(t)
            }
        }, i = function(t) {
            if (_._enabled) {
                switch (n(), t.touches.length) {
                    case 1:
                        _._state = _.touches.one;
                        break;
                    case 2:
                        _._state = _.touches.two;
                        break;
                    case 3:
                        _._state = _.touches.three
                }
                g(t)
            }
        }, o = -1, a = function(t) {
            if (_._enabled && _.mouseButtons.wheel !== ag.NONE) {
                t.preventDefault(), !_.dollyToCursor && _.mouseButtons.wheel !== ag.ROTATE && _.mouseButtons.wheel !== ag.TRUCK || (e = performance.now(), o - e < 1e3 && _._getClientRect(u), o = e);
                var e = Vg ? -1 : -3,
                    n = 1 === t.deltaMode ? t.deltaY / e : t.deltaY / (10 * e),
                    r = _.dollyToCursor ? (t.clientX - u.x) / u.z * 2 - 1 : 0,
                    i = _.dollyToCursor ? (t.clientY - u.y) / u.w * -2 + 1 : 0;
                switch (_.mouseButtons.wheel) {
                    case ag.ROTATE:
                        p(t.deltaX, t.deltaY);
                        break;
                    case ag.TRUCK:
                        h(t.deltaX, t.deltaY, !1);
                        break;
                    case ag.OFFSET:
                        h(t.deltaX, t.deltaY, !0);
                        break;
                    case ag.DOLLY:
                        d(-n, r, i);
                        break;
                    case ag.ZOOM:
                        f(-n)
                }
                _.dispatchEvent({ type: "control", originalEvent: t })
            }
        }, m = function(t) { _._enabled && t.preventDefault() }, g = function(t) {
            var e, n, r;
            _._enabled && (gg(t, Sg), _._getClientRect(u), s.copy(Sg), c.copy(Sg), mg(t) && 2 <= t.touches.length && (r = t, e = Sg.x - r.touches[1].clientX, n = Sg.y - r.touches[1].clientY, n = Math.sqrt(e * e + n * n), l.set(0, n), n = .5 * (r.touches[0].clientX + r.touches[1].clientX), r = .5 * (r.touches[0].clientY + r.touches[1].clientY), c.set(n, r)), document.addEventListener("mousemove", v), document.addEventListener("touchmove", v, { passive: !1 }), document.addEventListener("mouseup", y), document.addEventListener("touchend", y), _.dispatchEvent({ type: "controlstart", originalEvent: t }))
        }, v = function(t) {
            if (_._enabled) {
                t.preventDefault(), gg(t, Sg);
                var e = c.x - Sg.x,
                    n = c.y - Sg.y;
                switch (c.copy(Sg), _._state) {
                    case ag.ROTATE:
                    case ag.TOUCH_ROTATE:
                        p(e, n);
                        break;
                    case ag.DOLLY:
                    case ag.ZOOM:
                        var r = _.dollyToCursor ? (s.x - u.x) / u.z * 2 - 1 : 0,
                            i = _.dollyToCursor ? (s.y - u.y) / u.w * -2 + 1 : 0;
                        _._state === ag.DOLLY ? d(1 / 8 * n, r, i) : f(1 / 8 * n);
                        break;
                    case ag.TOUCH_DOLLY:
                    case ag.TOUCH_ZOOM:
                    case ag.TOUCH_DOLLY_TRUCK:
                    case ag.TOUCH_ZOOM_TRUCK:
                    case ag.TOUCH_DOLLY_OFFSET:
                    case ag.TOUCH_ZOOM_OFFSET:
                        var o = Sg.x - t.touches[1].clientX,
                            a = Sg.y - t.touches[1].clientY,
                            o = Math.sqrt(o * o + a * a),
                            a = l.y - o;
                        l.set(0, o);
                        r = _.dollyToCursor ? (c.x - u.x) / u.z * 2 - 1 : 0, i = _.dollyToCursor ? (c.y - u.y) / u.w * -2 + 1 : 0;
                        _._state === ag.TOUCH_DOLLY || _._state === ag.TOUCH_DOLLY_TRUCK ? d(1 / 8 * a, r, i) : f(1 / 8 * a), _._state === ag.TOUCH_DOLLY_TRUCK || _._state === ag.TOUCH_ZOOM_TRUCK ? h(e, n, !1) : _._state !== ag.TOUCH_DOLLY_OFFSET && _._state !== ag.TOUCH_ZOOM_OFFSET || h(e, n, !0);
                        break;
                    case ag.TRUCK:
                    case ag.TOUCH_TRUCK:
                        h(e, n, !1);
                        break;
                    case ag.OFFSET:
                    case ag.TOUCH_OFFSET:
                        h(e, n, !0)
                }
                _.dispatchEvent({ type: "control", originalEvent: t })
            }
        }, y = function(t) { _._enabled && (n(), _.dispatchEvent({ type: "controlend", originalEvent: t })) }, _._domElement.addEventListener("mousedown", r), _._domElement.addEventListener("touchstart", i), _._domElement.addEventListener("wheel", a), _._domElement.addEventListener("contextmenu", m), _._removeAllEventListeners = function() { _._domElement.removeEventListener("mousedown", r), _._domElement.removeEventListener("touchstart", i), _._domElement.removeEventListener("wheel", a), _._domElement.removeEventListener("contextmenu", m), document.removeEventListener("mousemove", v), document.removeEventListener("touchmove", v, { passive: !1 }), document.removeEventListener("mouseup", y), document.removeEventListener("touchend", y) }, _.cancel = function() { n(), _.dispatchEvent({ type: "controlend", originalEvent: null }) }), _.update(0), _
    }
    nl.install({ THREE: Cl });
    var Xg = new nl(rg, ig.domElement),
        nl = function(t, e) {
            this.el = t, this.menuItems = this.el.querySelectorAll(".menu-item"), this.menuScrollItems = this.el.querySelectorAll(".menu-item[data-anchor]"), this.buttonEl = e, this.overlayEl = Wm, this.isOpen = !1, _f.set(this.el, { translateX: "100%" }), this.buttonEl.addEventListener("click", this), this.overlayEl.addEventListener("click", this);
            for (var n = 0; n < this.menuScrollItems.length; n++) this.menuScrollItems[n].addEventListener("click", this);
            window.addEventListener("keydown", this)
        };
    nl.prototype.scrollTo = function(t) { this.close(), _f({ targets: Hm, scrollTop: Hm.querySelector(t).offsetTop, duration: 1500, easing: "easeOutCubic" }) }, nl.prototype.open = function() { zm.canRender = !1, this.isOpen = !0, this.buttonEl.classList.add("is-open"), wf.bodyEl.classList.add("menu-is-open"), this.overlayEl.classList.add("is-active"), _f.timeline({ easing: "easeOutQuad", duration: 350 }).add({ targets: this.el, translateX: "0%", translateZ: 0 }, 0).add({ targets: "canvas", translateX: "-150px", translateZ: 0 }, 0).add({ targets: this.menuItems, translateX: ["125px", "0px"], delay: _f.stagger(40) }, 0) }, nl.prototype.close = function() { this.isOpen = !1, this.buttonEl.classList.remove("is-open"), wf.bodyEl.classList.remove("menu-is-open"), this.overlayEl.classList.remove("is-active"), _f.timeline({ easing: "easeOutQuad", duration: 350, complete: function() { zm.canRender = !0 } }).add({ targets: this.el, translateX: "100%" }, 0).add({ targets: "canvas", translateX: 0 }, 0) }, nl.prototype.toggle = function() { this.isOpen ? this.close() : this.open() }, nl.prototype.handleEvent = function(t) {
        switch (t.type) {
            case "click":
                var e = t.target.dataset.anchor;
                e ? this.scrollTo(e) : this.toggle();
            case "keydown":
                "Escape" === t.key && this.close()
        }
    };

    function Yg(t) { this.el = document.getElementById(t), this.onClose = function() {} }
    new nl(tl, jm);
    Yg.prototype.open = function() { zm.canRender = !1, km.classList.add("is-active"), wf.bodyEl.classList.add("page-is-open"), wf.bodyEl.classList.remove("is-hover"), this.el.classList.add("is-open"), this.el.scrollTop = 0 }, Yg.prototype.close = function() { setTimeout(function() { wf.bodyEl.classList.remove("page-is-open"), wf.bodyEl.classList.remove("invert-ui"), km.classList.remove("is-active"), this.el.classList.remove("is-open"), zm.canRender = !0, this.onClose() }.bind(this), 1) };
    tl = function() { this.list = {}, this.closeActivePageButtonEl = qm, this.closeActivePageButtonEl.addEventListener("click", this), window.addEventListener("keydown", this) };
    tl.prototype.addPage = function(t) { this.list[t] = new Yg(t) }, tl.prototype.getPageContent = function(t, e) { return fetch(t).then(function(t) { return t.text() }).then(function(t) { t = (new DOMParser).parseFromString(t, "text/html"); return (e ? t.querySelector(e) : t.body).innerHTML }).catch(function(t) { console.log("Failed to fetch page: ", t) }) }, tl.prototype.openPage = function(t, e) { var n = this.list[t]; return n.open(), this.closeActivePageButtonEl.classList.add("is-visible"), n.el.focus(), e && e(n.el), new Promise(function(t, e) { t(n.el), e("Error loading the page") }) }, tl.prototype.closePages = function() {
        for (var t in this.list) this.list[t].close();
        setTimeout(function() { qm.classList.remove("is-visible"), Xm.pause(), Ym.pause() }.bind(this), 1)
    }, tl.prototype.handleEvent = function(t) {
        switch (t.type) {
            case "click":
                this.closePages();
                break;
            case "keydown":
                "Escape" === t.key && this.closePages()
        }
    };
    var Zg = new tl;
    new Ou;

    function Jg(t, e) { return t && e ? Math.floor(An.seededRandom() * (e - t + 1)) + t : An.seededRandom() }

    function Kg(t, e, n, r, i) {
        void 0 === i && (i = 2);
        var o = Jg(),
            a = Jg(),
            o = i * Math.PI * o,
            a = Math.acos(2 * a - 1);
        return [t + r * Math.sin(a) * Math.cos(o), e + r * Math.sin(a) * Math.sin(o), n + r * Math.cos(a)]
    }
    An.seededRandom(11);
    var Qg = function(t) { this.el = t, this.dataSrc = this.el.dataset.src, this.intersected = !1, this.observer = new IntersectionObserver(this.handleIntersect.bind(this)), this.observer.observe(this.el), this.el.addEventListener("load", this) };

    function $g(t) { for (var e = t.querySelectorAll("img[data-src]"), n = 0, r = e.length; n < r; n++) new Qg(e[n], t) }
    Qg.prototype.onLoad = function() { this.intersected && (this.el.classList.add("is-loaded"), this.el.removeAttribute("data-src")) }, Qg.prototype.handleEvent = function(t) { "load" === t.type && this.onLoad() }, Qg.prototype.handleIntersect = function(t) { t[0].isIntersecting && (this.intersected = !0, this.observer.unobserve(this.el), this.el.src = this.dataSrc) };
    var tv = function(t, e) { this.el = t, this.pageEl = e, this.setExpandDirection(), this.el.addEventListener("click", this), this.el.addEventListener("mouseenter", this), window.addEventListener("resize", this) };
    tv.prototype.toggleExapend = function() {
        if (this.el.classList.contains("is-expanded")) this.el.classList.remove("is-expanded");
        else {
            for (var t = this.pageEl.querySelectorAll(".product.is-expanded"), e = 0; e < t.length; e++) t[e] !== this.el && t[e].classList.remove("is-expanded");
            this.el.classList.add("is-expanded")
        }
    }, tv.prototype.setExpandDirection = function() {
        this.el.classList.remove("expand-left");
        var t = this.el.getBoundingClientRect();
        t.width > wf.width - t.right && this.el.classList.add("expand-left"), this.el.offsetTop + 2 * t.height > this.pageEl.scrollHeight && this.el.classList.add("expand-top")
    }, tv.prototype.handleEvent = function(t) {
        switch (t.type) {
            case "click":
                this.toggleExapend();
                break;
            case "resize":
                this.setExpandDirection()
        }
    };
    var ev = function() {
        var t = ev.SkyShader,
            t = new mo({ fragmentShader: t.fragmentShader, vertexShader: t.vertexShader, uniforms: ho.clone(t.uniforms), side: j, depthWrite: !1 });
        $i.call(this, new co(1, 1, 1), t)
    };
    ev.prototype = Object.create($i.prototype), ev.SkyShader = { uniforms: { luminance: { value: 1 }, turbidity: { value: 2 }, rayleigh: { value: 1 }, mieCoefficient: { value: .005 }, mieDirectionalG: { value: .8 }, sunPosition: { value: new kn }, up: { value: new kn(0, 1, 0) } }, vertexShader: ["uniform vec3 sunPosition;", "uniform float rayleigh;", "uniform float turbidity;", "uniform float mieCoefficient;", "uniform vec3 up;", "varying vec3 vWorldPosition;", "varying vec3 vSunDirection;", "varying float vSunfade;", "varying vec3 vBetaR;", "varying vec3 vBetaM;", "varying float vSunE;", "const float e = 2.71828182845904523536028747135266249775724709369995957;", "const float pi = 3.141592653589793238462643383279502884197169;", "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );", "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );", "const float v = 4.0;", "const vec3 K = vec3( 0.686, 0.678, 0.666 );", "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );", "const float cutoffAngle = 1.6110731556870734;", "const float steepness = 1.5;", "const float EE = 1000.0;", "float sunIntensity( float zenithAngleCos ) {", "\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );", "\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );", "}", "vec3 totalMie( float T ) {", "\tfloat c = ( 0.2 * T ) * 10E-18;", "\treturn 0.434 * c * MieConst;", "}", "void main() {", "\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "\tvWorldPosition = worldPosition.xyz;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "\tgl_Position.z = gl_Position.w;", "\tvSunDirection = normalize( sunPosition );", "\tvSunE = sunIntensity( dot( vSunDirection, up ) );", "\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );", "\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );", "\tvBetaR = totalRayleigh * rayleighCoefficient;", "\tvBetaM = totalMie( turbidity ) * mieCoefficient;", "}"].join("\n"), fragmentShader: ["varying vec3 vWorldPosition;", "varying vec3 vSunDirection;", "varying float vSunfade;", "varying vec3 vBetaR;", "varying vec3 vBetaM;", "varying float vSunE;", "uniform float luminance;", "uniform float mieDirectionalG;", "uniform vec3 up;", "const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );", "const float pi = 3.141592653589793238462643383279502884197169;", "const float n = 1.0003;", "const float N = 2.545E25;", "const float rayleighZenithLength = 8.4E3;", "const float mieZenithLength = 1.25E3;", "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;", "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;", "const float ONE_OVER_FOURPI = 0.07957747154594767;", "float rayleighPhase( float cosTheta ) {", "\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );", "}", "float hgPhase( float cosTheta, float g ) {", "\tfloat g2 = pow( g, 2.0 );", "\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );", "\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );", "}", "const float A = 0.15;", "const float B = 0.50;", "const float C = 0.10;", "const float D = 0.20;", "const float E = 0.02;", "const float F = 0.30;", "const float whiteScale = 1.0748724675633854;", "vec3 Uncharted2Tonemap( vec3 x ) {", "\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;", "}", "void main() {", "\tvec3 direction = normalize( vWorldPosition - cameraPos );", "\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );", "\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );", "\tfloat sR = rayleighZenithLength * inverse;", "\tfloat sM = mieZenithLength * inverse;", "\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );", "\tfloat cosTheta = dot( direction, vSunDirection );", "\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );", "\tvec3 betaRTheta = vBetaR * rPhase;", "\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );", "\tvec3 betaMTheta = vBetaM * mPhase;", "\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );", "\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );", "\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]", "\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]", "\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );", "\tvec3 L0 = vec3( 0.1 ) * Fex;", "\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );", "\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;", "\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );", "\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );", "\tvec3 color = curr * whiteScale;", "\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );", "\tgl_FragColor = vec4( retColor, 1.0 );", "}"].join("\n") };
    var nv = function(t, e, n, r, i) { void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === i && (i = Jg(120, 300)), this.sprite = new $s(eg.materials[t]), this.sprite.position.set(e, n, r), this.sprite.scale.setScalar(i), ng.add(this.sprite) },
        rv = function(t, e, n, r, i, o, a) { void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), this.group = new As, this.group.position.set(e, n, r), this.group.rotation.set(An.degToRad(i), An.degToRad(o), An.degToRad(a)), ng.add(this.group), this.images = [], this.videos = [], this.markerPosition = new kn, this.marker = this.addMarker(0, 0, 5), this.group.getWorldPosition(this.markerPosition), this.marker.getWorldPosition(this.markerPosition), this.domEl = document.createElement("section"), this.domEl.classList.add("site-section"), this.domEl.id = t, Hm.appendChild(this.domEl) };
    rv.prototype.addMarker = function(t, e, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0); var r = new $i(new so(.5, .5, .5), new di({ color: 16711680, transparent: !0, opacity: .5 })); return r.visible = !1, r.position.set(t, e, n), this.group.add(r), r }, rv.prototype._getResizedMediaDimensions = function(t, e, n, r) {
        var i = t * (wf.width / wf.height),
            t = r * (i / n);
        return e < t && (i = n * ((t = e) / r)), { width: i, height: t }
    }, rv.prototype.addImage = function(t, e, n, r, i) {
        void 0 === e && (e = 5), void 0 === n && (n = 5), void 0 === r && (r = { x: 0, y: 0, z: 0 });
        var o = eg.imageTextures[t],
            t = new di({ map: o, transparent: !0, depthTest: !1 }),
            o = this._getResizedMediaDimensions(e, n, o.image.width, o.image.height),
            t = new $i(new To(o.width, o.height), t);
        return t.userData.onClick = i, t.position.x = r.x, t.position.y = r.y, t.position.z = r.z, this.group.add(t), this.images.push(t), t
    }, rv.prototype.addVideo = function(t, e, n, r, i) {
        void 0 === e && (e = 3.5), void 0 === n && (n = 3.5), void 0 === r && (r = { x: 0, y: 0, z: 0 });
        var o = document.getElementById(t);
        o.currentTime = .1, o.play();
        var a = this._getResizedMediaDimensions(e, n, 1280, 720),
            t = new Fc(o);
        t.encoding = sn;
        t = new di({ map: t, transparent: !0, depthTest: !1 }), t = new $i(new To(a.width, a.height), t);
        return 2 <= o.readyState && (a = this._getResizedMediaDimensions(e, n, 1280, 720), t.geometry.width = a.width, t.geometry.height = a.height), t.userData.onClick = i, t.position.x = r.x, t.position.y = r.y, t.position.z = r.z, this.group.add(t), this.videos.push(t), t
    };
    tl = function(t) {
        this.el = t, this.y = this.el.scrollTop, this.height = this.el.scrollHeight - this.el.offsetHeight, this.progress = this.y / this.height || 0;
        t = this._captureScrollPosition.bind(this);
        Hm.addEventListener("scroll", t, !1), window.addEventListener("reisze", t, !1), t()
    };
    tl.prototype._captureScrollPosition = function() { this.y = this.el.scrollTop, this.height = this.el.scrollHeight - this.el.offsetHeight, this.progress = this.y / this.height || 0 };
    var iv = new tl(Hm),
        ov = {},
        av = {};

    function sv() {
        for (var t = 0; t < 80; t++) {
            var e = "cloud0" + Math.round(Jg(1, 5)),
                n = Kg(0, 0, 0, 350, 1);
            new nv(e, n[0], -n[1], n[2])
        }
        for (var r = 0; r < 8; r++) {
            var i = "cloud0" + Math.round(Jg(1, 4)),
                o = Kg(0, 50, 0, 400, 1);
            new nv(i, o[0], o[1], o[2])
        }
        Zg.addPage("campagnePage"), Zg.addPage("collectionPage"), Zg.addPage("innovationsPage"), Zg.addPage("entretienPage"), ov.start = new rv("start", -20, 20, 300, 0, 0, 0), ov.textIntro = new rv("textIntro", -20, 30, 250, -5, 0, 0), av.cloud01 = new nv("cloudSection03", -5, -2, 210, 80), av.cloud02 = new nv("cloudSection01", -25, 2, 235, 60), ov.textP01 = new rv("textP01", -30, 10, 200, 0, 55, 0), av.cloud03 = new nv("cloudSection04", -20, 20, 175, 60), ov.textP02 = new rv("textP02", -25, 0, 150, 0, 30, 0), av.cloud04 = new nv("cloudSection02", 5, 5, 130, 80), av.cloud042 = new nv("cloudSection42", 25, -15, 120, 80), ov.campagne = new rv("campagne", 25, -15, 100, 0, -45, 0), av.cloud05 = new nv("cloudSection05", 15, -30, 60, 70), ov.collection = new rv("collection", 25, -15, 50, 0, -30, 0), ov.innovations = new rv("innovations", 0, 0, 0, 0, 45, 0), av.cloud06 = new nv("cloudSection06", 30, 0, -25, 70), ov.entretien = new rv("entretien", 35, 15, -50, 0, -20, 0), av.cloud07 = new nv("cloudSection07", 68, 26, -85, 48), ov.outro = new rv("outro", 70, 38, -90, 0, -5, 0);
        var a = wf.isMinWidth("m") ? 4 : 6,
            s = wf.isMinWidth("m") ? 3.5 : 4.5;
        ov.textIntro.addImage("textIntro", a, 4), ov.textP01.addImage(wf.isMinWidth("m") ? "textParagraph01" : "textParagraph01S", 5, 5), ov.textP02.addImage(wf.isMinWidth("m") ? "textParagraph02" : "textParagraph02S", 5, 5), ov.campagne.addVideo("campagneVideoLoop", s, s, { x: 0, y: 0, z: 0 }, function() { Zg.openPage("campagnePage", function() { Xm.play() }) }), ov.campagne.addImage("playIcon", s, s, { x: 0, y: 0, z: .25 }), ov.collection.addImage("sectionCollection", 5, 5, { x: 0, y: 0, z: 0 }, function() {
            Zg.openPage("collectionPage").then(function(e) {
                wf.bodyEl.classList.add("invert-ui"), Zg.getPageContent("collection.html").then(function(t) {
                    e.innerHTML = t,
                        function(t) { $g(t); for (var e = t.querySelectorAll(".product"), n = 0; n < e.length; n++) new tv(e[n], t) }(e)
                })
            })
        }), ov.innovations.addImage("sectionInnovations", 5, 5, { x: 0, y: 0, z: 0 }, function() { Zg.openPage("innovationsPage").then(function(e) { wf.bodyEl.classList.add("invert-ui"), Zg.getPageContent("innovations.html").then(function(t) { e.innerHTML = t, $g(e) }) }) });
        a = eg.gltfModels.jacket;
        _f({ targets: a.rotation, y: An.degToRad(360), duration: 1e4, loop: !0, easing: "linear" }), a.position.set(0, -4.25, 0), a.scale.set(3.75, 3.75, 3.75), ov.innovations.group.add(a), wf.isMinWidth("s") ? ov.entretien.addImage("sectionEntretien", 5, 4, { x: 0, y: -1.1, z: 0 }) : ov.entretien.addImage("sectionEntretienS", 5, 5, { x: 0, y: 0, z: 0 }), ov.entretien.addVideo("entretienVideoLoop", s, s, { x: 0, y: 0, z: 0 }, function() { Zg.openPage("entretienPage", function() { Ym.play(), _f({ targets: ov.entretien.images[0].material, opacity: 0, easing: "linear", duration: 500 }) }) }), Zg.list.entretienPage.onClose = function() { _f({ targets: ov.entretien.images[0].material, opacity: 1, easing: "linear", duration: 500 }) }, ov.entretien.addImage("playIcon", s, s, { x: 0, y: 0, z: .25 }), ov.outro.addImage("sectionOutro", 5, 4, { x: 0, y: 0, z: 0 }, function() { Qm.click() });
        var c = { x: ov.start.markerPosition.x, y: ov.start.markerPosition.y, z: ov.start.markerPosition.z, lookAtX: ov.start.group.position.x, lookAtY: ov.start.group.position.y, lookAtZ: ov.start.group.position.z };

        function l(t) { Xg.setLookAt(c.x, c.y, c.z, c.lookAtX, c.lookAtY, c.lookAtZ, t) }
        l(!1),
            function() {
                var r = new ev;
                r.scale.setScalar(5e4), ng.add(r);
                var i = new kn,
                    o = { turbidity: 1.5, rayleigh: .5, mieCoefficient: .005, mieDirectionalG: .7, inclination: .05, azimuth: .2, exposure: ig.toneMappingExposure };

                function t() {
                    var t = r.material.uniforms;
                    t.turbidity.value = o.turbidity, t.rayleigh.value = o.rayleigh, t.mieCoefficient.value = o.mieCoefficient, t.mieDirectionalG.value = o.mieDirectionalG;
                    var e = Math.PI * (o.inclination - .5),
                        n = 2 * Math.PI * (o.azimuth - .5);
                    i.x = Math.cos(n), i.y = Math.sin(n) * Math.sin(e), i.z = Math.sin(n) * Math.cos(e), t.sunPosition.value.copy(i), ig.toneMappingExposure = o.exposure, ig.render(ng, rg)
                }
                var e = Fm.addFolder("SKY");
                e.add(o, "turbidity", 0, 20, .1).onChange(t), e.add(o, "rayleigh", 0, 4, .001).onChange(t), e.add(o, "mieCoefficient", 0, .1, .001).onChange(t), e.add(o, "mieDirectionalG", 0, 1, .001).onChange(t), e.add(o, "inclination", 0, 1, 1e-4).onChange(t), e.add(o, "azimuth", 0, 1, 1e-4).onChange(t), e.add(o, "exposure", 0, 1, 1e-4).onChange(t), t()
            }(),
            function() {
                var t, e, n, r = _f.timeline({ easing: "easeInOutQuad", duration: 5e3, begin: function() { Xg.enabled = !1 }, update: function() { l(!0) }, autoplay: !1 });
                for (t in ov) "start" !== t && (e = (n = ov[t]).markerPosition, n = n.group.position, r.add({ targets: c, x: e.x, y: e.y, z: e.z, lookAtX: { value: n.x, duration: 4e3 }, lookAtY: { value: n.y, duration: 4e3 }, lookAtZ: { value: n.z, duration: 4e3 } }));
                r.add({ targets: [Vm], translateY: [{ value: [200, 0], duration: 2e3 }, { value: 200, duration: 3e3 }], easing: "easeInOutQuad" }, 3e3), r.add({ targets: [Gm, jm], opacity: [0, 1], easing: "linear", duration: 500, delay: 2500 }, 5e3), r.add({ targets: [av.cloud01.sprite.material.uniforms.uAlpha, av.cloud02.sprite.material.uniforms.uAlpha], value: 0, easing: "linear", duration: 1500, delay: _f.stagger(300, { start: 1e3 }) }, 5e3), r.add({ targets: [av.cloud03.sprite.material.uniforms.uAlpha], value: 0, easing: "linear", duration: 1e3, delay: 2e3 }, 1e4), r.add({ targets: [av.cloud04.sprite.material.uniforms.uAlpha], value: 0, easing: "linear", duration: 1e3, delay: 1500 }, 15e3), r.add({ targets: [av.cloud042.sprite.material.uniforms.uAlpha], value: 0, easing: "linear", duration: 1500, delay: 2e3 }, 15e3), r.add({ targets: [av.cloud05.sprite.material.uniforms.uAlpha], value: 0, easing: "linear", duration: 1e3, delay: 2e3 }, 2e4), r.add({ targets: [av.cloud06.sprite.material.uniforms.uAlpha], value: 0, easing: "linear", duration: 1e3, delay: 2e3 }, 3e4), r.add({ targets: [av.cloud07.sprite.material.uniforms.uAlpha], value: 0, easing: "linear", duration: 1e3, delay: 3800 }, 35e3), _f({ duration: 1 / 0, update: function() { r.seek(r.duration * iv.progress) } })
            }()
    }
    eg.onProgress = function(t) { Km.innerHTML = Math.round(100 * t) + "%", Jm.style.transform = "scaleX(" + t + ")" }, eg.onComplete = function() {
        sv();
        var n = new Uh,
            r = new gp,
            i = new Ln,
            o = [],
            a = Object.values(ov).map(function(t) { return t.group });

        function e() {
            var t = o.length;
            if (t)
                for (var e = 0; e < t; e++) { var n = o[e].object; if (n.userData && n.userData.onClick) return n }
        }

        function t(t) {
            i.x = t.clientX / wf.width * 2 - 1, i.y = 2 * -(t.clientY / wf.height) + 1,
                function() {
                    if (!zm.canRender) return;
                    var t = e();
                    t ? t.userData.onClick && wf.bodyEl.classList.add("is-hover") : wf.bodyEl.classList.remove("is-hover")
                }()
        }
        var s = _f({
                update: function() {
                    o.length = 0;
                    var t = n.getDelta(),
                        e = n.getElapsedTime();
                    Xg.update(t), eg.materials.cloud01.uniforms.uTime.value = 30 * e, eg.materials.cloud02.uniforms.uTime.value = 25 * e, eg.materials.cloud03.uniforms.uTime.value = 28 * e, eg.materials.cloud04.uniforms.uTime.value = 25 * e, eg.materials.cloud05.uniforms.uTime.value = 27 * e, eg.materials.cloudSection01.uniforms.uTime.value = 30 * e, eg.materials.cloudSection02.uniforms.uTime.value = 20 * e, eg.materials.cloudSection03.uniforms.uTime.value = 28 * e, eg.materials.cloudSection04.uniforms.uTime.value = 25 * e, eg.materials.cloudSection05.uniforms.uTime.value = 27 * e, eg.materials.cloudSection06.uniforms.uTime.value = 30 * e, eg.materials.cloudSection07.uniforms.uTime.value = 25 * e, r.setFromCamera(i, rg), r.intersectObjects(a, !0, o), ig.render(ng, rg)
                },
                duration: 1 / 0,
                autoplay: !1
            }),
            c = _f.timeline({}).add({ targets: Hm, scrollTop: Hm.querySelectorAll(".site-section")[1].offsetTop, duration: 3e3, easing: "easeOutCubic", autoplay: !1 }).add({ targets: [Vm], opacity: [0, 1], duration: 1e3, easing: "linear" }, "-=1000"),
            l = _f({ targets: Zm, opacity: 0, duration: 2e3, delay: 1e3, easing: "linear", complete: function() { Zm.parentNode.removeChild(Zm) }, autoplay: !1 });

        function u(t) { t.target.closest(".logo") ? wf.bodyEl.classList.contains("page-is-open") ? Zg.closePages() : _f({ targets: Hm, scrollTop: Hm.querySelectorAll(".site-section")[1].offsetTop, duration: 3e3, easing: "easeOutCubic" }) : zm.canRender && (!(t = e()) || (t = t.userData).onClick && t.onClick()) }
        var h = !1;

        function p() { h || (h = !0, c.pause()) }
        window.addEventListener("mousemove", t, !1), window.addEventListener("resize", og, !1), document.addEventListener("click", u, !1), document.addEventListener("wheel", p, !1), document.addEventListener("touchmove", p, !1), s.play(), l.play(), c.play(), wf.bodyEl.classList.add("is-ready")
    }, eg.init();
    console.log("%cCode by https://juliangarnier.com", "\n  font-size: 11px;\n  font-weight: bold;\n  font-family: monospace;\n")
}();